/*!
 * okay3d (MarsGIS for Cesium)三维地球平台  
 * 版本信息：v2.2.0, hash值: 92f1bc6a52dd56e63ace
 * 编译日期：2020-11-7 17:35:55     
 * 版权所有：Copyright by 欧科科技 http://cesium.marsgis.cn
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("cesium/Cesium"), require("@turf/turf"));
	else if(typeof define === 'function' && define.amd)
		define(["cesium/Cesium", "@turf/turf"], factory);
	else if(typeof exports === 'object')
		exports["okay3d"] = factory(require("cesium/Cesium"), require("@turf/turf"));
	else
		root["okay3d"] = factory(root["Cesium"], root["turf"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__33__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 91);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loopArrayForFun = exports.isArray = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.printVersion = printVersion;
exports.isNumber = isNumber;
exports.isString = isString;
exports.isObject = isObject;
exports.alert = alert;
exports.msg = msg;
exports.getRequest = getRequest;
exports.getRequestByName = getRequestByName;
exports.removeArrayItem = removeArrayItem;
exports.clone = clone;
exports.isPCBroswer = isPCBroswer;
exports.getExplorerInfo = getExplorerInfo;
exports.webglreport = webglreport;
exports.downloadBase64Image = downloadBase64Image;
exports.downloadFile = downloadFile;
exports.formatDegree = formatDegree;
exports.formatLength = formatLength;
exports.formatArea = formatArea;
exports.heightToZoom = heightToZoom;
exports.buffer = buffer;
exports.getGranularity = getGranularity;
exports.currentTime = currentTime;
exports.getProxyUrl = getProxyUrl;
exports.template = template;
exports.getAttrVal = getAttrVal;
exports.getPopupForConfig = getPopupForConfig;
exports.getTooltipForConfig = getTooltipForConfig;
exports.getPopup = getPopup;
exports.bindLayerPopup = bindLayerPopup;
exports.highlightEntity = highlightEntity;
exports.unHighlightEntity = unHighlightEntity;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _version = __webpack_require__(47);

var ver = _interopRequireWildcard(_version);

var _FlashingEntity = __webpack_require__(94);

var _turf = __webpack_require__(33);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//打印信息
function printVersion() {
    var msg = "%c\uD83C\uDF12%c Okay3D %c \u4E09\u7EF4\u5730\u7403\u5E73\u53F0\u8F6F\u4EF6 %c\n\n\u7248 \u672C \u53F7\uFF1A" + ver.version + "    \u3010Cesium\u7248\u672C\uFF1A" + Cesium.VERSION + "\u3011\n\u7F16\u8BD1\u65E5\u671F\uFF1A" + ver.update + " \n\u7248\u6743\u58F0\u660E\uFF1A\n1. Okay3D\u7248\u6743\u5B8C\u5168\u5C5E\u4E8E \"\u5E7F\u5DDE\u6B27\u79D1\u79D1\u6280\u6709\u9650\u516C\u53F8\".\n2. Okay3D\u4E2Dokay3d.js\u7A0B\u5E8F\u5305\uFF0C\u4EFB\u4F55\u4E2A\u4EBA\u548C\u673A\u6784\u5728\u9075\u5B88\u4E0B\u5217\u6761\u4EF6\u7684\u524D\u63D0\u4E0B\u6388\u6743\u6C38\u4E45\u4F7F\u7528\uFF1A\n    1\uFF09\u4E0D\u8FDB\u884C\u4EFB\u4F55\u5F62\u5F0F\u7684\u7834\u89E3\u548C\u88C1\u526A\uFF0C\u7A0B\u5E8F\u5305\u5B8C\u6574\u5F15\u7528\n    2\uFF09\u4FDD\u7559\u6B64\u7248\u6743\u4FE1\u606F\u5728\u63A7\u5236\u53F0\u8F93\u51FA\n\u6211\u4EEC\u4FDD\u7559\u5BF9\u6B64\u7248\u6743\u4FE1\u606F\u7684\u6700\u7EC8\u89E3\u91CA\u6743.\n\n";

    var c1 = '\n\tfont-size: 19px;\n\tpadding-left: 10px;\n\tcolor: rgb(240, 133, 25);\n',
        c2 = "\n\tfont-size: 17px;\n\tline-height: 1.5;\n\tfont-weight: 1000;\n\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";\n\tcolor: rgb(240, 133, 25);\n",
        c3 = "\n\tfont-size: 15px;\n\tline-height: 1.5;\n\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";\n\tfont-style: italic;\n\tcolor: rgb(240, 133, 25);\n\tpadding-bottom: 5px;\n",
        c4 = "\n\tfont-size: 12px;\n\tline-height: 1.5;\n\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";\n\tcolor: rgb(0, 138, 255);\n\t";
    console.log(msg, c1, c2, c3, c4);
}

function isNumber(obj) {
    return typeof obj == 'number' && obj.constructor == Number;
}

function isString(str) {
    return typeof str == 'string' && str.constructor == String;
}

function isObject(obj) {
    return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) == 'object' && obj.constructor == Object;
}

var isArray = exports.isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
};

function alert(msg, title) {
    if (window.haoutil && window.haoutil.alert) //此方法需要引用haoutil 
        window.haoutil.alert(msg, title);else if (window.layer) //此方法需要引用layer.js
        layer.alert(msg, {
            title: title || '提示',
            skin: 'layui-layer-lan layer-mars-dialog',
            closeBtn: 0,
            anim: 0
        });else window.alert(msg);
};

function msg(msg) {
    if (window.haoutil && window.haoutil.msg) //此方法需要引用haoutil 
        window.haoutil.msg(msg);else if (window.toastr) //此方法需要引用toastr 
        toastr.info(msg);else if (window.layer) layer.msg(msg); //此方法需要引用layer.js
    else window.alert(msg);
};

//url参数获取
function getRequest() {
    var url = location.search; //获取url中"?"符后的字串   
    var theRequest = new Object();
    if (url.indexOf("?") != -1) {
        var str = url.substr(1);
        var strs = str.split("&");
        for (var i = 0; i < strs.length; i++) {
            theRequest[strs[i].split("=")[0]] = decodeURI(strs[i].split("=")[1]);
        }
    }
    return theRequest;
}

function getRequestByName(name) {
    var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
    var r = window.location.search.substr(1).match(reg);
    if (r != null) return decodeURI(r[2]);
    return null;
}

Array.prototype.indexOf = Array.prototype.indexOf || function (val) {
    for (var i = 0; i < this.length; i++) {
        if (this[i] == val) return i;
    }
    return -1;
};

function removeArrayItem(arr, val) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] == val) {
            arr.splice(i, 1);
            return true;
        }
    }
    return false;
}

function clone(obj, removeKeys, level) {
    if (level == null) level = 5; //避免死循环，拷贝的层级最大深度
    if (removeKeys == null) removeKeys = ["_layer"];

    if (null == obj || "object" != (typeof obj === "undefined" ? "undefined" : _typeof(obj))) return obj;

    // Handle Date
    if (obj instanceof Date) {
        var copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (isArray(obj) && level >= 0) {
        var copy = [];
        for (var i = 0, len = obj.length; i < len; ++i) {
            copy[i] = clone(obj[i], removeKeys, level - 1);
        }
        return copy;
    }

    // Handle Object
    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object' && level >= 0) {
        try {
            var copy = {};
            for (var attr in obj) {
                if (typeof attr === 'function') continue;
                if (removeKeys.indexOf(attr) != -1) continue;

                if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr], removeKeys, level - 1);
            }
            return copy;
        } catch (e) {
            marslog.warn(e);
        }
    }
    return obj;
}

function isPCBroswer() {
    var sUserAgent = navigator.userAgent.toLowerCase();

    var bIsIpad = sUserAgent.match(/ipad/i) == "ipad";
    var bIsIphoneOs = sUserAgent.match(/iphone/i) == "iphone";
    var bIsMidp = sUserAgent.match(/midp/i) == "midp";
    var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == "rv:1.2.3.4";
    var bIsUc = sUserAgent.match(/ucweb/i) == "ucweb";
    var bIsAndroid = sUserAgent.match(/android/i) == "android";
    var bIsCE = sUserAgent.match(/windows ce/i) == "windows ce";
    var bIsWM = sUserAgent.match(/windows mobile/i) == "windows mobile";
    if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {
        return false;
    } else {
        return true;
    }
}

//获取浏览器类型及版本
function getExplorerInfo() {
    var explorer = window.navigator.userAgent.toLowerCase();
    //ie 
    if (explorer.indexOf("msie") >= 0) {
        var ver = Number(explorer.match(/msie ([\d]+)/)[1]);
        return { type: "IE", version: ver };
    }
    //firefox 
    else if (explorer.indexOf("firefox") >= 0) {
            var ver = Number(explorer.match(/firefox\/([\d]+)/)[1]);
            return { type: "Firefox", version: ver };
        }
        //Chrome
        else if (explorer.indexOf("chrome") >= 0) {
                var ver = Number(explorer.match(/chrome\/([\d]+)/)[1]);
                return { type: "Chrome", version: ver };
            }
            //Opera
            else if (explorer.indexOf("opera") >= 0) {
                    var ver = Number(explorer.match(/opera.([\d]+)/)[1]);
                    return { type: "Opera", version: ver };
                }
                //Safari
                else if (explorer.indexOf("Safari") >= 0) {
                        var ver = Number(explorer.match(/version\/([\d]+)/)[1]);
                        return { type: "Safari", version: ver };
                    }
    return { type: explorer, version: -1 };
}

//检测浏览器webgl支持
function webglreport() {
    var exinfo = getExplorerInfo();
    if (exinfo.type == "IE" && exinfo.version < 11) {
        return false;
    }

    try {
        var glContext;
        var canvas = document.createElement('canvas');
        var requestWebgl2 = typeof WebGL2RenderingContext !== 'undefined';
        if (requestWebgl2) {
            glContext = canvas.getContext('webgl2') || canvas.getContext('experimental-webgl2') || undefined;
        }
        if (glContext == null) {
            glContext = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') || undefined;
        }
        if (glContext == null) {
            return false;
        }
    } catch (e) {
        return false;
    }
    return true;
}

function download(fileName, blob) {
    var aLink = document.createElement('a');
    aLink.download = fileName;
    aLink.href = URL.createObjectURL(blob);
    document.body.appendChild(aLink);
    aLink.click();
    document.body.removeChild(aLink);
}

function base64Img2Blob(code) {
    var parts = code.split(';base64,');
    var contentType = parts[0].split(':')[1];
    var raw = window.atob(parts[1]);
    var rawLength = raw.length;

    var uInt8Array = new Uint8Array(rawLength);
    for (var i = 0; i < rawLength; ++i) {
        uInt8Array[i] = raw.charCodeAt(i);
    }
    return new Blob([uInt8Array], { type: contentType });
}

//下载导出图片
function downloadBase64Image(name, base64) {
    var blob = base64Img2Blob(base64);
    download(name + '.png', blob);
}

//下载保存文件
function downloadFile(fileName, string) {
    var blob = new Blob([string]);
    download(fileName, blob);
}

//格式化经度/纬度，返回度分秒字符串
function formatDegree(value) {
    value = Math.abs(value);
    var v1 = Math.floor(value); //度  
    var v2 = Math.floor((value - v1) * 60); //分  
    var v3 = Math.round((value - v1) * 3600 % 60); //秒  
    return v1 + '° ' + v2 + '\'  ' + v3 + '"';
};

//  计算长度后，格式化显示长度值, 可指定单位
//  unit支持:m、km、mile、zhang   默认自动判断 m 或 km
function formatLength(val, unit) {
    if (val == null) return "";

    if (unit == null || unit == "auto") {
        if (val < 1000) unit = "m";else unit = "km";
    }

    var valstr = "";
    switch (unit) {
        default:
        case "m":
            valstr = val.toFixed(2) + '米';
            break;
        case "km":
            valstr = (val * 0.001).toFixed(2) + '公里';
            break;
        case "mile":
            valstr = (val * 0.00054).toFixed(2) + '海里';
            break;
        case "zhang":
            valstr = (val * 0.3).toFixed(2) + '丈';
            break;
    }
    return valstr;
}

//  计算面积后，格式化显示面积值, 可指定单位
//  unit支持:m、km、mu、ha   默认自动判断 m 或 km
function formatArea(val, unit) {
    if (val == null) return "";

    if (unit == null || unit == "auto") {
        if (val < 1000000) unit = "m";else unit = "km";
    }

    var valstr = "";
    switch (unit) {
        default:
        case "m":
            valstr = val.toFixed(2) + '平方米';
            break;
        case "km":
            valstr = (val / 1000000).toFixed(2) + '平方公里';
            break;
        case "mu":
            valstr = (val * 0.0015).toFixed(2) + '亩';
            break;
        case "ha":
            valstr = (val * 0.0001).toFixed(2) + '公顷';
            break;
    }

    return valstr;
}

//根据高度获取地图层级
function heightToZoom(altitude) {
    var A = 40487.57;
    var B = 0.00007096758;
    var C = 91610.74;
    var D = -40467.74;

    return Math.round(D + (A - D) / (1 + Math.pow(altitude / C, B)));
}

//缓冲分析（比如是建筑物单体化时,缓冲扩大点范围）,单位：米
function buffer(geojson, width) {
    try {
        width = Cesium.defaultValue(width, 1);
        //API: http://turfjs.org/docs/#buffer
        geojson = (0, _turf.buffer)(geojson, width, { units: 'meters', steps: 64 });
    } catch (e) {
        marslog.log("缓冲分析失败");
        marslog.log(e);
    }
    return geojson;
}

//求Rectangle范围内 按count等比插值的granularity值 
function getGranularity(positions, count) {
    var recta = Cesium.Rectangle.fromCartesianArray(positions);
    var granularity = Math.max(recta.height, recta.width);
    granularity /= Cesium.defaultValue(count, 10); //默认分割10次
    return granularity;
}

//取当前时间，用于getValue传参
function currentTime() {
    if (window.viewer) return window.viewer.clock.currentTime;else return Cesium.JulianDate.fromDate(new Date());
}

//判断url加上配置的代理
function getProxyUrl(config) {
    if (!config.url || !config.proxy && !config.headers && !config.queryParameters) return config;

    if (config.url instanceof Cesium.Resource) {
        config.url.headers = config.headers;
        return config;
    }

    var opts = {};
    for (var key in config) {
        opts[key] = config[key];
    }
    opts.url = new Cesium.Resource({
        url: opts.url,
        proxy: opts.proxy ? new Cesium.DefaultProxy(opts.proxy) : null,
        headers: opts.headers,
        queryParameters: opts.queryParameters
    });

    return opts;
}

var templateRe = /\{ *([a-zA-Z0-9_\u4e00-\u9fa5]+) *\}/g;

//popup的字符串模板
function template(str, data) {
    if (str == null) return str;

    return str.replace(templateRe, function (str, key) {
        var value = data[key];
        if (!Cesium.defined(value)) return "";

        if (typeof value === 'function') {
            value = value(data);
            if (!Cesium.defined(value)) return "";
        } else if (value.getValue && typeof value.getValue == 'function') {
            value = value.getValue(currentTime());
            if (!Cesium.defined(value)) return "";
        }

        return value;
    });
}

//简化Cesium内的属性，去掉getValue等，取最简的键值对。方便popup、tooltip等使用
function getAttrVal(attr) {
    if (!attr) return attr;

    try {
        if (attr.getValue) attr = attr.getValue(currentTime());

        var newattr = {};
        if (attr._propertyNames && attr._propertyNames.length > 0) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = attr._propertyNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _key = _step.value;

                    var showval = attr[_key];
                    if (showval == null || showval == '' || showval == 'Null' || showval == 'Unknown') continue;

                    if (showval.getValue && typeof showval.getValue == 'function') {
                        newattr[_key] = showval.getValue(currentTime());
                    } else {
                        if (typeof showval === 'function') continue;
                        newattr[_key] = showval;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        } else {
            for (var key in attr) {
                var showval = attr[key];
                if (showval == null || showval == '' || showval == 'Null' || showval == 'Unknown') continue;

                if (showval.getValue && typeof showval.getValue == 'function') {
                    newattr[key] = showval.getValue(currentTime());
                } else {
                    if (typeof showval === 'function') continue;
                    newattr[key] = showval;
                }
            }
        }
        return newattr;
    } catch (e) {
        marslog.log("getAttrVal 出错");
        marslog.log(e);
    }
    return attr;
}

//根据config配置规则获取popup使用的html字符串
function getPopupForConfig(cfg, attr) {
    var _title = cfg.popupNameField ? attr[cfg.popupNameField] : cfg.name;
    if (cfg.popupNoTitle) _title = null;

    if (cfg.popup) {
        return getPopup(cfg.popup, attr, { title: _title });
    } else if (cfg.columns) {
        return getPopup(cfg.columns, attr, { title: _title });
    }
    return false;
}

//根据config配置规则获取tooltip使用的html字符串
function getTooltipForConfig(cfg, attr) {
    var _title = cfg.tooltipNameField ? attr[cfg.tooltipNameField] : cfg.name;

    if (cfg.tooltip) {
        return getPopup(cfg.tooltip, attr, { title: _title });
    }
    return false;
}

//获取Popup或Tooltip格式化字符串
function getPopup(cfg, attr, options) {
    if (!attr) return false;

    options = options || {};
    if (isString(options)) {
        //兼容旧版本参数
        options = { title: options };
    }

    var title = options.title;
    var isEdit = options.edit;

    attr = getAttrVal(attr); //取值

    if (isArray(cfg)) {
        //数组  
        var countsok = 0;
        var inhtml = title ? '<div class="mars-popup-titile">' + title + '</div>' : '<div style="height: 10px;"></div>';
        inhtml += '<div class="mars-popup-content" >';
        for (var i = 0; i < cfg.length; i++) {
            var thisfield = cfg[i];
            if (thisfield == null) continue;

            var col = thisfield.field;

            if (thisfield.type == 'details' || thisfield.type == 'button') {
                //详情等button按钮 
                var showval = String.prototype.trim.call(attr[col || "OBJECTID"]);
                if (showval == null) continue;

                var onclickHtml = '';
                var callback = thisfield.callback || thisfield.calback;
                if (callback) {
                    onclickHtml = "onclick=\"" + callback + "('" + showval + "');\"  ";
                }

                inhtml += "<div style=\"text-align: center;padding: 2px 0;\">\n                            <button type=\"button\"  " + onclickHtml + "\n                            data-type=\"" + col + "\" class=\"btn btn-primary btn-sm okay3d-popup-btn\" >" + (thisfield.name || '查看详情') + "</button>\n                        </div>";
                continue;
            } else if (thisfield.type == 'html') {
                inhtml += '<div>' + thisfield.html + '</div>';
                continue;
            }

            if (!isEdit) {
                //非编辑状态隐藏空值
                if (col == null || attr[col] == null) continue;
                if (typeof attr[col] === 'function') continue;
            }

            //值
            var showval = String.prototype.trim.call(attr[col] || "");

            if (!isEdit) {
                //非编辑状态隐藏空值
                if (showval == null || showval == '' || showval == 'Null' || showval == 'Unknown' || showval == '0' || showval.length == 0) continue;
            }

            if (thisfield.format) {
                //使用外部 格式化js方法
                try {
                    showval = eval(thisfield.format + "(" + showval + ")");
                } catch (e) {
                    marslog.log("getPopupByConfig error:" + thisfield.format);
                }
            }

            if (isEdit) {
                switch (thisfield.type) {
                    default:
                    case "string":
                    case "number":
                        showval = "<input type=\"" + (thisfield.type || 'text') + "\" class=\"okay3d-popup-edititem\" style=\"width:" + (options.width || 190) + "px;\"\n                        data-type=\"" + col + "\" value=\"" + showval + "\" placeholder=\"\u8BF7\u8F93\u5165 " + thisfield.name + "\"  />";
                        break;
                    case "textarea":
                        showval = "<textarea class=\"okay3d-popup-edititem\" style=\"width:" + (options.width || 190) + "px;\"\n                        data-type=\"" + col + "\"  placeholder=\"\u8BF7\u8F93\u5165 " + thisfield.name + "\"  >" + showval + "</textarea>";
                        break;
                }
            }

            if (thisfield.unit) {
                showval += thisfield.unit;
            }

            inhtml += '<div><label>' + thisfield.name + '</label>' + showval + '</div>';
            countsok++;
        }
        inhtml += "</div>";

        if (countsok == 0) return false;
        return inhtml;
    } else if ((typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) === 'object') {
        //对象,type区分逻辑
        switch (cfg.type) {
            case "iframe":
                var _url = template(cfg.url, attr);

                var inhtml = '<iframe id="ifarm" src="' + _url + '"  style="width:' + (cfg.width || '300') + 'px;height:' + (cfg.height || '300') + 'px;overflow:hidden;margin:0;" scrolling="no" frameborder="0" ></iframe>';
                return inhtml;
                break;
            case "javascript":
                //回调方法 
                var callback = cfg.callback || cfg.calback;
                return eval(callback + "(" + JSON.stringify(attr) + ")");
                break;
        }
    } else if (typeof cfg === 'function') {
        return cfg(attr);
    } else if (cfg == "all") {
        //全部显示
        var countsok = 0;
        var inhtml = title ? '<div class="mars-popup-titile">' + title + '</div>' : '';
        inhtml += '<div class="mars-popup-content" >';
        for (var col in attr) {
            try {
                if (col == null || attr[col] == null) continue;

                if (col == "Shape" || col == "FID" || col == "OBJECTID" || col == "_definitionChanged" || col == "_propertyNames") continue; //不显示的字段

                if (col.substr(0, 1) == "_") {
                    col = col.substring(1); //cesium 内部属性
                }

                if (_typeof(attr[col]) === 'object' && attr[col].hasOwnProperty && attr[col].hasOwnProperty('getValue')) attr[col] = attr[col].getValue(currentTime());
                if (typeof attr[col] === 'function') continue;

                var showval = String.prototype.trim.call(attr[col]);
                if (showval == null || showval == '' || showval == 'Null' || showval == 'Unknown' || showval == '0' || showval.length == 0) continue; //不显示空值，更美观友好

                inhtml += '<div><label>' + col + '</label>' + showval + '</div>';
                countsok++;
            } catch (e) {
                marslog.log(e);
            }
        }
        inhtml += "</div>";

        if (countsok == 0) return false;
        return inhtml;
    } else {
        //格式化字符串 
        return template(cfg, attr);
    }

    return false;
}

//对okay3d内置图层的绑定处理（图层一般因为有属性读取及格式化处理）
function bindLayerPopup(popup, getHtmlFun) {
    //显示内容
    var inhtml;
    if ((typeof popup === "undefined" ? "undefined" : _typeof(popup)) === 'object' && popup.html) {
        inhtml = popup.html;
    } else {
        inhtml = popup;
        popup = {
            html: inhtml
        };
    }

    if (typeof inhtml === 'function') {
        //自定义的回调方法 
        popup.html = function (entity, cartesian, callback) {
            return inhtml(entity, cartesian, callback);
        };
    } else {
        //内置的格式化方法，一般使用getPopup
        popup.html = function (entity) {
            return getHtmlFun(entity);
        };
    }
    popup.anchor = popup.anchor || [0, -15];

    return popup;
}

var loopArrayForFun = exports.loopArrayForFun = _FlashingEntity.loopArrayForFun;

var lastFlashingEntity;

//定时闪烁高亮Entity（点、线、面）
function highlightEntity(entitys, opts) {
    var flashingEntity = new _FlashingEntity.FlashingEntity();
    flashingEntity.highlight(entitys, opts);

    lastFlashingEntity = flashingEntity;
    return flashingEntity;
}

//取消定时闪烁高亮Entity（点、线、面）
function unHighlightEntity(flashingEntity) {
    if (flashingEntity) return flashingEntity.unHighlight();else if (lastFlashingEntity) return lastFlashingEntity.unHighlight();
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.aroundPoint = exports.windingPoint = undefined;
exports.formatNum = formatNum;
exports.formatPosition = formatPosition;
exports.getPositionValue = getPositionValue;
exports.formatRectangle = formatRectangle;
exports.getRectangle = getRectangle;
exports.getMaxHeight = getMaxHeight;
exports.addPositionsHeight = addPositionsHeight;
exports.setPositionsHeight = setPositionsHeight;
exports.getSurfaceHeight = getSurfaceHeight;
exports.getSurface3DTilesHeight = getSurface3DTilesHeight;
exports.getSurfaceTerrainHeight = getSurfaceTerrainHeight;
exports.setPositionSurfaceHeight = setPositionSurfaceHeight;
exports.getCurrentMousePosition = getCurrentMousePosition;
exports.getCenter = getCenter;
exports.pickCenterPoint = pickCenterPoint;
exports.getExtent = getExtent;
exports.getCameraView = getCameraView;
exports.centerOfMass = centerOfMass;
exports.isInPoly = isInPoly;
exports.getPositionByGeoJSON = getPositionByGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _index = __webpack_require__(20);

var drawAttr = _interopRequireWildcard(_index);

var _Attr = __webpack_require__(21);

var polygonAttr = _interopRequireWildcard(_Attr);

var _tileset = __webpack_require__(27);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _layer = __webpack_require__(23);

var _turf = __webpack_require__(33);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//格式化 数字 小数位数
function formatNum(num, digits) {
    return Number(Number(num).toFixed(digits || 0));
}

//格式化坐标点为可显示的可理解格式（如：经度x:123.345345、纬度y:31.324324、高度z:123.1）。
function formatPosition(position) {
    if (!position) return null;
    var carto = Cesium.Cartographic.fromCartesian(position);
    var result = {};
    result.y = formatNum(Cesium.Math.toDegrees(carto.latitude), 6);
    result.x = formatNum(Cesium.Math.toDegrees(carto.longitude), 6);
    result.z = formatNum(carto.height, 2);
    return result;
}

//获取position的最终value值，因为cesium经常属性或绑定一层，通过该方法可以内部去判断是否有getValue或_value进行取最终value值。
function getPositionValue(position, time) {
    if (!position) return position;

    var _position;
    if (position instanceof Cesium.Cartesian3) {
        _position = position;
    } else if (position._value && position._value instanceof Cesium.Cartesian3) {
        _position = position._value;
    } else if (typeof position.getValue == 'function') {
        _position = position.getValue(time || (0, _util.currentTime)());
    }

    return _position;
}

//格式化Rectangle
function formatRectangle(rectangle) {
    var west = formatNum(Cesium.Math.toDegrees(rectangle.west), 6);
    var east = formatNum(Cesium.Math.toDegrees(rectangle.east), 6);
    var north = formatNum(Cesium.Math.toDegrees(rectangle.north), 6);
    var south = formatNum(Cesium.Math.toDegrees(rectangle.south), 6);

    return {
        xmin: west,
        xmax: east,
        ymin: south,
        ymax: north
    };
}

//获取坐标的边界
function getRectangle(positions, isFormat) {
    //剔除null值的数据
    for (var i = positions.length - 1; i >= 0; i--) {
        if (!Cesium.defined(positions[i])) {
            positions.splice(i, 1);
        }
    }

    var rectangle = Cesium.Rectangle.fromCartesianArray(positions);
    if (isFormat) return formatRectangle(rectangle);else return rectangle;
}

/**
 * 获取坐标数组中最高高程值
 * @param {Array} positions Array<Cartesian3> 笛卡尔坐标数组
 * @param {Number} defaultVal 默认高程值
 */
function getMaxHeight(positions, defaultVal) {
    if (defaultVal == null) defaultVal = 0;

    var maxHeight = defaultVal;
    if (positions == null || positions.length == 0) return maxHeight;

    for (var i = 0; i < positions.length; i++) {
        var tempCarto = Cesium.Cartographic.fromCartesian(positions[i]);
        if (tempCarto.height > maxHeight) {
            maxHeight = tempCarto.height;
        }
    }
    return formatNum(maxHeight, 2);
}

/**
 * 在坐标基础海拔上增加指定的海拔高度值
 * @param {Array} positions Cartesian3类型的数组
 * @param {Number} height 高度值
 * @return {Array} Cartesian3类型的数组
 */
function addPositionsHeight(positions, addHeight) {
    addHeight = Number(addHeight) || 0;

    if (isNaN(addHeight) || addHeight == 0) return positions;

    if (positions instanceof Array) {
        var arr = [];
        for (var i = 0, len = positions.length; i < len; i++) {
            var car = Cesium.Cartographic.fromCartesian(positions[i]);
            var point = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
            arr.push(point);
        }
        return arr;
    } else {
        var car = Cesium.Cartographic.fromCartesian(positions);
        return Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
    }
}

/**
 * 设置坐标中海拔高度为指定的高度值
 * @param {Array} positions Cartesian3类型的数组
 * @param {Number} height 高度值
 * @return {Array} Cartesian3类型的数组
 */
function setPositionsHeight(positions, height) {
    height = Number(height) || 0;

    if (positions instanceof Array) {
        var arr = [];
        for (var i = 0, len = positions.length; i < len; i++) {
            var car = Cesium.Cartographic.fromCartesian(positions[i]);
            var point = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
            arr.push(point);
        }
        return arr;
    } else {
        var car = Cesium.Cartographic.fromCartesian(positions);
        return Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
    }
}

/**
 * 获取坐标的贴地(或贴模型)高度
 * opts支持:  是否在has3dtiles:true , 是否异步 asyn:true  异步回调方法callback
 */
function getSurfaceHeight(scene, position, opts) {
    if (!position) return position;
    if (scene instanceof Cesium.Viewer) //兼容传入viewer
        scene = scene.scene;
    opts = opts || {};

    //是否在3ditiles上面
    var _has3dtiles = Cesium.defaultValue(opts.has3dtiles, Cesium.defined((0, _tileset.pick3DTileset)(scene, position)));
    if (_has3dtiles) {
        //求贴模型的高度
        return getSurface3DTilesHeight(scene, position, opts);
    } else {
        //求贴地形高度
        return getSurfaceTerrainHeight(scene, position, opts);
    }
}

/**
 * 获取坐标的 贴模型高度
 * opts支持:   是否异步 asyn:true  异步回调方法callback返回“新高度”和“原始的Cartographic坐标”
 */
function getSurface3DTilesHeight(scene, position, opts) {
    opts = opts || {};

    //原始的Cartographic坐标
    opts.cartesian = opts.cartesian || Cesium.Cartographic.fromCartesian(position);
    var carto = opts.cartesian;
    var callback = opts.callback || opts.calback; //兼容不同参数名

    //是否异步求精确高度 
    if (opts.asyn) {
        scene.clampToHeightMostDetailed([position], opts.objectsToExclude, 0.2).then(function (clampedPositions) {
            var clampedPt = clampedPositions[0];
            if (Cesium.defined(clampedPt)) {
                var cartiles = Cesium.Cartographic.fromCartesian(clampedPt);
                var heightTiles = cartiles.height;
                if (Cesium.defined(heightTiles) && heightTiles > -1000) {
                    if (callback) callback(heightTiles, cartiles);
                    return;
                }
            }
            //说明没在模型上，继续求地形上的高度
            getSurfaceTerrainHeight(scene, position, opts);
        });
    } else {
        //取贴模型高度
        var heightTiles = scene.sampleHeight(carto, opts.objectsToExclude, 0.2);
        if (Cesium.defined(heightTiles) && heightTiles > -1000) {
            if (callback) callback(heightTiles, carto);
            return heightTiles;
        }
    }

    return 0; //表示取值失败
}

/**
 * 获取坐标的 贴地高度
 * opts支持:   是否异步 asyn:true  异步回调方法callback
 */
function getSurfaceTerrainHeight(scene, position, opts) {
    opts = opts || {};

    //原始的Cartographic坐标
    var carto = opts.cartesian || Cesium.Cartographic.fromCartesian(position);
    var callback = opts.callback || opts.calback; //兼容不同参数名

    var _hasTerrain = (0, _layer.hasTerrain)(scene); //是否有地形
    if (!_hasTerrain) {
        //不存在地形，直接返回
        if (callback) callback(carto.height, carto);
        return carto.height;
    }

    //是否异步求精确高度 
    if (opts.asyn) {
        Cesium.when(Cesium.sampleTerrainMostDetailed(scene.terrainProvider, [carto]), function (samples) {
            var clampedCart = samples[0];
            var heightTerrain;
            if (Cesium.defined(clampedCart) && Cesium.defined(clampedCart.height)) {
                heightTerrain = clampedCart.height;
            } else {
                heightTerrain = scene.globe.getHeight(carto);
            }
            if (callback) callback(heightTerrain, carto);
        });
    } else {
        var heightTerrain = scene.globe.getHeight(carto);
        if (Cesium.defined(heightTerrain) && heightTerrain > -1000) {
            if (callback) callback(heightTerrain, carto);
            return heightTerrain;
        }
    }
    return 0; //表示取值失败
}

/**
 * 设置坐标中海拔高度为贴地或贴模型的高度 
 * opts支持:  是否在has3dtiles:true , 是否异步 asyn:true  异步回调方法callback
 */
function setPositionSurfaceHeight(scene, position, opts) {
    if (!position) return position;

    opts = opts || {};
    var carto = Cesium.Cartographic.fromCartesian(position);

    var height = getSurfaceHeight(scene, position, opts);
    if (height != 0 || Cesium.defined(opts.maxHeight) && height <= opts.maxHeight) {
        if (opts.relativeHeight) height += carto.height; //Cesium.HeightReference.RELATIVE_TO_GROUND时
        var positionNew = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, height);
        return positionNew;
    }
    return position;
}

function hasPickedModel(pickedObject, noPickEntity) {
    if (Cesium.defined(pickedObject.id)) {
        //entity 
        var entity = pickedObject.id;
        if (entity._noMousePosition) return entity; //排除标识不拾取的对象
        if (noPickEntity && entity == noPickEntity) return entity;
    }

    if (Cesium.defined(pickedObject.primitive)) {
        //primitive
        var primitive = pickedObject.primitive;
        if (primitive._noMousePosition) return primitive; //排除标识不拾取的对象
        if (noPickEntity && primitive == noPickEntity) return primitive;
    }

    return null;
}

/**
 * 获取鼠标当前的屏幕坐标位置的三维Cesium坐标
 * @param {Cesium.Scene} scene 
 * @param {Cesium.Cartesian2} position 二维屏幕坐标位置
 * @param {Cesium.Entity} noPickEntity 排除的对象（主要用于绘制中，排除对自己本身的拾取）
 */
function getCurrentMousePosition(scene, position, noPickEntity) {
    var cartesian;

    //在模型上提取坐标   
    var pickedObject;
    try {
        pickedObject = scene.pick(position, 5, 5);
    } catch (e) {
        marslog.log("scene.pick 拾取位置时异常");
        marslog.log(e);
    }

    if (scene.pickPositionSupported && Cesium.defined(pickedObject)) {
        //pickPositionSupported :判断是否支持深度拾取,不支持时无法进行鼠标交互绘制

        var pcEntity = hasPickedModel(pickedObject, noPickEntity);
        if (pcEntity) {
            if (pcEntity.show) {
                pcEntity.show = false; //先隐藏被排除的noPickEntity对象
                cartesian = getCurrentMousePosition(scene, position, noPickEntity);
                pcEntity.show = true; //还原被排除的noPickEntity对象
                if (cartesian) {
                    return cartesian;
                } else {
                    marslog.log("拾取到被排除的noPickEntity模型");
                }
            }
        } else {
            cartesian = scene.pickPosition(position);
            if (Cesium.defined(cartesian)) {
                var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
                if (cartographic.height >= 0) return cartesian;

                //不是entity时，支持3dtiles地下
                if (!Cesium.defined(pickedObject.id) && cartographic.height >= -500) return cartesian;
                //marslog.log("scene.pickPosition 拾取模型时 高度值异常：" + cartographic.height);
            } else {
                    //marslog.log("scene.pickPosition 拾取模型 返回为空");
                }
        }
    } else {}
        //marslog.log("scene.pick 拾取位置 返回为空");


        //超图s3m数据拾取
    if (Cesium.defined(Cesium.S3MTilesLayer)) {
        cartesian = scene.pickPosition(position);
        if (Cesium.defined(cartesian)) {
            return cartesian;
        }
    }

    //onlyPickModelPosition是在 ViewerEx 中定义的对外属性
    //通过 viewer.mars.onlyPickModelPosition 进行修改
    if (scene.onlyPickModelPosition) return cartesian; //只取模型上的时候，不继续读取了


    //测试scene.pickPosition和globe.pick的适用场景 https://zhuanlan.zhihu.com/p/44767866
    //1. globe.pick的结果相对稳定准确，不论地形深度检测开启与否，不论加载的是默认地形还是别的地形数据；
    //2. scene.pickPosition只有在开启地形深度检测，且不使用默认地形时是准确的。
    //注意点： 1. globe.pick只能求交地形； 2. scene.pickPosition不仅可以求交地形，还可以求交除地形以外其他所有写深度的物体。

    //提取鼠标点的地理坐标 
    if (scene.mode === Cesium.SceneMode.SCENE3D) {
        //三维模式下
        var pickRay = scene.camera.getPickRay(position);
        cartesian = scene.globe.pick(pickRay, scene);
    } else {
        //二维模式下
        cartesian = scene.camera.pickEllipsoid(position, scene.globe.ellipsoid);
    }

    if (Cesium.defined(cartesian) && scene.camera.positionCartographic.height < 10000) {
        var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
        // marslog.log(cartographic.height);
        if (cartographic.height < -5000) return null; //屏蔽无效值
    }

    return cartesian;
}

//提取屏幕中心点坐标
function getCenter(viewer, isToWgs) {
    var bestTarget = pickCenterPoint(viewer.scene);
    if (!Cesium.defined(bestTarget)) {
        bestTarget = setPositionSurfaceHeight(viewer, viewer.scene.camera.positionWC);
    }

    var result = formatPosition(bestTarget);
    if (isToWgs) result = viewer.mars.point2wgs(result); //坐标转换为wgs

    // 获取地球中心点世界位置  与  摄像机的世界位置  之间的距离
    // var distance = Cesium.Cartesian3.distance(bestTarget, viewer.scene.camera.positionWC);
    // result.cameraZ = distance;

    return result;
}

//取屏幕中心点坐标
function pickCenterPoint(scene) {
    var canvas = scene.canvas;
    var center = new Cesium.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight / 2);

    var ray = scene.camera.getPickRay(center);
    var target = scene.globe.pick(ray, scene);
    if (!target) target = scene.camera.pickEllipsoid(center);
    return target;
}

//提取地球视域边界
function getExtent(target, opts) {
    opts = opts || {};

    // 范围对象
    var extent = {
        xmin: 0,
        xmax: 0,
        ymin: 0,
        ymax: 0
    };

    if (target instanceof Cesium.Viewer) {
        // var rectangle = viewer.camera.computeViewRectangle(); //不支持二维模式
        // if (rectangle == null) return null; 
        // var extent = formatRectangle(rectangle);  // 范围对象

        //默认值：中国区域
        extent = {
            xmin: 70,
            xmax: 140,
            ymin: 0,
            ymax: 55,
            height: 0
        };

        // 得到当前三维场景
        var viewer = target;
        var scene = viewer.scene;

        // 得到当前三维场景的椭球体
        var ellipsoid = scene.globe.ellipsoid;
        var canvas = scene.canvas;

        // canvas左上角
        var car3_lt = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(0, 0), ellipsoid);
        if (car3_lt) {
            // 在椭球体上
            var carto_lt = ellipsoid.cartesianToCartographic(car3_lt);
            extent.xmin = Cesium.Math.toDegrees(carto_lt.longitude);
            extent.ymax = Cesium.Math.toDegrees(carto_lt.latitude);
            extent.height = Math.max(extent.height, carto_lt.height);
        } else {
            // 不在椭球体上 
            var xMax = canvas.width / 2;
            var yMax = canvas.height / 2;

            var car3_lt2;
            // 这里每次10像素递加，一是10像素相差不大，二是为了提高程序运行效率
            for (var yIdx = 0; yIdx <= yMax; yIdx += 10) {
                var xIdx = yIdx <= xMax ? yIdx : xMax;
                car3_lt2 = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(xIdx, yIdx), ellipsoid);
                if (car3_lt2) break;
            }
            if (car3_lt2) {
                var carto_lt = ellipsoid.cartesianToCartographic(car3_lt2);
                extent.xmin = Cesium.Math.toDegrees(carto_lt.longitude);
                extent.ymax = Cesium.Math.toDegrees(carto_lt.latitude);
                extent.height = Math.max(extent.height, carto_lt.height);
            }
        }

        // canvas右下角
        var car3_rb = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(canvas.width, canvas.height), ellipsoid);
        if (car3_rb) {
            // 在椭球体上
            var carto_rb = ellipsoid.cartesianToCartographic(car3_rb);
            extent.xmax = Cesium.Math.toDegrees(carto_rb.longitude);
            extent.ymin = Cesium.Math.toDegrees(carto_rb.latitude);
            extent.height = Math.max(extent.height, carto_rb.height);
        } else {
            // 不在椭球体上
            var xMax = canvas.width / 2;
            var yMax = canvas.height / 2;

            var car3_rb2;
            // 这里每次10像素递减，一是10像素相差不大，二是为了提高程序运行效率
            for (var yIdx = canvas.height; yIdx >= yMax; yIdx -= 10) {
                var xIdx = yIdx >= xMax ? yIdx : xMax;
                car3_rb2 = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(xIdx, yIdx), ellipsoid);
                if (car3_rb2) break;
            }
            if (car3_rb2) {
                var carto_rb = ellipsoid.cartesianToCartographic(car3_rb2);
                extent.xmax = Cesium.Math.toDegrees(carto_rb.longitude);
                extent.ymin = Cesium.Math.toDegrees(carto_rb.latitude);
                extent.height = Math.max(extent.height, carto_rb.height);
            }
        }

        if (opts.isToWgs) {
            //坐标转换为wgs
            var pt1 = viewer.mars.point2wgs({
                x: extent.xmin,
                y: extent.ymin
            });
            extent.xmin = pt1.x;
            extent.ymin = pt1.y;

            var pt2 = viewer.mars.point2wgs({
                x: extent.xmax,
                y: extent.ymax
            });
            extent.xmax = pt2.x;
            extent.ymax = pt2.y;
        }
    } else if (target instanceof Cesium.Entity) {
        //传入Entity对象 
        var positions = drawAttr.getPositions(target);
        extent = getRectangle(positions, true);
        extent.height = getMaxHeight(positions);
    } else if ((0, _util.isArray)(target)) {
        //传入Entity对象数组
        var positions = [];
        for (var i = 0, len = target.length; i < len; i++) {
            var pts = drawAttr.getPositions(target[i]);
            positions = positions.concat(pts);
        }
        extent = getRectangle(positions, true);
        extent.height = getMaxHeight(positions);
    }

    //交换
    if (extent.xmax < extent.xmin) {
        var temp = extent.xmax;
        extent.xmax = extent.xmin;
        extent.xmin = temp;
    }
    if (extent.ymax < extent.ymin) {
        var temp = extent.ymax;
        extent.ymax = extent.ymin;
        extent.ymin = temp;
    }

    //缩放
    if (opts.scale) {
        var old_xmin = extent.xmin;
        var old_xmax = extent.xmax;
        var old_ymin = extent.ymin;
        var old_ymax = extent.ymax;

        //限定最大倍数
        if (opts.scale > 3) opts.scale = 3;
        if (opts.scale < -3) opts.scale = -3;

        var stepx = (extent.xmax - extent.xmin) * opts.scale;
        extent.xmin -= stepx;
        extent.xmax += stepx;
        var stepy = (extent.ymax - extent.ymin) * opts.scale;
        extent.ymin -= stepy;
        extent.ymax += stepy;

        //如果超出地球范围，还原放大的值
        if (extent.xmin < -180 || extent.xmax > 180 || extent.ymin < -90 || extent.ymax > 90) {
            extent.xmin = old_xmin;
            extent.xmax = old_xmax;
            extent.ymin = old_ymin;
            extent.ymax = old_ymax;
        }
    }

    //截取长度
    if (opts.formatNum) {
        extent.xmin = formatNum(extent.xmin, 6);
        extent.xmax = formatNum(extent.xmax, 6);
        extent.ymin = formatNum(extent.ymin, 6);
        extent.ymax = formatNum(extent.ymax, 6);
    }

    return extent;
}

//提取相机视角范围参数 
function getCameraView(viewer, isToWgs) {
    var camera = viewer.camera;
    var position = camera.positionCartographic;

    var bookmark = {};
    bookmark.y = formatNum(Cesium.Math.toDegrees(position.latitude), 6);
    bookmark.x = formatNum(Cesium.Math.toDegrees(position.longitude), 6);
    bookmark.z = formatNum(position.height, 2);
    bookmark.heading = formatNum(Cesium.Math.toDegrees(camera.heading || 0) % 360, 1);
    bookmark.pitch = formatNum(Cesium.Math.toDegrees(camera.pitch || 0) % 360, 1);
    bookmark.roll = formatNum(Cesium.Math.toDegrees(camera.roll || 0) % 360, 1);

    if (isToWgs) bookmark = viewer.mars.point2wgs(bookmark); //坐标转换为wgs

    return bookmark;
}

//Turf求面的中心点 
function centerOfMass(positions, height) {
    try {
        if (positions.length == 1) {
            return positions[0];
        } else if (positions.length == 2) {
            return Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
        }

        if (height == null) {
            height = getMaxHeight(positions);
        }

        var coordinates = pointconvert.cartesians2lonlats(positions);
        coordinates.push(coordinates[0]);

        var center = (0, _turf.centerOfMass)({
            type: "Feature",
            geometry: {
                type: "Polygon",
                coordinates: [coordinates]
            }
        });
        var centerX = center.geometry.coordinates[0];
        var centerY = center.geometry.coordinates[1];

        //所求的中心点在边界外时，求矩形中心点
        var extent = getRectangle(positions, true);
        if (centerX < extent.xmin || centerX > extent.xmax || centerY < extent.ymin || centerY > extent.ymax) {
            centerX = (extent.xmin + extent.xmax) / 2;
            centerY = (extent.ymin + extent.ymax) / 2;
        }

        var ptcenter = Cesium.Cartesian3.fromDegrees(centerX, centerY, height);
        return ptcenter;
    } catch (e) {
        return positions[Math.floor(positions.length / 2)];
    }
}

//点 是否在 entity（面、圆、多边形）内
function isInPoly(position, entity) {
    if (!entity || !position) return false;

    if (entity.rectangle) {
        var rectangle = entity.rectangle.coordinates.getValue((0, _util.currentTime)());

        var isInRectangle = Cesium.Rectangle.contains(rectangle, Cesium.Cartographic.fromCartesian(position));
        return isInRectangle;
    } else if (entity.ellipse) {
        var center = getPositionValue(entity.position);
        center = setPositionsHeight(center, 0);
        var radiu = entity.ellipse.semiMajorAxis.getValue((0, _util.currentTime)());

        var len = Cesium.Cartesian3.distance(center, position);
        return len <= radiu; //小于半径的说明在圆内
    } else if (entity.polygon) {
        var pt = {
            type: "Feature",
            geometry: { type: "Point", coordinates: pointconvert.cartesian2lonlat(position) }
        };
        var poly = polygonAttr.toGeoJSON(entity);
        var isInArea = (0, _turf.booleanPointInPolygon)(pt, poly); //turf插件计算的 
        return isInArea;
    } else if (entity.type && entity.type == "Feature") {
        //entity为geojson 
        var pt = {
            type: "Feature",
            geometry: { type: "Point", coordinates: pointconvert.cartesian2lonlat(position) }
        };
        var isInArea = (0, _turf.booleanPointInPolygon)(pt, entity); //turf插件计算的 
        return isInArea;
    }
    return false;
}

//geojson转entity
function getPositionByGeoJSON(geojson, defHeight) {
    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
        coords = geometry ? geometry.coordinates : null;

    if (!coords && !geometry) {
        return null;
    }

    switch (geometry.type) {
        case 'Point':
            return pointconvert.lonlat2cartesian(coords, defHeight);
        case 'MultiPoint':
        case 'LineString':
            return pointconvert.lonlats2cartesians(coords, defHeight);

        case 'MultiLineString':
        case 'Polygon':
            return pointconvert.lonlats2cartesians(coords[0], defHeight);
        case 'MultiPolygon':
            return pointconvert.lonlats2cartesians(coords[0][0], defHeight);
        default:
            throw new Error('Invalid GeoJSON object.');
    }
}

//绕点 环绕飞行
var windingPoint = exports.windingPoint = {
    isStart: false,
    viewer: null,
    start: function start(viewer, point) {
        this.viewer = viewer;
        if (point && point instanceof Cesium.Cartesian3) {
            this.position = point;
        } else {
            if (!point) point = getCenter(viewer);
            this.position = Cesium.Cartesian3.fromDegrees(point.x, point.y, point.z);
        }

        this.distance = point.distance || Cesium.Cartesian3.distance(this.position, viewer.camera.positionWC); // 给定相机距离点多少距离飞行 
        this.angle = 360 / (point.time || 60); //time：给定飞行一周所需时间(单位 秒)

        this.time = viewer.clock.currentTime.clone();
        this.heading = viewer.camera.heading; // 相机的当前heading
        this.pitch = viewer.camera.pitch;

        this.viewer.clock.shouldAnimate = true;
        this.viewer.clock.onTick.addEventListener(this.clock_onTickHandler, this);
        this.isStart = true;
    },
    clock_onTickHandler: function clock_onTickHandler(e) {
        var delTime = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time); // 当前已经过去的时间，单位 秒
        var heading = Cesium.Math.toRadians(delTime * this.angle) + this.heading;

        this.viewer.scene.camera.setView({
            destination: this.position, // 点的坐标
            orientation: {
                heading: heading,
                pitch: this.pitch
            }
        });
        this.viewer.scene.camera.moveBackward(this.distance);
    },
    stop: function stop() {
        if (!this.isStart) return;

        if (this.viewer) this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
        this.isStart = false;
    }
};

//固定点 向四周旋转
var aroundPoint = exports.aroundPoint = {
    isStart: false,
    viewer: null,
    start: function start(viewer, point) {
        this.viewer = viewer;
        if (point && point instanceof Cesium.Cartesian3) {
            this.position = point;
        } else {
            if (!point) point = getCenter(viewer);
            this.position = Cesium.Cartesian3.fromDegrees(point.x, point.y, point.z);
        }

        this.angle = 360 / (point.time || 60); //time：给定飞行一周所需时间(单位 秒)

        this.time = viewer.clock.currentTime.clone();
        this.heading = viewer.camera.heading; // 相机的当前heading
        this.pitch = viewer.camera.pitch;

        this.viewer.clock.shouldAnimate = true;
        this.viewer.clock.onTick.addEventListener(this.clock_onTickHandler, this);
        this.isStart = true;
    },
    clock_onTickHandler: function clock_onTickHandler(e) {
        // 当前已经过去的时间，单位s
        var delTime = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time);
        var heading = Cesium.Math.toRadians(delTime * this.angle) + this.heading;
        this.viewer.scene.camera.setView({
            orientation: {
                heading: heading,
                pitch: this.pitch
            }
        });
    },
    stop: function stop() {
        if (!this.isStart) return;

        if (this.viewer) this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
        this.isStart = false;
    }
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MarsClass = exports.MarsClass = function () {
	//========== 构造方法 ========== 
	function MarsClass(options) {
		_classCallCheck(this, MarsClass);

		// this.options = options;

		// 别名,但不建议使用。 
		this.addEventListener = this.on;
		this.removeEventListener = this.clearAllEventListeners = this.off;
		this.addOneTimeEventListener = this.once;
		this.fireEvent = this.fire;
		this.hasEventListeners = this.listens;
	}

	_createClass(MarsClass, [{
		key: 'destroy',
		value: function destroy() {
			//删除所有绑定的数据
			for (var i in this) {
				delete this[i];
			}
		}

		//========== 方法 ==========  

		/* @method on(type: String, fn: Function, context?: Object): this
  * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
  *
  * @alternative
  * @method on(eventMap: Object): this
  * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  */

	}, {
		key: 'on',
		value: function on(types, fn, context) {

			// types can be a map of types/handlers
			if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
				for (var type in types) {
					// we don't process space-separated events here for performance;
					// it's a hot path since Layer uses the on(obj) syntax
					this._on(type, types[type], fn);
				}
			} else {
				// types can be a string of space-separated words
				types = splitWords(types);

				for (var i = 0, len = types.length; i < len; i++) {
					this._on(types[i], fn, context);
				}
			}

			return this;
		}

		/* @method off(type: String, fn?: Function, context?: Object): this
   * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
   *
   * @alternative
   * @method off(eventMap: Object): this
   * Removes a set of type/listener pairs.
   *
   * @alternative
   * @method off: this
   * Removes all listeners to all events on the object.
   */

	}, {
		key: 'off',
		value: function off(types, fn, context) {

			if (!types) {
				// clear all listeners if called without arguments
				delete this._events;
			} else if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
				for (var type in types) {
					this._off(type, types[type], fn);
				}
			} else {
				types = splitWords(types);

				for (var i = 0, len = types.length; i < len; i++) {
					this._off(types[i], fn, context);
				}
			}

			return this;
		}

		// attach listener (without syntactic sugar now)

	}, {
		key: '_on',
		value: function _on(type, fn, context) {
			this._events = this._events || {};

			/* get/init listeners for type */
			var typeListeners = this._events[type];
			if (!typeListeners) {
				typeListeners = [];
				this._events[type] = typeListeners;
			}

			if (context === this) {
				// Less memory footprint.
				context = undefined;
			}
			var newListener = { fn: fn, ctx: context },
			    listeners = typeListeners;

			// check if fn already there
			for (var i = 0, len = listeners.length; i < len; i++) {
				if (listeners[i].fn === fn && listeners[i].ctx === context) {
					return;
				}
			}

			listeners.push(newListener);
		}
	}, {
		key: '_off',
		value: function _off(type, fn, context) {
			var listeners, i, len;

			if (!this._events) {
				return;
			}

			listeners = this._events[type];

			if (!listeners) {
				return;
			}

			if (!fn) {
				// Set all removed listeners to noop so they are not called if remove happens in fire
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].fn = falseFn;
				}
				// clear all listeners for a type if function isn't specified
				delete this._events[type];
				return;
			}

			if (context === this) {
				context = undefined;
			}

			if (listeners) {

				// find fn and remove it
				for (i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					if (l.ctx !== context) {
						continue;
					}
					if (l.fn === fn) {

						// set the removed listener to noop so that's not called if remove happens in fire
						l.fn = falseFn;

						if (this._firingCount) {
							/* copy array in case events are being fired */
							this._events[type] = listeners = listeners.slice();
						}
						listeners.splice(i, 1);

						return;
					}
				}
			}
		}

		// @method fire(type: String, data?: Object, propagate?: Boolean): this
		// Fires an event of the specified type. You can optionally provide an data
		// object — the first argument of the listener function will contain its
		// properties. The event can optionally be propagated to event parents.

	}, {
		key: 'fire',
		value: function fire(type, data, propagate) {
			if (!this.listens(type, propagate)) {
				return this;
			}

			var event = extend({}, data, {
				type: type,
				target: this,
				sourceTarget: data && data.sourceTarget || this
			});

			if (this._events) {
				var listeners = this._events[type];

				if (listeners) {
					this._firingCount = this._firingCount + 1 || 1;
					for (var i = 0, len = listeners.length; i < len; i++) {
						var l = listeners[i];
						l.fn.call(l.ctx || this, event);
					}

					this._firingCount--;
				}
			}

			if (propagate) {
				// propagate the event to parents (set with addEventParent)
				this._propagateEvent(event);
			}

			return this;
		}

		// @method listens(type: String): Boolean
		// Returns `true` if a particular event type has any listeners attached to it.

	}, {
		key: 'listens',
		value: function listens(type, propagate) {
			var listeners = this._events && this._events[type];
			if (listeners && listeners.length) {
				return true;
			}

			if (propagate) {
				// also check parents for listeners if event propagates
				for (var id in this._eventParents) {
					if (this._eventParents[id].listens(type, propagate)) {
						return true;
					}
				}
			}
			return false;
		}

		// @method once(…): this
		// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.

	}, {
		key: 'once',
		value: function once(types, fn, context) {

			if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
				for (var type in types) {
					this.once(type, types[type], fn);
				}
				return this;
			}

			var handler = bind(function () {
				this.off(types, fn, context).off(types, handler, context);
			}, this);

			// add a listener that's executed once and removed after that
			return this.on(types, fn, context).on(types, handler, context);
		}

		// @method addEventParent(obj: Evented): this
		// Adds an event parent - an `Evented` that will receive propagated events

	}, {
		key: 'addEventParent',
		value: function addEventParent(obj) {
			this._eventParents = this._eventParents || {};
			this._eventParents[stamp(obj)] = obj;
			return this;
		}

		// @method removeEventParent(obj: Evented): this
		// Removes an event parent, so it will stop receiving propagated events

	}, {
		key: 'removeEventParent',
		value: function removeEventParent(obj) {
			if (this._eventParents) {
				delete this._eventParents[stamp(obj)];
			}
			return this;
		}
	}, {
		key: '_propagateEvent',
		value: function _propagateEvent(e) {
			for (var id in this._eventParents) {
				this._eventParents[id].fire(e.type, extend({
					layer: e.target,
					propagatedFrom: e.target
				}, e), true);
			}
		}
	}]);

	return MarsClass;
}();

//事件类型枚举[统一的定义，避免命名混乱]


var eventType = exports.eventType = {
	add: 'add',
	remove: 'remove', //移除对象
	delete: 'delete', //删除对象
	update: 'update',

	start: 'start',
	change: 'change',
	endItem: 'endItem', //多个数据异步分析时，完成其中一个时的回调事件
	end: 'end',
	stop: 'stop',

	loadBefore: 'loadBefore', //加载完成 未做任何其他处理前
	load: 'load', //加载完成，执行所有内部处理后
	error: 'error',

	click: 'click',
	clickMap: 'clickMap', //单击地图空白（未单击到矢量或模型数据）时
	mouseMove: 'mouseMove',
	mouseOver: 'mouseOver', //鼠标移入
	mouseOut: 'mouseOut', //鼠标移出


	//标绘事件
	drawStart: 'draw-start', //开始绘制
	drawMouseMove: 'draw-mouse-move', //正在移动鼠标中，绘制过程中鼠标移动了点
	drawAddPoint: 'draw-add-point', //绘制过程中增加了点
	drawRemovePoint: 'draw-remove-lastpoint', //绘制过程中删除了last点
	drawCreated: 'draw-created', //创建完成
	editStart: 'edit-start', //开始编辑
	editMouseDown: 'edit-mouse-movestart', //移动鼠标按下左键					  LEFT_DOWN
	editMouseMove: 'edit-mouse-move', //正在移动鼠标中，正在编辑拖拽修改点中	MOUSE_MOVE
	editMovePoint: 'edit-move-point', //编辑修改了点 						  LEFT_UP
	editRemovePoint: 'edit-remove-point', //编辑删除了点
	editStop: 'edit-stop', //停止编辑

	//3dtiles模型
	initialTilesLoaded: 'initialTilesLoaded',
	allTilesLoaded: 'allTilesLoaded',

	//瓦片底图
	loadTileStart: 'loadTileStart',
	loadTileEnd: 'loadTileEnd',
	loadTileError: 'loadTileError'

};

function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

function trim(str) {
	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
	if (!str) {
		console.error("传入了空event事件名称，请检查代码");
		return str;
	}
	return trim(str).split(/\s+/);
}

function falseFn() {
	return false;
}

function bind(fn, obj) {
	var slice = Array.prototype.slice;

	if (fn.bind) {
		return fn.bind.apply(fn, slice.call(arguments, 1));
	}

	var args = slice.call(arguments, 2);

	return function () {
		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
	};
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assigning it one if it doesn't have it.
function stamp(obj) {
	obj._okay3d_id = obj._okay3d_id || ++lastId;
	return obj._okay3d_id;
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cartesian2lonlat = cartesian2lonlat;
exports.cartesians2lonlats = cartesians2lonlats;
exports.cartesian2mercator = cartesian2mercator;
exports.cartesians2mercators = cartesians2mercators;
exports.lonlat2cartesian = lonlat2cartesian;
exports.lonlats2cartesians = lonlats2cartesians;
exports.lonlat2mercator = lonlat2mercator;
exports.lonlats2mercators = lonlats2mercators;
exports.mercator2cartesian = mercator2cartesian;
exports.mercators2cartesians = mercators2cartesians;
exports.mercator2lonlat = mercator2lonlat;
exports.mercators2lonlats = mercators2lonlats;
exports.bd2gcj = bd2gcj;
exports.gcj2bd = gcj2bd;
exports.wgs2gcj = wgs2gcj;
exports.gcj2wgs = gcj2wgs;
exports.bd2wgs = bd2wgs;
exports.wgs2bd = wgs2bd;
exports.jwd2mct = jwd2mct;
exports.mct2jwd = mct2jwd;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
};

//格式化 数字 小数位数
function formatNum(num, digits) {
    return Number(num.toFixed(digits || 0));
}

//===============提供了cesium内部不同对象之间的坐标转换==============

//cesium笛卡尔空间坐标 转 经纬度坐标【用于转geojson】
function cartesian2lonlat(cartesian) {
    var carto = Cesium.Cartographic.fromCartesian(cartesian);
    if (carto == null) return null;

    var x = formatNum(Cesium.Math.toDegrees(carto.longitude), 6);
    var y = formatNum(Cesium.Math.toDegrees(carto.latitude), 6);
    var z = formatNum(carto.height, 2);

    return [x, y, z];
}

//数组，cesium笛卡尔空间坐标 转 经纬度坐标【用于转geojson】
function cartesians2lonlats(positions) {
    var coordinates = [];
    for (var i = 0, len = positions.length; i < len; i++) {
        var point = cartesian2lonlat(positions[i]);
        if (point) coordinates.push(point);
    }
    return coordinates;
}

//cesium笛卡尔空间坐标 转 web mercator投影坐标
function cartesian2mercator(position) {
    if (!position) return null;

    var lonlat = cartesian2lonlat(position);
    return lonlat2mercator(lonlat);
}

//数组，cesium笛卡尔空间坐标 转 web mercator投影坐标
function cartesians2mercators(arr) {
    var arrNew = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        var point = cartesian2mercator(arr[i]);
        if (point) arrNew.push(point);
    }
    return arrNew;
}

//经纬度坐标 转 cesium笛卡尔空间坐标
function lonlat2cartesian(coord, defHeight) {
    if (!coord || coord.length < 2) return null;
    return Cesium.Cartesian3.fromDegrees(coord[0], coord[1], coord[2] || defHeight || 0);
}

//数组，经纬度坐标 转 cesium笛卡尔空间坐标
function lonlats2cartesians(coords, defHeight) {
    var arr = [];
    for (var i = 0, len = coords.length; i < len; i++) {
        var item = coords[i];
        if (isArray(item[0])) {
            var arr2 = lonlats2cartesians(item, defHeight);
            if (arr2 && arr2.length > 0) arr.push(arr2);
        } else {
            var cartesian = lonlat2cartesian(item, defHeight);
            if (cartesian) arr.push(cartesian);
        }
    }
    return arr;
}

//地理坐标 转 投影坐标
function lonlat2mercator(lnglat) {
    return jwd2mct(lnglat);
}
//数组，地理坐标 转 投影坐标
function lonlats2mercators(arr) {
    var arrNew = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        var point = lonlat2mercator(arr[i]);
        arrNew.push(point);
    }
    return arrNew;
}

//投影坐标 转 cesium笛卡尔空间坐标
function mercator2cartesian(point) {
    if (isNaN(point[0]) || isNaN(point[1])) return null;

    var lonlat = mercator2lonlat(point);
    return lonlat2cartesian(lonlat);
}
//数组，投影坐标 转 cesium笛卡尔空间坐标
function mercators2cartesians(arr) {
    var arrNew = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        var point = mercator2cartesian(arr[i]);
        if (point) arrNew.push(point);
    }
    return arrNew;
}

//投影坐标 转 地理坐标
function mercator2lonlat(point) {
    return mct2jwd(point);
}
//数组，投影坐标 转 地理坐标
function mercators2lonlats(arr) {
    var arrNew = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        var point = mercator2lonlat(arr[i]);
        arrNew.push(point);
    }
    return arrNew;
}

//========提供了百度（BD09）、国测局（GCJ02）、WGS84、Web墨卡托 4类坐标之间的转换=======
//传入参数 和 返回结果 均是数组：[经度,纬度] 

//定义一些常量
var x_PI = 3.14159265358979324 * 3000.0 / 180.0;
var PI = 3.1415926535897932384626;
var a = 6378245.0;
var ee = 0.00669342162296594323;

function transformlat(lng, lat) {
    var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
    ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
    ret += (20.0 * Math.sin(lat * PI) + 40.0 * Math.sin(lat / 3.0 * PI)) * 2.0 / 3.0;
    ret += (160.0 * Math.sin(lat / 12.0 * PI) + 320 * Math.sin(lat * PI / 30.0)) * 2.0 / 3.0;
    return ret;
}

function transformlng(lng, lat) {
    var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
    ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
    ret += (20.0 * Math.sin(lng * PI) + 40.0 * Math.sin(lng / 3.0 * PI)) * 2.0 / 3.0;
    ret += (150.0 * Math.sin(lng / 12.0 * PI) + 300.0 * Math.sin(lng / 30.0 * PI)) * 2.0 / 3.0;
    return ret;
}

/**
 * 判断是否在国内，不在国内则不做偏移
 * @param lng
 * @param lat
 * @returns {boolean}
 */
function out_of_china(lng, lat) {
    return lng < 72.004 || lng > 137.8347 || lat < 0.8293 || lat > 55.8271 || false;
}

/**
 * 百度坐标系 (BD-09) 与 国测局坐标系 (GCJ-02)的转换
 * 即 百度 转 谷歌、高德
 * @param bd_lon
 * @param bd_lat
 * @returns {*[]}
 */
function bd2gcj(arrdata) {
    var bd_lon = Number(arrdata[0]);
    var bd_lat = Number(arrdata[1]);

    var x_pi = 3.14159265358979324 * 3000.0 / 180.0;
    var x = bd_lon - 0.0065;
    var y = bd_lat - 0.006;
    var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_pi);
    var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_pi);
    var gg_lng = z * Math.cos(theta);
    var gg_lat = z * Math.sin(theta);

    gg_lng = Number(gg_lng.toFixed(6));
    gg_lat = Number(gg_lat.toFixed(6));
    return [gg_lng, gg_lat];
};

/**
 * 国测局坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换
 * 即谷歌、高德 转 百度
 * @param lng
 * @param lat
 * @returns {*[]}
 */
function gcj2bd(arrdata) {
    var lng = Number(arrdata[0]);
    var lat = Number(arrdata[1]);

    var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_PI);
    var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_PI);
    var bd_lng = z * Math.cos(theta) + 0.0065;
    var bd_lat = z * Math.sin(theta) + 0.006;

    bd_lng = Number(bd_lng.toFixed(6));
    bd_lat = Number(bd_lat.toFixed(6));
    return [bd_lng, bd_lat];
};

/**
 * WGS84转GCj02
 * @param lng
 * @param lat
 * @returns {*[]}
 */
function wgs2gcj(arrdata) {
    var lng = Number(arrdata[0]);
    var lat = Number(arrdata[1]);

    if (out_of_china(lng, lat)) {
        return [lng, lat];
    } else {
        var dlat = transformlat(lng - 105.0, lat - 35.0);
        var dlng = transformlng(lng - 105.0, lat - 35.0);
        var radlat = lat / 180.0 * PI;
        var magic = Math.sin(radlat);
        magic = 1 - ee * magic * magic;
        var sqrtmagic = Math.sqrt(magic);
        dlat = dlat * 180.0 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
        dlng = dlng * 180.0 / (a / sqrtmagic * Math.cos(radlat) * PI);
        var mglat = lat + dlat;
        var mglng = lng + dlng;

        mglng = Number(mglng.toFixed(6));
        mglat = Number(mglat.toFixed(6));
        return [mglng, mglat];
    }
};

/**
 * GCJ02 转换为 WGS84
 * @param lng
 * @param lat
 * @returns {*[]}
 */
function gcj2wgs(arrdata) {
    var lng = Number(arrdata[0]);
    var lat = Number(arrdata[1]);

    if (out_of_china(lng, lat)) {
        return [lng, lat];
    } else {
        var dlat = transformlat(lng - 105.0, lat - 35.0);
        var dlng = transformlng(lng - 105.0, lat - 35.0);
        var radlat = lat / 180.0 * PI;
        var magic = Math.sin(radlat);
        magic = 1 - ee * magic * magic;
        var sqrtmagic = Math.sqrt(magic);
        dlat = dlat * 180.0 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
        dlng = dlng * 180.0 / (a / sqrtmagic * Math.cos(radlat) * PI);

        var mglat = lat + dlat;
        var mglng = lng + dlng;

        var jd = lng * 2 - mglng;
        var wd = lat * 2 - mglat;

        jd = Number(jd.toFixed(6));
        wd = Number(wd.toFixed(6));
        return [jd, wd];
    }
};

//百度经纬度坐标 转 标准WGS84坐标   
function bd2wgs(arrdata) {
    return gcj2wgs(bd2gcj(arrdata));
};

//标准WGS84坐标  转 百度经纬度坐标   
function wgs2bd(arrdata) {
    return gcj2bd(wgs2gcj(arrdata));
};

//经纬度转Web墨卡托  
function jwd2mct(arrdata) {
    var lng = Number(arrdata[0]);
    var lat = Number(arrdata[1]);

    var x = lng * 20037508.34 / 180;
    var y = Math.log(Math.tan((90 + lat) * PI / 360)) / (PI / 180);
    y = y * 20037508.34 / 180; //+ 7.081154553416204e-10;

    x = Number(x.toFixed(2));
    y = Number(y.toFixed(2));
    return [x, y, arrdata[2] || 0];
};

//Web墨卡托转经纬度  
function mct2jwd(arrdata) {
    var lng = Number(arrdata[0]);
    var lat = Number(arrdata[1]);

    var x = lng / 20037508.34 * 180;
    var y = lat / 20037508.34 * 180;
    y = 180 / PI * (2 * Math.atan(Math.exp(y * PI / 180)) - PI / 2);

    x = Number(x.toFixed(6));
    y = Number(y.toFixed(6));
    return [x, y, arrdata[2] || 0];
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.log = log;
exports.warn = warn;
exports.update = update;
var hasLog = exports.hasLog = true;

//输出普通信息(含调试)
function log(log) {
    if (!hasLog) return;

    console.log(log);
}

var hasWarn = exports.hasWarn = true;

//输出警示信息(含错误)
function warn(log) {
    if (!hasWarn) return;

    console.warn(log);
}

function update(val) {
    var val2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    exports.hasLog = hasLog = val;
    exports.hasWarn = hasWarn = val2;
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Draw = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

exports.register = register;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(8);

var _MarsClass2 = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _point = __webpack_require__(2);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _Tooltip = __webpack_require__(7);

var _index = __webpack_require__(20);

var attr = _interopRequireWildcard(_index);

var _Draw = __webpack_require__(44);

var _Draw2 = __webpack_require__(24);

var _Draw3 = __webpack_require__(45);

var _Draw4 = __webpack_require__(115);

var _Draw5 = __webpack_require__(116);

var _Draw6 = __webpack_require__(16);

var _Draw7 = __webpack_require__(117);

var _Draw8 = __webpack_require__(118);

var _Draw9 = __webpack_require__(119);

var _Draw10 = __webpack_require__(63);

var _Draw11 = __webpack_require__(10);

var _Draw12 = __webpack_require__(120);

var _Draw13 = __webpack_require__(121);

var _Draw14 = __webpack_require__(122);

var _Draw15 = __webpack_require__(124);

var _Draw16 = __webpack_require__(125);

var _Draw17 = __webpack_require__(126);

var _Draw18 = __webpack_require__(127);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//类库外部扩展的类
var exDraw = {};
function register(type, layerClass) {
    exDraw[type] = layerClass;
}

//绘制entity类型

var Draw = exports.Draw = function (_MarsClass) {
    _inherits(Draw, _MarsClass);

    //========== 构造方法 ========== 
    function Draw(options, oldparam) {
        _classCallCheck(this, Draw);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (Draw.__proto__ || Object.getPrototypeOf(Draw)).call(this));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码


        _this.options = options;
        _this.viewer = options.viewer;
        _this.popup = options.popup;

        _this.options.groupName = Cesium.defaultValue(_this.options.groupName, '默认分组');

        _this.arrGroup = []; //分组
        _this.dataSource = Cesium.defaultValue(_this.options.dataSource, _this.addGroup(_this.options.groupName));

        if (Cesium.defaultValue(_this.options.removeScreenSpaceEvent, true)) {
            _this.viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
            _this.viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }

        _this.tooltip = new _Tooltip.Tooltip(_this.viewer.container); //鼠标提示信息

        _this.hasEdit(Cesium.defaultValue(_this.options.hasEdit, true)); //是否可编辑


        //编辑工具初始化
        var _opts = {
            viewer: _this.viewer,
            dataSource: _this.dataSource,
            tooltip: _this.tooltip
        };

        //entity
        _this.drawCtrl = {};
        _this.drawCtrl['point'] = new _Draw2.DrawPoint(_opts);
        _this.drawCtrl['billboard'] = new _Draw3.DrawBillboard(_opts);
        _this.drawCtrl['label'] = new _Draw4.DrawLabel(_opts);
        _this.drawCtrl['model'] = new _Draw5.DrawModel(_opts);

        _this.drawCtrl['polyline'] = new _Draw6.DrawPolyline(_opts);
        _this.drawCtrl['curve'] = new _Draw7.DrawCurve(_opts);
        _this.drawCtrl['polylineVolume'] = new _Draw8.DrawPolylineVolume(_opts);
        _this.drawCtrl['corridor'] = new _Draw9.DrawCorridor(_opts);

        _this.drawCtrl['polygon'] = new _Draw10.DrawPolygon(_opts);
        _this.drawCtrl['rectangle'] = new _Draw12.DrawRectangle(_opts);
        _this.drawCtrl['ellipse'] = new _Draw13.DrawCircle(_opts);
        _this.drawCtrl['circle'] = _this.drawCtrl['ellipse']; //圆
        _this.drawCtrl['cylinder'] = new _Draw14.DrawCylinder(_opts);
        _this.drawCtrl['ellipsoid'] = new _Draw15.DrawEllipsoid(_opts);
        _this.drawCtrl['wall'] = new _Draw16.DrawWall(_opts);
        _this.drawCtrl['box'] = new _Draw18.DrawBox(_opts);
        _this.drawCtrl['plane'] = new _Draw17.DrawPlane(_opts);

        //外部图层
        for (var key in exDraw) {
            _this.drawCtrl[key] = new exDraw[key](_opts);
        }

        //绑定事件抛出方法
        var that = _this;
        for (var type in _this.drawCtrl) {
            _this.drawCtrl[type]._fire = function (type, data, propagate) {
                that.fire(type, data, propagate);
            };
        }

        _this.isContinued = Cesium.defaultValue(_this.options.isContinued, false);
        _this.isAutoEditing = Cesium.defaultValue(_this.options.isAutoEditing, true);
        _this.on(_MarsClass2.eventType.drawCreated, function (e) {
            _this.bindExtension(e.entity);

            setTimeout(function () {
                if (_this.isContinued) {
                    //连续标绘时
                    _this.stopDraw();
                    _this.startDraw(_this._last_attribute, _this._last_drawOkCallback);
                } else if (_this.isAutoEditing) {
                    //创建完成后激活编辑 
                    _this.startEditing(e.entity);
                }
            }, 50);
        }, _this);
        return _this;
    }
    //========== 对外属性 ==========  


    _createClass(Draw, [{
        key: 'addGroup',


        //==========分组相关==========
        //新增添加分组
        value: function addGroup(name, item) {
            var dataSource = new Cesium.CustomDataSource(name);
            dataSource.attribute = item; //携带数据，非必须
            this.viewer.dataSources.add(dataSource);

            this.arrGroup.push(dataSource);
            return dataSource;
        }
        //校验分组是否有同名的

    }, {
        key: 'checkGroupName',
        value: function checkGroupName(name, thisLayer) {
            for (var i = 0; i < this.arrGroup.length; i++) {
                var layer = this.arrGroup[i];
                if (thisLayer && layer == thisLayer) continue;

                if (layer.name == name) return true;
            }
            return false;
        }
        //根据name获取分组

    }, {
        key: 'getGroup',
        value: function getGroup(name) {
            for (var i = 0; i < this.arrGroup.length; i++) {
                var layer = this.arrGroup[i];
                if (layer.name == name) return layer;
            }
            return null;
        }
        //新增或获取已有分组

    }, {
        key: 'addOrGetGroup',
        value: function addOrGetGroup(name) {
            if (!name) return this.dataSource;
            var group = this.getGroup(name);
            if (group) {
                return group;
            } else {
                return this.addGroup(name);
            }
        }
        //删除分组后的对默认图层和激活图层的特殊处理

    }, {
        key: '_processForRemoveGroup',
        value: function _processForRemoveGroup() {
            if (this.arrGroup.length == 0) {
                this.dataSource = this.addGroup(this.options.groupName);
            } else if (this.dataSource == null) {
                //如果删除的是当前激活的图层，默认再次激活第1个图层
                this.dataSource = this.arrGroup[0];
            }
        }
        //根据name删除分组

    }, {
        key: 'removeGroup',
        value: function removeGroup(name) {
            var layer;
            if (name instanceof Cesium.CustomDataSource) layer = name;else layer = this.getGroup(name);

            if (layer) {
                if (this.dataSource == layer) {
                    this.dataSource = null;
                }
                this.removeByGroup(layer);
                this.viewer.dataSources.remove(layer, true);
                util.removeArrayItem(this.arrGroup, layer);

                this._processForRemoveGroup();
                return true;
            }
            return false;
        }
        //删除所有非空数组

    }, {
        key: 'removeNullGroup',
        value: function removeNullGroup() {
            for (var i = this.arrGroup.length - 1; i >= 0; i--) {
                var layer = this.arrGroup[i];
                if (layer.entities.values.length == 0) {
                    this.viewer.dataSources.remove(layer, true);
                    this.arrGroup.splice(i, 1);

                    if (this.dataSource == layer) {
                        this.dataSource = null;
                    }
                }
            }
            this._processForRemoveGroup();
        }
        //激活图层，新增的标绘是加到当前激活的图层中。

    }, {
        key: 'activateGroup',
        value: function activateGroup(name) {
            var layer;
            if (name instanceof Cesium.CustomDataSource) layer = name;else layer = this.getGroup(name);

            if (!layer) return false;

            this.dataSource = layer;
            return true;
        }

        //移动标号到新分组

    }, {
        key: 'moveEntityGroup',
        value: function moveEntityGroup(entity, group) {
            var dataSource;
            if (group instanceof Cesium.CustomDataSource) dataSource = group;else dataSource = this.getGroup(group);

            entity.entityCollection.remove(entity); //从原有的集合中删除 
            dataSource.entities.add(entity); //加入到draw集合图层中

            entity.attribute.group = dataSource.name; //记录分组信息
        }
    }, {
        key: 'getDataSource',
        value: function getDataSource() {
            return this.dataSource;
        }

        //==========绘制相关==========

    }, {
        key: 'startDraw',
        value: function startDraw(attribute, drawOkCallback) {
            //参数是字符串id或uri时
            if (typeof attribute === 'string') {
                attribute = { type: attribute };
            } else {
                if (attribute == null || attribute.type == null) {
                    marslog.warn('需要传入指定绘制的type类型！');
                    return;
                }
            }

            var type = attribute.type;
            if (this.drawCtrl[type] == null) {
                marslog.warn('不能进行type为【' + type + '】的绘制，无该类型！');
                return;
            }

            if (!drawOkCallback && attribute.success) {
                drawOkCallback = attribute.success;
                delete attribute.success;
            }
            this._last_drawOkCallback = drawOkCallback;
            this._last_attribute = attribute;

            //赋默认值  
            attribute = attr.addGeoJsonDefVal(attribute);

            this.stopDraw();
            var entity = this.drawCtrl[type].activate(attribute, drawOkCallback);
            return entity;
        }
        //对已经绘制完成的entity，重新激活开始编辑[目前仅支持polyline、polygon]

    }, {
        key: 'restartDraw',
        value: function restartDraw(entity, drawOkCallback) {
            var attribute = entity.attribute;
            var type = attribute.type;
            if (this.drawCtrl[type] == null) {
                marslog.warn('不能进行type为【' + type + '】的绘制，无该类型！');
                return;
            }

            if (!drawOkCallback && attribute.success) {
                drawOkCallback = attribute.success;
                delete attribute.success;
            }
            this._last_drawOkCallback = drawOkCallback;
            this._last_attribute = attribute;

            this.stopDraw();
            var entity = this.drawCtrl[type].activate(entity, drawOkCallback);
            return entity;
        }
        //是否还在绘制中

    }, {
        key: 'hasDrawing',
        value: function hasDrawing() {
            for (var type in this.drawCtrl) {
                if (this.drawCtrl[type]._enabled) return true;
            }
            return false;
        }
        //外部控制，完成绘制，比如手机端无法双击结束

    }, {
        key: 'endDraw',
        value: function endDraw() {
            for (var type in this.drawCtrl) {
                if (this.drawCtrl[type].endDraw) this.drawCtrl[type].endDraw();
            }
            return this;
        }
    }, {
        key: 'stopDraw',
        value: function stopDraw() {
            this.stopEditing();
            for (var type in this.drawCtrl) {
                this.drawCtrl[type].disable(true);
            }
            return this;
        }
    }, {
        key: 'closeTooltip',
        value: function closeTooltip() {
            if (!this.tooltip) return;

            this.tooltip.setVisible(false);
            if (this.tiptimeTik) {
                clearTimeout(this.tiptimeTik);
                delete this.tiptimeTik;
            }
        }
        //==========编辑相关==========
        // currEditFeature: null,      //当前编辑的要素  

    }, {
        key: 'getCurrentEntity',
        value: function getCurrentEntity() {
            return this.currEditFeature;
        }
        // _hasEdit: null,

    }, {
        key: 'hasEdit',
        value: function hasEdit(val) {
            if (this._hasEdit !== null && this._hasEdit === val) return;

            this._hasEdit = val;
            if (val) {
                this.bindSelectEvent();
            } else {
                this.stopEditing();
                this.destroySelectEvent();
            }
        }
        //绑定鼠标选中事件

    }, {
        key: 'bindSelectEvent',
        value: function bindSelectEvent() {
            var _this2 = this;

            //选取对象
            var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
            handler.setInputAction(function (event) {
                var pickedObject = _this2.viewer.scene.pick(event.position, 5, 5);
                if (Cesium.defined(pickedObject)) {
                    var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;

                    if (_this2.hasDrawing()) return; //还在绘制中时，跳出
                    if (_this2.currEditFeature && _this2.currEditFeature === entity) return; //重复单击了跳出
                    if (!Cesium.defaultValue(entity.hasEdit, true)) return; //如果设置了不可编辑跳出

                    if (entity && _this2.isMyEntity(entity)) {
                        if (!Cesium.defaultValue(entity.inProgress, false)) {
                            _this2.startEditing(entity);
                            _this2.closeTooltip();
                            if (entity.draw_tooltip) {
                                _this2.tooltip.showAt(event.position, entity.draw_tooltip);
                            }
                            return;
                        }
                    }
                }
                _this2.stopEditing();
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

            //编辑提示事件
            handler.setInputAction(function (event) {
                if (!_this2._hasEdit) return;

                //还在绘制中时，跳出
                if (_this2.hasDrawing()) return;

                //正在拖拽其他的entity时，跳出
                if (!_this2.viewer.scene.screenSpaceCameraController.enableInputs) return;

                _this2.closeTooltip();

                var pickedObject = _this2.viewer.scene.pick(event.endPosition, 5, 5);
                if (Cesium.defined(pickedObject)) {
                    var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;
                    if (entity && entity.editing && !Cesium.defaultValue(entity.inProgress, false) && _this2.isMyEntity(entity)) {
                        var tooltip = _this2.tooltip;

                        //删除右键菜单打开了不显示tooltip
                        if (_this2.viewer.mars.contextmenu && _this2.viewer.mars.contextmenu.show && _this2.viewer.mars.contextmenu.target == entity) return;

                        _this2.tiptimeTik = setTimeout(function () {
                            //edit中的MOUSE_MOVE会关闭提示，延迟执行。
                            tooltip.showAt(event.endPosition, _Tooltip.message.edit.start);
                        }, 100);
                    }
                }
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

            this.selectHandler = handler;
        }
    }, {
        key: 'destroySelectEvent',
        value: function destroySelectEvent() {
            this.selectHandler && this.selectHandler.destroy();
            this.selectHandler = undefined;
        }
    }, {
        key: 'startEditing',
        value: function startEditing(entity) {
            this.stopEditing();
            if (entity == null || !this._hasEdit) return;

            if (entity.editing && entity.editing.activate) {
                entity.editing.activate();
            }
            this.currEditFeature = entity;
        }
    }, {
        key: 'stopEditing',
        value: function stopEditing() {
            this.closeTooltip();
            if (this.currEditFeature && this.currEditFeature.editing && this.currEditFeature.editing.disable) {
                this.currEditFeature.editing.disable();
            }
            this.currEditFeature = null;
        }
        //修改了属性

    }, {
        key: 'updateAttribute',
        value: function updateAttribute(attribute, entity) {
            if (entity == null) entity = this.currEditFeature;
            if (entity == null || attribute == null) return;

            attribute.style = attribute.style || {};
            attribute.attr = attribute.attr || {};

            //更新属性
            var type = entity.attribute.type;
            this.drawCtrl[type].style2Entity(attribute.style, entity);
            entity.attribute = attribute;

            //如果在编辑状态，更新绑定的拖拽点
            if (entity.editing) {
                if (entity.editing.updateAttrForEditing) entity.editing.updateAttrForEditing();

                if (entity.editing.updateDraggers) entity.editing.updateDraggers();
            }

            return entity;
        }
    }, {
        key: 'updateStyle',
        value: function updateStyle(style, entity) {
            if (entity == null) entity = this.currEditFeature;
            if (entity == null) return;

            var type = entity.attribute.type;

            var oldstyle = entity.attribute.style || {};
            for (var key in style) {
                oldstyle[key] = style[key];
            }
            this.drawCtrl[type].style2Entity(oldstyle, entity);
        }

        //修改坐标、高程

    }, {
        key: 'setPositions',
        value: function setPositions(positions, entity) {
            if (entity == null) entity = this.currEditFeature;
            if (entity == null || positions == null) return;

            //如果在编辑状态，更新绑定的拖拽点
            if (entity.editing) {
                entity.editing.setPositions(positions);
                entity.editing.updateDraggers();
            }
            return entity;
        }

        //绑定扩展的右键、popup等处理

    }, {
        key: 'bindExtension',
        value: function bindExtension(entity) {
            var _this3 = this;

            var that = this;

            entity.hasDrawEdit = function () {
                return _this3.edit;
            };

            //右键菜单
            entity.contextmenuItems = entity.contextmenuItems || [];
            entity.contextmenuItems.push({
                text: '删除对象',
                iconCls: 'fa fa-trash-o',
                visible: function visible(e) {
                    that.closeTooltip();

                    var entity = e.target;
                    if (entity.inProgress && !entity.editing) return false;

                    if (Cesium.defined(that.options.hasDel)) return that._hasEdit && that.options.hasDel(e);else return that._hasEdit;
                },
                callback: function callback(e) {
                    var entity = e.target;

                    if (entity.editing && entity.editing.disable) {
                        entity.editing.disable();
                    }
                    that.deleteEntity(entity);
                }
            });

            //名称 绑定到tooltip
            if (this.options.nameTooltip) {
                entity.tooltip = {
                    visible: function visible() {
                        return !that._hasEdit;
                    },
                    html: function html(entity) {
                        if (entity.attribute.attr && entity.attribute.attr.name) return entity.attribute.attr.name;else return null;
                    }
                };
            }

            if (this.popup) {
                var that = this;

                entity.popup = {
                    visible: function visible(entity) {
                        return that.popup.enable;
                    },
                    html: function html(entity) {
                        var html = util.getPopup([].concat(_toConsumableArray(that.popup.columns), [that.popup.edit ? { "field": "id", "name": "确定", "type": "button" } : null]), entity.attribute.attr, {
                            title: that.popup.title || "属性信息",
                            edit: that.popup.edit,
                            width: 200
                        });
                        return html;
                    },
                    onAdd: function onAdd(eleId, entity) {
                        //popup的DOM添加到页面的回调方法 
                        (0, _zepto.zepto)("#" + eleId + " .okay3d-popup-btn").click(function (e) {
                            (0, _zepto.zepto)("#" + eleId + " .okay3d-popup-edititem").each(function () {
                                var val = (0, _zepto.zepto)(this).val();
                                var key = (0, _zepto.zepto)(this).attr("data-type");
                                entity.attribute.attr[key] = val;
                            });
                            that.viewer.mars.popup.close();
                            if (that.popup.callback) that.popup.callback();
                        });
                    },
                    onRemove: function onRemove(eleId, entity) {//popup的DOM从页面移除的回调方法 

                    },
                    anchor: this.popup.enable.anchor || [0, -20]
                };
            }
        }
        //==========删除相关==========  
        //删除单个

    }, {
        key: 'deleteEntity',
        value: function deleteEntity(entity) {
            if (entity == null) entity = this.currEditFeature;
            if (entity == null) return;

            if (entity.editing) {
                entity.editing.destroy();
                delete entity.editing;
            }
            if (entity.featureEx) {
                entity.featureEx.destroy();
                delete entity.featureEx;
            }

            if (entity.entityCollection.contains(entity)) entity.entityCollection.remove(entity);

            this.fire(_MarsClass2.eventType.delete, { entity: entity });
        }
    }, {
        key: 'remove',
        value: function remove(entity) {
            //兼容不同习惯命名
            return this.deleteEntity(entity);
        }
        //是否为当前编辑器编辑的标号

    }, {
        key: 'isMyEntity',
        value: function isMyEntity(entity) {
            for (var i = 0; i < this.arrGroup.length; i++) {
                var layer = this.arrGroup[i];
                if (layer.entities.contains(entity)) return true;
            }
            return false;
        }
    }, {
        key: 'removeByGroup',
        value: function removeByGroup(layer) {
            var arrEntity = layer.entities.values;
            for (var i = 0, len = arrEntity.length; i < len; i++) {
                var entity = arrEntity[i];
                if (entity.editing) {
                    entity.editing.destroy();
                    delete entity.editing;
                }
                if (entity.featureEx) {
                    entity.featureEx.destroy();
                    delete entity.featureEx;
                }
            }
            layer.entities.removeAll();
        }
        //删除所有

    }, {
        key: 'deleteAll',
        value: function deleteAll() {
            //兼容不同习惯命名
            this.removeAll();
        }
    }, {
        key: 'clearDraw',
        value: function clearDraw() {
            //兼容不同习惯命名
            this.removeAll();
        }
    }, {
        key: 'removeAll',
        value: function removeAll() {
            this.stopDraw();

            for (var i = 0; i < this.arrGroup.length; i++) {
                this.removeByGroup(this.arrGroup[i]);
            }

            return this;
        }
        //==========转换GeoJSON==========
        //转换当前所有为geojson

    }, {
        key: 'toGeoJSON',
        value: function toGeoJSON(entity) {
            this.stopDraw();

            if (entity == null) {
                //全部数据   
                var features = [];
                var groupName = [];
                for (var k = 0; k < this.arrGroup.length; k++) {
                    var layer = this.arrGroup[k];
                    groupName.push(layer.name);
                    features = features.concat(this.getJsonByGroup(layer));
                }

                return {
                    type: "FeatureCollection",
                    group: groupName,
                    features: features
                };
            } else if (entity instanceof Cesium.CustomDataSource) {
                return {
                    type: "FeatureCollection",
                    features: this.getJsonByGroup(entity)
                };
            } else {
                var type = entity.attribute.type;
                var geojson = this.drawCtrl[type].toGeoJSON(entity);
                geojson = attr.removeGeoJsonDefVal(geojson);
                return geojson;
            }
        }
    }, {
        key: 'getJsonByGroup',
        value: function getJsonByGroup(layer) {
            var features = [];
            var arrEntity = layer.entities.values;
            for (var i = 0, len = arrEntity.length; i < len; i++) {
                var entity = arrEntity[i];
                if (entity.attribute == null || entity.attribute.type == null) continue;

                var type = entity.attribute.type;
                var geojson = this.drawCtrl[type].toGeoJSON(entity);
                if (geojson == null) continue;
                geojson = attr.removeGeoJsonDefVal(geojson);
                geojson.properties.group = layer.name; //记录分组信息

                features.push(geojson);
            }
            return features;
        }

        //加载goejson数据

    }, {
        key: 'jsonToEntity',
        value: function jsonToEntity(json, isClear, isFly) {
            //兼容旧版本方法名
            return this.loadJson(json, {
                clear: isClear,
                flyTo: isFly
            });
        }
    }, {
        key: 'loadJson',
        value: function loadJson(json, opts) {
            opts = opts || {};

            var jsonObjs = json;
            try {
                if (util.isString(json)) jsonObjs = JSON.parse(json);
            } catch (e) {
                util.alert(e.name + ": " + e.message + " \n请确认json文件格式正确!!!");
                return;
            }

            if (opts.clear) {
                this.clearDraw();
            }

            var arrthis = [];
            var jsonFeatures = jsonObjs.features ? jsonObjs.features : [jsonObjs];

            //存在分组信息
            var groupName = jsonObjs.group;
            if (groupName) {
                for (var k = 0; k < groupName.length; k++) {
                    this.addOrGetGroup(groupName[k]);
                }
            }

            for (var i = 0, len = jsonFeatures.length; i < len; i++) {
                var feature = jsonFeatures[i];

                if (!feature.properties || !feature.properties.type) {
                    //非本身保存的外部其他geojson数据
                    feature.properties = feature.properties || {};
                    switch (feature.geometry.type) {
                        case "MultiPolygon":
                        case "Polygon":
                            feature.properties.type = "polygon";
                            break;
                        case "MultiLineString":
                        case "LineString":
                            feature.properties.type = "polyline";
                            break;
                        case "MultiPoint":
                        case "Point":
                            feature.properties.type = "point";
                            break;
                    }
                }
                feature.properties.style = opts.style || feature.properties.style || {};
                feature.properties.attr = feature.properties.attr || {};

                if (opts.onEachFeature) //添加到地图前 回调方法
                    opts.onEachFeature(feature, feature.properties.type, i);

                var type = feature.properties.type;
                if (this.drawCtrl[type] == null) {
                    marslog.warn('数据无法识别或者数据的[' + type + ']类型参数有误');
                    continue;
                }

                var entity = this.getEntityById(feature.properties.attr.id);
                if (entity) {
                    this.updateStyle(feature.properties.style, entity);

                    var positions = (0, _point.getPositionByGeoJSON)(feature);
                    if (positions) this.setPositions(positions, entity);
                } else {
                    entity = this.addFeature(type, feature);
                }

                if (opts.onEachEntity) //添加到地图后回调方法
                    opts.onEachEntity(feature, entity, i);

                arrthis.push(entity);
            }

            if (opts.flyTo) {
                this.viewer.mars.flyTo(arrthis);
            }

            return arrthis;
        }

        //外部添加billboard点数据

    }, {
        key: 'addBillboard',
        value: function addBillboard(point, style) {
            if (point instanceof Cesium.Cartesian3) {
                point = pointconvert.cartesian2lonlat(point);
            }
            var type = 'billboard';

            var feature = {
                type: "Feature",
                properties: { style: style },
                geometry: { type: "Point", coordinates: point }
            };

            var entity = this.addFeature(type, feature);
            return entity;
        }
        //外部添加billboard点数据

    }, {
        key: 'addPoint',
        value: function addPoint(point, style) {
            if (point instanceof Cesium.Cartesian3) {
                point = pointconvert.cartesian2lonlat(point);
            }

            var type = 'point';

            var feature = {
                type: "Feature",
                properties: { style: style },
                geometry: { type: "Point", coordinates: point }
            };

            var entity = this.addFeature(type, feature);
            return entity;
        }
        //外部添加线数据

    }, {
        key: 'addPolyline',
        value: function addPolyline(coordinates, style) {
            var type = 'polyline';

            var feature = {
                type: "Feature",
                properties: { style: style },
                geometry: {
                    type: "LineString",
                    coordinates: coordinates
                }
            };

            var entity = this.addFeature(type, feature);
            return entity;
        }
        //外部添加面数据

    }, {
        key: 'addPolygon',
        value: function addPolygon(coordinates, style) {
            var type = 'polygon';

            var feature = {
                type: "Feature",
                properties: { style: style },
                geometry: {
                    type: "Polygon",
                    coordinates: [coordinates]
                }
            };

            var entity = this.addFeature(type, feature);
            return entity;
        }
        //外部添加数据（内部使用的）

    }, {
        key: 'addFeature',
        value: function addFeature(type, geojson) {
            geojson.properties.type = type;
            geojson.properties.style = geojson.properties.style || {};

            //赋默认值  
            geojson.properties = attr.addGeoJsonDefVal(geojson.properties);

            //或者分组
            var group = this.addOrGetGroup(geojson.properties.group);

            var entity = this.drawCtrl[type].jsonToEntity(geojson, group);
            this.bindExtension(entity);
            return entity;
        }
        //属性转entity

    }, {
        key: 'attributeToEntity',
        value: function attributeToEntity(attribute, positions) {
            var entity = this.drawCtrl[attribute.type].attributeToEntity(attribute, positions);
            this.bindExtension(entity);
            return entity;
        }
        //绑定外部非Draw产生的entity到标绘

    }, {
        key: 'bindExtraEntity',
        value: function bindExtraEntity(entity, attribute) {
            attribute = attribute || {};
            attribute.type = attribute.type || attr.getTypeName(entity);
            attribute.style = attribute.style || {};
            // attribute = attr.addGeoJsonDefVal(attribute);

            var entity = this.drawCtrl[attribute.type].bindExtraEntity(entity, attribute);
            this.bindExtension(entity);

            entity.entityCollection.remove(entity); //从原有的集合中删除 
            this.dataSource.entities.add(entity); //加入到draw集合图层中
        }
        //==========对外接口========== 

    }, {
        key: 'setVisible',
        value: function setVisible(visible) {
            this._visible = visible;
            if (!visible) {
                this.stopDraw();
            }

            for (var i = 0; i < this.arrGroup.length; i++) {
                var layer = this.arrGroup[i];
                layer.show = visible;
            }
        }
        //是否存在绘制

    }, {
        key: 'hasDraw',
        value: function hasDraw() {
            for (var i = 0; i < this.arrGroup.length; i++) {
                var layer = this.arrGroup[i];
                if (layer.entities.values.length > 0) return true;
            }
            return false;
        }
        //获取所有绘制的实体对象列表

    }, {
        key: 'getEntitys',
        value: function getEntitys(noStop) {
            if (!noStop) this.stopDraw();

            var arr = [];
            for (var i = 0; i < this.arrGroup.length; i++) {
                var layer = this.arrGroup[i];
                var arrEntity = layer.entities.values;
                for (var j = 0, len = arrEntity.length; j < len; j++) {
                    var entity = arrEntity[j];
                    entity.attribute.group = layer.name; //记录分组信息
                    arr.push(entity);
                }
            }
            return arr;
        }
    }, {
        key: 'getEntityById',
        value: function getEntityById(id) {
            if (!id) return null;

            var arrEntity = this.getEntitys();
            for (var i = 0, len = arrEntity.length; i < len; i++) {
                var entity = arrEntity[i];
                if (id == entity.attribute.attr.id) {
                    return entity;
                }
            }
            return null;
        }
        //获取实体的经纬度值 坐标数组

    }, {
        key: 'getCoordinates',
        value: function getCoordinates(entity) {
            var type = entity.attribute.type;
            var coor = this.drawCtrl[type].getCoordinates(entity);
            return coor;
        }
        //获取实体的坐标数组

    }, {
        key: 'getPositions',
        value: function getPositions(entity) {
            var type = entity.attribute.type;
            var positions = this.drawCtrl[type].getPositions(entity);
            return positions;
        }
    }, {
        key: 'flyTo',
        value: function flyTo(entity, opts) {
            this.viewer.mars.flyTo(entity, opts);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.stopDraw();
            this.hasEdit(false);

            for (var type in this.drawCtrl) {
                this.drawCtrl[type].destroy();
            }
            delete this.drawCtrl;
            this.clearDraw();

            for (var i = 0; i < this.arrGroup.length; i++) {
                var layer = this.arrGroup[i];
                if (this.viewer.dataSources.contains(layer)) {
                    this.viewer.dataSources.remove(layer, true);
                }
            }
            if (this.tooltip) {
                this.tooltip.destroy();
                delete this.tooltip;
            }

            _get(Draw.prototype.__proto__ || Object.getPrototypeOf(Draw.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'visible',
        get: function get() {
            return this.getVisible();
        },
        set: function set(val) {
            this.setVisible(val);
        }
    }, {
        key: 'edit',
        get: function get() {
            return this._hasEdit;
        },
        set: function set(val) {
            this.hasEdit(val);
        }

        //是否还在绘制中

    }, {
        key: 'drawing',
        get: function get() {
            return this.hasDrawing();
        }

        //获取所有分组

    }, {
        key: 'dataSources',
        get: function get() {
            return this.arrGroup;
        }

        //当前激活的分组

    }, {
        key: 'dataSource',
        get: function get() {
            return this._dataSourceAct;
        },
        set: function set(layer) {
            if (this._dataSourceAct) {
                //上一次的取消激活状态
                delete this._dataSourceAct.isActivate;
            }

            this._dataSourceAct = layer;
            if (this._dataSourceAct) {
                //本次的标记为激活状态
                this._dataSourceAct.isActivate = true;
            }

            if (this.drawCtrl) {
                for (var type in this.drawCtrl) {
                    this.drawCtrl[type].dataSource = layer;
                }
            }
        }
    }]);

    return Draw;
}(_MarsClass2.MarsClass);
//[静态属性]本类中支持的事件类型常量


Draw.event = {
    drawStart: _MarsClass2.eventType.drawStart,
    drawAddPoint: _MarsClass2.eventType.drawAddPoint,
    drawRemovePoint: _MarsClass2.eventType.drawRemovePoint,
    drawMouseMove: _MarsClass2.eventType.drawMouseMove,
    drawCreated: _MarsClass2.eventType.drawCreated,
    editStart: _MarsClass2.eventType.editStart,
    editMouseDown: _MarsClass2.eventType.editMouseDown,
    editMouseMove: _MarsClass2.eventType.editMouseMove,
    editMovePoint: _MarsClass2.eventType.editMovePoint,
    editRemovePoint: _MarsClass2.eventType.editRemovePoint,
    editStop: _MarsClass2.eventType.editStop,
    delete: _MarsClass2.eventType.delete,
    load: _MarsClass2.eventType.load

    //绑定到draw，方便外部使用
};Draw.Base = _Draw.DrawBase;
Draw.Billboard = _Draw3.DrawBillboard;
Draw.Circle = _Draw13.DrawCircle;
Draw.Cylinder = _Draw14.DrawCylinder;
Draw.Corridor = _Draw9.DrawCorridor;
Draw.Curve = _Draw7.DrawCurve;
Draw.Ellipsoid = _Draw15.DrawEllipsoid;
Draw.Label = _Draw4.DrawLabel;
Draw.Model = _Draw5.DrawModel;
Draw.Point = _Draw2.DrawPoint;
Draw.Polygon = _Draw10.DrawPolygon;
Draw.Polyline = _Draw6.DrawPolyline;
Draw.PolylineVolume = _Draw8.DrawPolylineVolume;
Draw.Rectangle = _Draw12.DrawRectangle;
Draw.Wall = _Draw16.DrawWall;
Draw.PolygonEx = _Draw11.DrawPolygonEx;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.message = exports.Tooltip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _zepto = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tooltip = exports.Tooltip = function () {
    //========== 构造方法 ========== 
    function Tooltip(frameDiv) {
        _classCallCheck(this, Tooltip);

        var div = document.createElement('DIV');
        div.className = "okay3d-draw-tooltip right";

        var arrow = document.createElement('DIV');
        arrow.className = "okay3d-draw-tooltip-arrow";
        div.appendChild(arrow);

        var title = document.createElement('DIV');
        title.className = "okay3d-draw-tooltip-inner";
        div.appendChild(title);

        this._div = div;
        this._title = title;

        // add to frame div and display coordinates
        frameDiv.appendChild(div);

        //鼠标的移入
        (0, _zepto.zepto)(".okay3d-draw-tooltip").mouseover(function () {
            (0, _zepto.zepto)(this).hide();
        });
    }

    _createClass(Tooltip, [{
        key: 'setVisible',
        value: function setVisible(visible) {
            this._div.style.display = visible ? 'block' : 'none';
        }
    }, {
        key: 'showAt',
        value: function showAt(position, message) {
            if (position && message) {
                this.setVisible(true);

                this._title.innerHTML = message;
                this._div.style.top = position.y - this._div.clientHeight / 2 + "px";

                //left css时
                //this._div.style.left = (position.x - this._div.clientWidth - 30) + "px"; 

                //right css时
                this._div.style.left = position.x + 30 + "px";
            } else {
                this.setVisible(false);
            }
        }
    }, {
        key: 'destroy',
        value: function destroy(visible) {
            this.setVisible(false);
            (0, _zepto.zepto)(this._div).remove();
        }
    }]);

    return Tooltip;
}();

//样式文件在map.css


var message = exports.message = {
    draw: {
        point: {
            start: '单击 完成绘制'
        },
        polyline: { //线面
            start: '单击 开始绘制',
            cont: '单击增加点，右击删除点',
            end: '单击增加点，右击删除点<br/>双击完成绘制',
            end2: '单击完成绘制'
        }
    },
    edit: {
        start: '单击后 激活编辑<br/>右击 单击菜单删除',
        end: '释放后 完成修改'
    },
    dragger: {
        def: '拖动该点后<br/>修改位置 ', //默认  
        moveAll: '拖动该点后<br/>整体平移',
        addMidPoint: '拖动该点后<br/>增加点',
        moveHeight: '拖动该点后<br/>修改高度',
        editRadius: '拖动该点后<br/>修改半径',
        editHeading: '拖动该点后<br/>修改方向',
        editScale: '拖动该点后<br/>修改缩放比例'
    },
    del: {
        def: '<br/>右击 删除该点',
        min: '无法删除，点数量不能少于'
    }
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* zepto v1.2.0 - 替代jquery的库 */

//目前主要用到：DOM的操作和事件、ajax请求。
var zepto = function () {
  var undefined,
      key,
      $,
      classList,
      emptyArray = [],
      _concat = emptyArray.concat,
      _filter = emptyArray.filter,
      _slice = emptyArray.slice,
      document = window.document,
      elementDisplay = {},
      classCache = {},
      cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1, 'opacity': 1, 'z-index': 1, 'zoom': 1 },
      fragmentRE = /^\s*<(\w+|!)[^>]*>/,
      singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
      tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
      rootNodeRE = /^(?:body|html)$/i,
      capitalRE = /([A-Z])/g,


  // special attributes that should be get/set via method calls
  methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],
      adjacencyOperators = ['after', 'prepend', 'before', 'append'],
      table = document.createElement('table'),
      tableRow = document.createElement('tr'),
      containers = {
    'tr': document.createElement('tbody'),
    'tbody': table, 'thead': table, 'tfoot': table,
    'td': tableRow, 'th': tableRow,
    '*': document.createElement('div')
  },
      readyRE = /complete|loaded|interactive/,
      simpleSelectorRE = /^[\w-]*$/,
      class2type = {},
      toString = class2type.toString,
      zepto = {},
      camelize,
      uniq,
      tempParent = document.createElement('div'),
      propMap = {
    'tabindex': 'tabIndex',
    'readonly': 'readOnly',
    'for': 'htmlFor',
    'class': 'className',
    'maxlength': 'maxLength',
    'cellspacing': 'cellSpacing',
    'cellpadding': 'cellPadding',
    'rowspan': 'rowSpan',
    'colspan': 'colSpan',
    'usemap': 'useMap',
    'frameborder': 'frameBorder',
    'contenteditable': 'contentEditable'
  },
      isArray = Array.isArray || function (object) {
    return object instanceof Array;
  };

  zepto.matches = function (element, selector) {
    if (!selector || !element || element.nodeType !== 1) return false;
    var matchesSelector = element.matches || element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector;
    if (matchesSelector) return matchesSelector.call(element, selector);
    // fall back to performing a selector:
    var match,
        parent = element.parentNode,
        temp = !parent;
    if (temp) (parent = tempParent).appendChild(element);
    match = ~zepto.qsa(parent, selector).indexOf(element);
    temp && tempParent.removeChild(element);
    return match;
  };

  function type(obj) {
    return obj == null ? String(obj) : class2type[toString.call(obj)] || "object";
  }

  function isFunction(value) {
    return type(value) == "function";
  }
  function isWindow(obj) {
    return obj != null && obj == obj.window;
  }
  function isDocument(obj) {
    return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
  }
  function isObject(obj) {
    return type(obj) == "object";
  }
  function isPlainObject(obj) {
    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
  }

  function likeArray(obj) {
    var length = !!obj && 'length' in obj && obj.length,
        type = $.type(obj);

    return 'function' != type && !isWindow(obj) && ('array' == type || length === 0 || typeof length == 'number' && length > 0 && length - 1 in obj);
  }

  function compact(array) {
    return _filter.call(array, function (item) {
      return item != null;
    });
  }
  function flatten(array) {
    return array.length > 0 ? $.fn.concat.apply([], array) : array;
  }
  camelize = function camelize(str) {
    return str.replace(/-+(.)?/g, function (match, chr) {
      return chr ? chr.toUpperCase() : '';
    });
  };
  function dasherize(str) {
    return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
  }
  uniq = function uniq(array) {
    return _filter.call(array, function (item, idx) {
      return array.indexOf(item) == idx;
    });
  };

  function classRE(name) {
    return name in classCache ? classCache[name] : classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)');
  }

  function maybeAddPx(name, value) {
    return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
  }

  function defaultDisplay(nodeName) {
    var element, display;
    if (!elementDisplay[nodeName]) {
      element = document.createElement(nodeName);
      document.body.appendChild(element);
      display = getComputedStyle(element, '').getPropertyValue("display");
      element.parentNode.removeChild(element);
      display == "none" && (display = "block");
      elementDisplay[nodeName] = display;
    }
    return elementDisplay[nodeName];
  }

  function _children(element) {
    return 'children' in element ? _slice.call(element.children) : $.map(element.childNodes, function (node) {
      if (node.nodeType == 1) return node;
    });
  }

  function Z(dom, selector) {
    var i,
        len = dom ? dom.length : 0;
    for (i = 0; i < len; i++) {
      this[i] = dom[i];
    }this.length = len;
    this.selector = selector || '';
  }

  // `$.zepto.fragment` takes a html string and an optional tag name
  // to generate DOM nodes from the given html string.
  // The generated DOM nodes are returned as an array.
  // This function can be overridden in plugins for example to make
  // it compatible with browsers that don't support the DOM fully.
  zepto.fragment = function (html, name, properties) {
    var dom, nodes, container;

    // A special case optimization for a single tag
    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1));

    if (!dom) {
      if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>");
      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1;
      if (!(name in containers)) name = '*';

      container = containers[name];
      container.innerHTML = '' + html;
      dom = $.each(_slice.call(container.childNodes), function () {
        container.removeChild(this);
      });
    }

    if (isPlainObject(properties)) {
      nodes = $(dom);
      $.each(properties, function (key, value) {
        if (methodAttributes.indexOf(key) > -1) nodes[key](value);else nodes.attr(key, value);
      });
    }

    return dom;
  };

  // `$.zepto.Z` swaps out the prototype of the given `dom` array
  // of nodes with `$.fn` and thus supplying all the zepto functions
  // to the array. This method can be overridden in plugins.
  zepto.Z = function (dom, selector) {
    return new Z(dom, selector);
  };

  // `$.zepto.isZ` should return `true` if the given object is a zepto
  // collection. This method can be overridden in plugins.
  zepto.isZ = function (object) {
    return object instanceof zepto.Z;
  };

  // `$.zepto.init` is zepto's counterpart to jQuery's `$.fn.init` and
  // takes a CSS selector and an optional context (and handles various
  // special cases).
  // This method can be overridden in plugins.
  zepto.init = function (selector, context) {
    var dom;
    // If nothing given, return an empty zepto collection
    if (!selector) return zepto.Z();
    // Optimize for string selectors
    else if (typeof selector == 'string') {
        selector = selector.trim();
        // If it's a html fragment, create nodes from it
        // Note: In both Chrome 21 and Firefox 15, DOM error 12
        // is thrown if the fragment doesn't begin with <
        if (selector[0] == '<' && fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null;
        // If there's a context, create a collection on that context first, and select
        // nodes from there
        else if (context !== undefined) return $(context).find(selector);
          // If it's a CSS selector, use it to select nodes.
          else dom = zepto.qsa(document, selector);
      }
      // If a function is given, call it when the DOM is ready
      else if (isFunction(selector)) return $(document).ready(selector);
        // If a zepto collection is given, just return it
        else if (zepto.isZ(selector)) return selector;else {
            // normalize array if an array of nodes is given
            if (isArray(selector)) dom = compact(selector);
            // Wrap DOM nodes.
            else if (isObject(selector)) {
                if (selector.length > 0) dom = selector, selector = null;else dom = [selector], selector = null;
              }
              // If it's a html fragment, create nodes from it
              else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null;
                // If there's a context, create a collection on that context first, and select
                // nodes from there
                else if (context !== undefined) return $(context).find(selector);
                  // And last but no least, if it's a CSS selector, use it to select nodes.
                  else dom = zepto.qsa(document, selector);
          }
    // create a new zepto collection from the nodes found
    return zepto.Z(dom, selector);
  };

  // `$` will be the base `zepto` object. When calling this
  // function just call `$.zepto.init, which makes the implementation
  // details of selecting nodes and creating zepto collections
  // patchable in plugins.
  $ = function $(selector, context) {
    return zepto.init(selector, context);
  };

  function extend(target, source, deep) {
    for (key in source) {
      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key])) target[key] = {};
        if (isArray(source[key]) && !isArray(target[key])) target[key] = [];
        extend(target[key], source[key], deep);
      } else if (source[key] !== undefined) target[key] = source[key];
    }
  }

  // Copy all but undefined properties from one or more
  // objects to the `target` object.
  $.extend = function (target) {
    var deep,
        args = _slice.call(arguments, 1);
    if (typeof target == 'boolean') {
      deep = target;
      target = args.shift();
    }
    args.forEach(function (arg) {
      extend(target, arg, deep);
    });
    return target;
  };

  // `$.zepto.qsa` is zepto's CSS selector implementation which
  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
  // This method can be overridden in plugins.
  zepto.qsa = function (element, selector) {
    var found,
        maybeID = selector[0] == '#',
        maybeClass = !maybeID && selector[0] == '.',
        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector,
        // Ensure that a 1 char tag name still gets checked
    isSimple = simpleSelectorRE.test(nameOnly);
    return element.getElementById && isSimple && maybeID ? // Safari DocumentFragment doesn't have getElementById
    (found = element.getElementById(nameOnly)) ? [found] : [] : element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11 ? [] : _slice.call(isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName
    maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class
    element.getElementsByTagName(selector) : // Or a tag
    element.querySelectorAll(selector) // Or it's not simple, and we need to query all
    );
  };

  function filtered(nodes, selector) {
    return selector == null ? $(nodes) : $(nodes).filter(selector);
  }

  $.contains = document.documentElement.contains ? function (parent, node) {
    return parent !== node && parent.contains(node);
  } : function (parent, node) {
    while (node && (node = node.parentNode)) {
      if (node === parent) return true;
    }return false;
  };

  function funcArg(context, arg, idx, payload) {
    return isFunction(arg) ? arg.call(context, idx, payload) : arg;
  }

  function setAttribute(node, name, value) {
    value == null ? node.removeAttribute(name) : node.setAttribute(name, value);
  }

  // access className property while respecting SVGAnimatedString
  function className(node, value) {
    var klass = node.className || '',
        svg = klass && klass.baseVal !== undefined;

    if (value === undefined) return svg ? klass.baseVal : klass;
    svg ? klass.baseVal = value : node.className = value;
  }

  // "true"  => true
  // "false" => false
  // "null"  => null
  // "42"    => 42
  // "42.5"  => 42.5
  // "08"    => "08"
  // JSON    => parse if valid
  // String  => self
  function deserializeValue(value) {
    try {
      return value ? value == "true" || (value == "false" ? false : value == "null" ? null : +value + "" == value ? +value : /^[\[\{]/.test(value) ? $.parseJSON(value) : value) : value;
    } catch (e) {
      return value;
    }
  }

  $.type = type;
  $.isFunction = isFunction;
  $.isWindow = isWindow;
  $.isArray = isArray;
  $.isPlainObject = isPlainObject;

  $.isEmptyObject = function (obj) {
    var name;
    for (name in obj) {
      return false;
    }return true;
  };

  $.isNumeric = function (val) {
    var num = Number(val),
        type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
    return val != null && type != 'boolean' && (type != 'string' || val.length) && !isNaN(num) && isFinite(num) || false;
  };

  $.inArray = function (elem, array, i) {
    return emptyArray.indexOf.call(array, elem, i);
  };

  $.camelCase = camelize;
  $.trim = function (str) {
    return str == null ? "" : String.prototype.trim.call(str);
  };

  // plugin compatibility
  $.uuid = 0;
  $.support = {};
  $.expr = {};
  $.noop = function () {};

  $.map = function (elements, callback) {
    var value,
        values = [],
        i,
        key;
    if (likeArray(elements)) for (i = 0; i < elements.length; i++) {
      value = callback(elements[i], i);
      if (value != null) values.push(value);
    } else for (key in elements) {
      value = callback(elements[key], key);
      if (value != null) values.push(value);
    }
    return flatten(values);
  };

  $.each = function (elements, callback) {
    var i, key;
    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++) {
        if (callback.call(elements[i], i, elements[i]) === false) return elements;
      }
    } else {
      for (key in elements) {
        if (callback.call(elements[key], key, elements[key]) === false) return elements;
      }
    }

    return elements;
  };

  $.grep = function (elements, callback) {
    return _filter.call(elements, callback);
  };

  if (window.JSON) $.parseJSON = JSON.parse;

  // Populate the class2type map
  $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  // Define methods that will be available on all
  // zepto collections
  $.fn = {
    constructor: zepto.Z,
    length: 0,

    // Because a collection acts like an array
    // copy over these useful array functions.
    forEach: emptyArray.forEach,
    reduce: emptyArray.reduce,
    push: emptyArray.push,
    sort: emptyArray.sort,
    splice: emptyArray.splice,
    indexOf: emptyArray.indexOf,
    concat: function concat() {
      var i,
          value,
          args = [];
      for (i = 0; i < arguments.length; i++) {
        value = arguments[i];
        args[i] = zepto.isZ(value) ? value.toArray() : value;
      }
      return _concat.apply(zepto.isZ(this) ? this.toArray() : this, args);
    },

    // `map` and `slice` in the jQuery API work differently
    // from their array counterparts
    map: function map(fn) {
      return $($.map(this, function (el, i) {
        return fn.call(el, i, el);
      }));
    },
    slice: function slice() {
      return $(_slice.apply(this, arguments));
    },

    ready: function ready(callback) {
      // need to check if document.body exists for IE as that browser reports
      // document ready when it hasn't yet created the body element
      if (readyRE.test(document.readyState) && document.body) callback($);else document.addEventListener('DOMContentLoaded', function () {
        callback($);
      }, false);
      return this;
    },
    get: function get(idx) {
      return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
    },
    toArray: function toArray() {
      return this.get();
    },
    size: function size() {
      return this.length;
    },
    remove: function remove() {
      return this.each(function () {
        if (this.parentNode != null) this.parentNode.removeChild(this);
      });
    },
    each: function each(callback) {
      emptyArray.every.call(this, function (el, idx) {
        return callback.call(el, idx, el) !== false;
      });
      return this;
    },
    filter: function filter(selector) {
      if (isFunction(selector)) return this.not(this.not(selector));
      return $(_filter.call(this, function (element) {
        return zepto.matches(element, selector);
      }));
    },
    add: function add(selector, context) {
      return $(uniq(this.concat($(selector, context))));
    },
    is: function is(selector) {
      return this.length > 0 && zepto.matches(this[0], selector);
    },
    not: function not(selector) {
      var nodes = [];
      if (isFunction(selector) && selector.call !== undefined) this.each(function (idx) {
        if (!selector.call(this, idx)) nodes.push(this);
      });else {
        var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);
        this.forEach(function (el) {
          if (excludes.indexOf(el) < 0) nodes.push(el);
        });
      }
      return $(nodes);
    },
    has: function has(selector) {
      return this.filter(function () {
        return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size();
      });
    },
    eq: function eq(idx) {
      return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
    },
    first: function first() {
      var el = this[0];
      return el && !isObject(el) ? el : $(el);
    },
    last: function last() {
      var el = this[this.length - 1];
      return el && !isObject(el) ? el : $(el);
    },
    find: function find(selector) {
      var result,
          $this = this;
      if (!selector) result = $();else if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) == 'object') result = $(selector).filter(function () {
        var node = this;
        return emptyArray.some.call($this, function (parent) {
          return $.contains(parent, node);
        });
      });else if (this.length == 1) result = $(zepto.qsa(this[0], selector));else result = this.map(function () {
        return zepto.qsa(this, selector);
      });
      return result;
    },
    closest: function closest(selector, context) {
      var nodes = [],
          collection = (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) == 'object' && $(selector);
      this.each(function (_, node) {
        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector))) {
          node = node !== context && !isDocument(node) && node.parentNode;
        }if (node && nodes.indexOf(node) < 0) nodes.push(node);
      });
      return $(nodes);
    },
    parents: function parents(selector) {
      var ancestors = [],
          nodes = this;
      while (nodes.length > 0) {
        nodes = $.map(nodes, function (node) {
          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
            ancestors.push(node);
            return node;
          }
        });
      }return filtered(ancestors, selector);
    },
    parent: function parent(selector) {
      return filtered(uniq(this.pluck('parentNode')), selector);
    },
    children: function children(selector) {
      return filtered(this.map(function () {
        return _children(this);
      }), selector);
    },
    contents: function contents() {
      return this.map(function () {
        return this.contentDocument || _slice.call(this.childNodes);
      });
    },
    siblings: function siblings(selector) {
      return filtered(this.map(function (i, el) {
        return _filter.call(_children(el.parentNode), function (child) {
          return child !== el;
        });
      }), selector);
    },
    empty: function empty() {
      return this.each(function () {
        this.innerHTML = '';
      });
    },
    // `pluck` is borrowed from Prototype.js
    pluck: function pluck(property) {
      return $.map(this, function (el) {
        return el[property];
      });
    },
    show: function show() {
      return this.each(function () {
        this.style.display == "none" && (this.style.display = '');
        if (getComputedStyle(this, '').getPropertyValue("display") == "none") this.style.display = defaultDisplay(this.nodeName);
      });
    },
    replaceWith: function replaceWith(newContent) {
      return this.before(newContent).remove();
    },
    wrap: function wrap(structure) {
      var func = isFunction(structure);
      if (this[0] && !func) var dom = $(structure).get(0),
          clone = dom.parentNode || this.length > 1;

      return this.each(function (index) {
        $(this).wrapAll(func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom);
      });
    },
    wrapAll: function wrapAll(structure) {
      if (this[0]) {
        $(this[0]).before(structure = $(structure));
        var children;
        // drill down to the inmost element
        while ((children = structure.children()).length) {
          structure = children.first();
        }$(structure).append(this);
      }
      return this;
    },
    wrapInner: function wrapInner(structure) {
      var func = isFunction(structure);
      return this.each(function (index) {
        var self = $(this),
            contents = self.contents(),
            dom = func ? structure.call(this, index) : structure;
        contents.length ? contents.wrapAll(dom) : self.append(dom);
      });
    },
    unwrap: function unwrap() {
      this.parent().each(function () {
        $(this).replaceWith($(this).children());
      });
      return this;
    },
    clone: function clone() {
      return this.map(function () {
        return this.cloneNode(true);
      });
    },
    hide: function hide() {
      return this.css("display", "none");
    },
    toggle: function toggle(setting) {
      return this.each(function () {
        var el = $(this);(setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide();
      });
    },
    prev: function prev(selector) {
      return $(this.pluck('previousElementSibling')).filter(selector || '*');
    },
    next: function next(selector) {
      return $(this.pluck('nextElementSibling')).filter(selector || '*');
    },
    html: function html(_html) {
      return 0 in arguments ? this.each(function (idx) {
        var originHtml = this.innerHTML;
        $(this).empty().append(funcArg(this, _html, idx, originHtml));
      }) : 0 in this ? this[0].innerHTML : null;
    },
    text: function text(_text) {
      return 0 in arguments ? this.each(function (idx) {
        var newText = funcArg(this, _text, idx, this.textContent);
        this.textContent = newText == null ? '' : '' + newText;
      }) : 0 in this ? this.pluck('textContent').join("") : null;
    },
    attr: function attr(name, value) {
      var result;
      return typeof name == 'string' && !(1 in arguments) ? 0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined : this.each(function (idx) {
        if (this.nodeType !== 1) return;
        if (isObject(name)) for (key in name) {
          setAttribute(this, key, name[key]);
        } else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)));
      });
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        this.nodeType === 1 && name.split(' ').forEach(function (attribute) {
          setAttribute(this, attribute);
        }, this);
      });
    },
    prop: function prop(name, value) {
      name = propMap[name] || name;
      return 1 in arguments ? this.each(function (idx) {
        this[name] = funcArg(this, value, idx, this[name]);
      }) : this[0] && this[0][name];
    },
    removeProp: function removeProp(name) {
      name = propMap[name] || name;
      return this.each(function () {
        delete this[name];
      });
    },
    data: function data(name, value) {
      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase();

      var data = 1 in arguments ? this.attr(attrName, value) : this.attr(attrName);

      return data !== null ? deserializeValue(data) : undefined;
    },
    val: function val(value) {
      if (0 in arguments) {
        if (value == null) value = "";
        return this.each(function (idx) {
          this.value = funcArg(this, value, idx, this.value);
        });
      } else {
        return this[0] && (this[0].multiple ? $(this[0]).find('option').filter(function () {
          return this.selected;
        }).pluck('value') : this[0].value);
      }
    },
    offset: function offset(coordinates) {
      if (coordinates) return this.each(function (index) {
        var $this = $(this),
            coords = funcArg(this, coordinates, index, $this.offset()),
            parentOffset = $this.offsetParent().offset(),
            props = {
          top: coords.top - parentOffset.top,
          left: coords.left - parentOffset.left
        };

        if ($this.css('position') == 'static') props['position'] = 'relative';
        $this.css(props);
      });
      if (!this.length) return null;
      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0])) return { top: 0, left: 0 };
      var obj = this[0].getBoundingClientRect();

      obj.width = this[0].offsetWidth; //wanghao 2020-3-22 add 
      obj.height = this[0].offsetHeight;

      return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: Math.round(obj.width),
        height: Math.round(obj.height)
      };
    },
    css: function css(property, value) {
      if (arguments.length < 2) {
        var element = this[0];
        if (typeof property == 'string') {
          if (!element) return;
          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property);
        } else if (isArray(property)) {
          if (!element) return;
          var props = {};
          var computedStyle = getComputedStyle(element, '');
          $.each(property, function (_, prop) {
            props[prop] = element.style[camelize(prop)] || computedStyle.getPropertyValue(prop);
          });
          return props;
        }
      }

      var css = '';
      if (type(property) == 'string') {
        if (!value && value !== 0) this.each(function () {
          this.style.removeProperty(dasherize(property));
        });else css = dasherize(property) + ":" + maybeAddPx(property, value);
      } else {
        for (key in property) {
          if (!property[key] && property[key] !== 0) this.each(function () {
            this.style.removeProperty(dasherize(key));
          });else css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
        }
      }

      return this.each(function () {
        if (!this.style) return;
        this.style.cssText += ';' + css;
      });
    },
    index: function index(element) {
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
    },
    hasClass: function hasClass(name) {
      if (!name) return false;
      return emptyArray.some.call(this, function (el) {
        return this.test(className(el));
      }, classRE(name));
    },
    addClass: function addClass(name) {
      if (!name) return this;
      return this.each(function (idx) {
        if (!('className' in this)) return;
        classList = [];
        var cls = className(this),
            newName = funcArg(this, name, idx, cls);
        newName.split(/\s+/g).forEach(function (klass) {
          if (!$(this).hasClass(klass)) classList.push(klass);
        }, this);
        classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "));
      });
    },
    removeClass: function removeClass(name) {
      return this.each(function (idx) {
        if (!('className' in this)) return;
        if (name === undefined) return className(this, '');
        classList = className(this);
        funcArg(this, name, idx, classList).split(/\s+/g).forEach(function (klass) {
          classList = classList.replace(classRE(klass), " ");
        });
        className(this, classList.trim());
      });
    },
    toggleClass: function toggleClass(name, when) {
      if (!name) return this;
      return this.each(function (idx) {
        var $this = $(this),
            names = funcArg(this, name, idx, className(this));
        names.split(/\s+/g).forEach(function (klass) {
          (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass);
        });
      });
    },
    scrollTop: function scrollTop(value) {
      if (!this.length) return;
      var hasScrollTop = 'scrollTop' in this[0];
      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
      return this.each(hasScrollTop ? function () {
        this.scrollTop = value;
      } : function () {
        this.scrollTo(this.scrollX, value);
      });
    },
    scrollLeft: function scrollLeft(value) {
      if (!this.length) return;
      var hasScrollLeft = 'scrollLeft' in this[0];
      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
      return this.each(hasScrollLeft ? function () {
        this.scrollLeft = value;
      } : function () {
        this.scrollTo(value, this.scrollY);
      });
    },
    position: function position() {
      if (!this.length) return;

      var elem = this[0],

      // Get *real* offsetParent
      offsetParent = this.offsetParent(),

      // Get correct offsets
      offset = this.offset(),
          parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

      // Subtract element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      offset.top -= parseFloat($(elem).css('margin-top')) || 0;
      offset.left -= parseFloat($(elem).css('margin-left')) || 0;

      // Add offsetParent borders
      parentOffset.top += parseFloat($(offsetParent[0]).css('border-top-width')) || 0;
      parentOffset.left += parseFloat($(offsetParent[0]).css('border-left-width')) || 0;

      // Subtract the two offsets
      return {
        top: offset.top - parentOffset.top,
        left: offset.left - parentOffset.left
      };
    },
    offsetParent: function offsetParent() {
      return this.map(function () {
        var parent = this.offsetParent || document.body;
        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static") {
          parent = parent.offsetParent;
        }return parent;
      });
    }

    // for now
  };$.fn.detach = $.fn.remove

  // Generate the `width` and `height` functions
  ;['width', 'height'].forEach(function (dimension) {
    var dimensionProperty = dimension.replace(/./, function (m) {
      return m[0].toUpperCase();
    });

    $.fn[dimension] = function (value) {
      var offset,
          el = this[0];
      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] : isDocument(el) ? el.documentElement['scroll' + dimensionProperty] : (offset = this.offset()) && offset[dimension];else return this.each(function (idx) {
        el = $(this);
        el.css(dimension, funcArg(this, value, idx, el[dimension]()));
      });
    };
  });

  function traverseNode(node, fun) {
    fun(node);
    for (var i = 0, len = node.childNodes.length; i < len; i++) {
      traverseNode(node.childNodes[i], fun);
    }
  }

  // Generate the `after`, `prepend`, `before`, `append`,
  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
  adjacencyOperators.forEach(function (operator, operatorIndex) {
    var inside = operatorIndex % 2; //=> prepend, append

    $.fn[operator] = function () {
      // arguments can be nodes, arrays of nodes, zepto objects and HTML strings
      var argType,
          nodes = $.map(arguments, function (arg) {
        var arr = [];
        argType = type(arg);
        if (argType == "array") {
          arg.forEach(function (el) {
            if (el.nodeType !== undefined) return arr.push(el);else if ($.zepto.isZ(el)) return arr = arr.concat(el.get());
            arr = arr.concat(zepto.fragment(el));
          });
          return arr;
        }
        return argType == "object" || arg == null ? arg : zepto.fragment(arg);
      }),
          parent,
          copyByClone = this.length > 1;
      if (nodes.length < 1) return this;

      return this.each(function (_, target) {
        parent = inside ? target : target.parentNode;

        // convert all methods to a "before" operation
        target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null;

        var parentInDocument = $.contains(document.documentElement, parent);

        nodes.forEach(function (node) {
          if (copyByClone) node = node.cloneNode(true);else if (!parent) return $(node).remove();

          parent.insertBefore(node, target);
          if (parentInDocument) traverseNode(node, function (el) {
            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' && (!el.type || el.type === 'text/javascript') && !el.src) {
              var target = el.ownerDocument ? el.ownerDocument.defaultView : window;
              target['eval'].call(target, el.innerHTML);
            }
          });
        });
      });
    };

    // after    => insertAfter
    // prepend  => prependTo
    // before   => insertBefore
    // append   => appendTo
    $.fn[inside ? operator + 'To' : 'insert' + (operatorIndex ? 'Before' : 'After')] = function (html) {
      $(html)[operator](this);
      return this;
    };
  });

  zepto.Z.prototype = Z.prototype = $.fn;

  // Export internal API functions in the `$.zepto` namespace
  zepto.uniq = uniq;
  zepto.deserializeValue = deserializeValue;
  $.zepto = zepto;

  return $;
}();

(function ($) {
  var _zid = 1,
      undefined,
      slice = Array.prototype.slice,
      isFunction = $.isFunction,
      isString = function isString(obj) {
    return typeof obj == 'string';
  },
      handlers = {},
      specialEvents = {},
      focusinSupported = 'onfocusin' in window,
      focus = { focus: 'focusin', blur: 'focusout' },
      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' };

  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents';

  function zid(element) {
    return element._zid || (element._zid = _zid++);
  }
  function findHandlers(element, event, fn, selector) {
    event = parse(event);
    if (event.ns) var matcher = matcherFor(event.ns);
    return (handlers[zid(element)] || []).filter(function (handler) {
      return handler && (!event.e || handler.e == event.e) && (!event.ns || matcher.test(handler.ns)) && (!fn || zid(handler.fn) === zid(fn)) && (!selector || handler.sel == selector);
    });
  }
  function parse(event) {
    var parts = ('' + event).split('.');
    return { e: parts[0], ns: parts.slice(1).sort().join(' ') };
  }
  function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)');
  }

  function eventCapture(handler, captureSetting) {
    return handler.del && !focusinSupported && handler.e in focus || !!captureSetting;
  }

  function realEvent(type) {
    return hover[type] || focusinSupported && focus[type] || type;
  }

  function add(element, events, fn, data, selector, delegator, capture) {
    var id = zid(element),
        set = handlers[id] || (handlers[id] = []);
    events.split(/\s/).forEach(function (event) {
      if (event == 'ready') return $(document).ready(fn);
      var handler = parse(event);
      handler.fn = fn;
      handler.sel = selector;
      // emulate mouseenter, mouseleave
      if (handler.e in hover) fn = function fn(e) {
        var related = e.relatedTarget;
        if (!related || related !== this && !$.contains(this, related)) return handler.fn.apply(this, arguments);
      };
      handler.del = delegator;
      var callback = delegator || fn;
      handler.proxy = function (e) {
        e = compatible(e);
        if (e.isImmediatePropagationStopped()) return;
        e.data = data;
        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args));
        if (result === false) e.preventDefault(), e.stopPropagation();
        return result;
      };
      handler.i = set.length;
      set.push(handler);
      if ('addEventListener' in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
    });
  }
  function remove(element, events, fn, selector, capture) {
    var id = zid(element);(events || '').split(/\s/).forEach(function (event) {
      findHandlers(element, event, fn, selector).forEach(function (handler) {
        delete handlers[id][handler.i];
        if ('removeEventListener' in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
      });
    });
  }

  $.event = { add: add, remove: remove };

  $.proxy = function (fn, context) {
    var args = 2 in arguments && slice.call(arguments, 2);
    if (isFunction(fn)) {
      var proxyFn = function proxyFn() {
        return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
      };
      proxyFn._zid = zid(fn);
      return proxyFn;
    } else if (isString(context)) {
      if (args) {
        args.unshift(fn[context], fn);
        return $.proxy.apply(null, args);
      } else {
        return $.proxy(fn[context], fn);
      }
    } else {
      throw new TypeError("expected function");
    }
  };

  $.fn.bind = function (event, data, callback) {
    return this.on(event, data, callback);
  };
  $.fn.unbind = function (event, callback) {
    return this.off(event, callback);
  };
  $.fn.one = function (event, selector, data, callback) {
    return this.on(event, selector, data, callback, 1);
  };

  var returnTrue = function returnTrue() {
    return true;
  },
      returnFalse = function returnFalse() {
    return false;
  },
      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,
      eventMethods = {
    preventDefault: 'isDefaultPrevented',
    stopImmediatePropagation: 'isImmediatePropagationStopped',
    stopPropagation: 'isPropagationStopped'
  };

  function compatible(event, source) {
    if (source || !event.isDefaultPrevented) {
      source || (source = event);

      $.each(eventMethods, function (name, predicate) {
        var sourceMethod = source[name];
        event[name] = function () {
          this[predicate] = returnTrue;
          return sourceMethod && sourceMethod.apply(source, arguments);
        };
        event[predicate] = returnFalse;
      });

      event.timeStamp || (event.timeStamp = Date.now());

      if (source.defaultPrevented !== undefined ? source.defaultPrevented : 'returnValue' in source ? source.returnValue === false : source.getPreventDefault && source.getPreventDefault()) event.isDefaultPrevented = returnTrue;
    }
    return event;
  }

  function createProxy(event) {
    var key,
        proxy = { originalEvent: event };
    for (key in event) {
      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key];
    }return compatible(proxy, event);
  }

  $.fn.delegate = function (selector, event, callback) {
    return this.on(event, selector, callback);
  };
  $.fn.undelegate = function (selector, event, callback) {
    return this.off(event, selector, callback);
  };

  $.fn.live = function (event, callback) {
    $(document.body).delegate(this.selector, event, callback);
    return this;
  };
  $.fn.die = function (event, callback) {
    $(document.body).undelegate(this.selector, event, callback);
    return this;
  };

  $.fn.on = function (event, selector, data, callback, one) {
    var autoRemove,
        delegator,
        $this = this;
    if (event && !isString(event)) {
      $.each(event, function (type, fn) {
        $this.on(type, selector, data, fn, one);
      });
      return $this;
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = data, data = selector, selector = undefined;
    if (callback === undefined || data === false) callback = data, data = undefined;

    if (callback === false) callback = returnFalse;

    return $this.each(function (_, element) {
      if (one) autoRemove = function autoRemove(e) {
        remove(element, e.type, callback);
        return callback.apply(this, arguments);
      };

      if (selector) delegator = function delegator(e) {
        var evt,
            match = $(e.target).closest(selector, element).get(0);
        if (match && match !== element) {
          evt = $.extend(createProxy(e), { currentTarget: match, liveFired: element });
          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)));
        }
      };

      add(element, event, callback, data, selector, delegator || autoRemove);
    });
  };
  $.fn.off = function (event, selector, callback) {
    var $this = this;
    if (event && !isString(event)) {
      $.each(event, function (type, fn) {
        $this.off(type, selector, fn);
      });
      return $this;
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = selector, selector = undefined;

    if (callback === false) callback = returnFalse;

    return $this.each(function () {
      remove(this, event, callback, selector);
    });
  };

  $.fn.trigger = function (event, args) {
    event = isString(event) || $.isPlainObject(event) ? $.Event(event) : compatible(event);
    event._args = args;
    return this.each(function () {
      // handle focus(), blur() by calling them directly
      if (event.type in focus && typeof this[event.type] == "function") this[event.type]();
      // items in the collection might not be DOM elements
      else if ('dispatchEvent' in this) this.dispatchEvent(event);else $(this).triggerHandler(event, args);
    });
  };

  // triggers event handlers on current element just as if an event occurred,
  // doesn't trigger an actual event, doesn't bubble
  $.fn.triggerHandler = function (event, args) {
    var e, result;
    this.each(function (i, element) {
      e = createProxy(isString(event) ? $.Event(event) : event);
      e._args = args;
      e.target = element;
      $.each(findHandlers(element, event.type || event), function (i, handler) {
        result = handler.proxy(e);
        if (e.isImmediatePropagationStopped()) return false;
      });
    });
    return result;
  }

  // shortcut methods for `.bind(event, fn)` for each event type
  ;('focusin focusout focus blur load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select keydown keypress keyup error').split(' ').forEach(function (event) {
    $.fn[event] = function (callback) {
      return 0 in arguments ? this.bind(event, callback) : this.trigger(event);
    };
  });

  $.Event = function (type, props) {
    if (!isString(type)) props = type, type = props.type;
    var event = document.createEvent(specialEvents[type] || 'Events'),
        bubbles = true;
    if (props) for (var name in props) {
      name == 'bubbles' ? bubbles = !!props[name] : event[name] = props[name];
    }event.initEvent(type, bubbles, true);
    return compatible(event);
  };
})(zepto);

(function ($) {
  var jsonpID = +new Date(),
      document = window.document,
      key,
      name,
      rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      scriptTypeRE = /^(?:text|application)\/javascript/i,
      xmlTypeRE = /^(?:text|application)\/xml/i,
      jsonType = 'application/json',
      htmlType = 'text/html',
      blankRE = /^\s*$/,
      originAnchor = document.createElement('a');

  originAnchor.href = window.location.href;

  // trigger a custom event and return false if it was cancelled
  function triggerAndReturn(context, eventName, data) {
    var event = $.Event(eventName);
    $(context).trigger(event, data);
    return !event.isDefaultPrevented();
  }

  // trigger an Ajax "global" event
  function triggerGlobal(settings, context, eventName, data) {
    if (settings.global) return triggerAndReturn(context || document, eventName, data);
  }

  // Number of active Ajax requests
  $.active = 0;

  function ajaxStart(settings) {
    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart');
  }
  function ajaxStop(settings) {
    if (settings.global && ! --$.active) triggerGlobal(settings, null, 'ajaxStop');
  }

  // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
  function ajaxBeforeSend(xhr, settings) {
    var context = settings.context;
    if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false) return false;

    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings]);
  }
  function ajaxSuccess(data, xhr, settings, deferred) {
    var context = settings.context,
        status = 'success';
    settings.success.call(context, data, status, xhr);
    if (deferred) deferred.resolveWith(context, [data, status, xhr]);
    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data]);
    ajaxComplete(status, xhr, settings);
  }
  // type: "timeout", "error", "abort", "parsererror"
  function ajaxError(error, type, xhr, settings, deferred) {
    var context = settings.context;
    settings.error.call(context, xhr, type, error);
    if (deferred) deferred.rejectWith(context, [xhr, type, error]);
    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type]);
    ajaxComplete(type, xhr, settings);
  }
  // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
  function ajaxComplete(status, xhr, settings) {
    var context = settings.context;
    settings.complete.call(context, xhr, status);
    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings]);
    ajaxStop(settings);
  }

  function ajaxDataFilter(data, type, settings) {
    if (settings.dataFilter == empty) return data;
    var context = settings.context;
    return settings.dataFilter.call(context, data, type);
  }

  // Empty function, used as default callback
  function empty() {}

  $.ajaxJSONP = function (options, deferred) {
    if (!('type' in options)) return $.ajax(options);

    var _callbackName = options.jsonpCallback,
        callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || 'Zepto' + jsonpID++,
        script = document.createElement('script'),
        originalCallback = window[callbackName],
        responseData,
        abort = function abort(errorType) {
      $(script).triggerHandler('error', errorType || 'abort');
    },
        xhr = { abort: abort },
        abortTimeout;

    if (deferred) deferred.promise(xhr);

    $(script).on('load error', function (e, errorType) {
      clearTimeout(abortTimeout);
      $(script).off().remove();

      if (e.type == 'error' || !responseData) {
        ajaxError(null, errorType || 'error', xhr, options, deferred);
      } else {
        ajaxSuccess(responseData[0], xhr, options, deferred);
      }

      window[callbackName] = originalCallback;
      if (responseData && $.isFunction(originalCallback)) originalCallback(responseData[0]);

      originalCallback = responseData = undefined;
    });

    if (ajaxBeforeSend(xhr, options) === false) {
      abort('abort');
      return xhr;
    }

    window[callbackName] = function () {
      responseData = arguments;
    };

    script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName);
    document.head.appendChild(script);

    if (options.timeout > 0) abortTimeout = setTimeout(function () {
      abort('timeout');
    }, options.timeout);

    return xhr;
  };

  $.ajaxSettings = {
    // Default type of request
    type: 'GET',
    // Callback that is executed before request
    beforeSend: empty,
    // Callback that is executed if the request succeeds
    success: empty,
    // Callback that is executed the the server drops error
    error: empty,
    // Callback that is executed on request complete (both: error and success)
    complete: empty,
    // The context for the callbacks
    context: null,
    // Whether to trigger "global" Ajax events
    global: true,
    // Transport
    xhr: function xhr() {
      return new window.XMLHttpRequest();
    },
    // MIME types mapping
    // IIS returns Javascript as "application/x-javascript"
    accepts: {
      script: 'text/javascript, application/javascript, application/x-javascript',
      json: jsonType,
      xml: 'application/xml, text/xml',
      html: htmlType,
      text: 'text/plain'
    },
    // Whether the request is to another domain
    crossDomain: false,
    // Default timeout
    timeout: 0,
    // Whether data should be serialized to string
    processData: true,
    // Whether the browser should be allowed to cache GET responses
    cache: true,
    //Used to handle the raw response data of XMLHttpRequest.
    //This is a pre-filtering function to sanitize the response.
    //The sanitized response should be returned
    dataFilter: empty
  };

  function mimeToDataType(mime) {
    if (mime) mime = mime.split(';', 2)[0];
    return mime && (mime == htmlType ? 'html' : mime == jsonType ? 'json' : scriptTypeRE.test(mime) ? 'script' : xmlTypeRE.test(mime) && 'xml') || 'text';
  }

  function appendQuery(url, query) {
    if (query == '') return url;
    return (url + '&' + query).replace(/[&?]{1,2}/, '?');
  }

  // serialize payload and append it to the URL for GET requests
  function serializeData(options) {
    if (options.processData && options.data && $.type(options.data) != "string") options.data = $.param(options.data, options.traditional);
    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType)) options.url = appendQuery(options.url, options.data), options.data = undefined;
  }

  $.ajax = function (options) {
    var settings = $.extend({}, options || {}),
        deferred = $.Deferred && $.Deferred(),
        urlAnchor,
        hashIndex;
    for (key in $.ajaxSettings) {
      if (settings[key] === undefined) settings[key] = $.ajaxSettings[key];
    }ajaxStart(settings);

    if (!settings.crossDomain) {
      urlAnchor = document.createElement('a');
      urlAnchor.href = settings.url;
      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049
      urlAnchor.href = urlAnchor.href;
      settings.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
    }

    if (!settings.url) settings.url = window.location.toString();
    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex);
    serializeData(settings);

    var dataType = settings.dataType,
        hasPlaceholder = /\?.+=\?/.test(settings.url);
    if (hasPlaceholder) dataType = 'jsonp';

    if (settings.cache === false || (!options || options.cache !== true) && ('script' == dataType || 'jsonp' == dataType)) settings.url = appendQuery(settings.url, '_=' + Date.now());

    if ('jsonp' == dataType) {
      if (!hasPlaceholder) settings.url = appendQuery(settings.url, settings.jsonp ? settings.jsonp + '=?' : settings.jsonp === false ? '' : 'callback=?');
      return $.ajaxJSONP(settings, deferred);
    }

    var mime = settings.accepts[dataType],
        headers = {},
        setHeader = function setHeader(name, value) {
      headers[name.toLowerCase()] = [name, value];
    },
        protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
        xhr = settings.xhr(),
        nativeSetHeader = xhr.setRequestHeader,
        abortTimeout;

    if (deferred) deferred.promise(xhr);

    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest');
    setHeader('Accept', mime || '*/*');
    if (mime = settings.mimeType || mime) {
      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0];
      xhr.overrideMimeType && xhr.overrideMimeType(mime);
    }
    if (settings.contentType || settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET') setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded');

    if (settings.headers) for (name in settings.headers) {
      setHeader(name, settings.headers[name]);
    }xhr.setRequestHeader = setHeader;

    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        xhr.onreadystatechange = empty;
        clearTimeout(abortTimeout);
        var result,
            error = false;
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 || xhr.status == 0 && protocol == 'file:') {
          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'));

          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob') result = xhr.response;else {
            result = xhr.responseText;

            try {
              // http://perfectionkills.com/global-eval-what-are-the-options/
              // sanitize response accordingly if data filter callback provided
              result = ajaxDataFilter(result, dataType, settings);
              if (dataType == 'script') (1, eval)(result);else if (dataType == 'xml') result = xhr.responseXML;else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result);
            } catch (e) {
              error = e;
            }

            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred);
          }

          ajaxSuccess(result, xhr, settings, deferred);
        } else {
          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred);
        }
      }
    };

    if (ajaxBeforeSend(xhr, settings) === false) {
      xhr.abort();
      ajaxError(null, 'abort', xhr, settings, deferred);
      return xhr;
    }

    var async = 'async' in settings ? settings.async : true;
    xhr.open(settings.type, settings.url, async, settings.username, settings.password);

    if (settings.xhrFields) for (name in settings.xhrFields) {
      xhr[name] = settings.xhrFields[name];
    }for (name in headers) {
      nativeSetHeader.apply(xhr, headers[name]);
    }if (settings.timeout > 0) abortTimeout = setTimeout(function () {
      xhr.onreadystatechange = empty;
      xhr.abort();
      ajaxError(null, 'timeout', xhr, settings, deferred);
    }, settings.timeout);

    // avoid sending empty string (#319)
    xhr.send(settings.data ? settings.data : null);
    return xhr;
  };

  // handle optional data/success arguments
  function parseArguments(url, data, success, dataType) {
    if ($.isFunction(data)) dataType = success, success = data, data = undefined;
    if (!$.isFunction(success)) dataType = success, success = undefined;
    return {
      url: url,
      data: data,
      success: success,
      dataType: dataType
    };
  }

  $.get = function () /* url, data, success, dataType */{
    return $.ajax(parseArguments.apply(null, arguments));
  };

  $.post = function () /* url, data, success, dataType */{
    var options = parseArguments.apply(null, arguments);
    options.type = 'POST';
    return $.ajax(options);
  };

  $.getJSON = function () /* url, data, success */{
    var options = parseArguments.apply(null, arguments);
    options.dataType = 'json';
    return $.ajax(options);
  };

  $.fn.load = function (url, data, success) {
    if (!this.length) return this;
    var self = this,
        parts = url.split(/\s/),
        selector,
        options = parseArguments(url, data, success),
        callback = options.success;
    if (parts.length > 1) options.url = parts[0], selector = parts[1];
    options.success = function (response) {
      self.html(selector ? $('<div>').html(response.replace(rscript, "")).find(selector) : response);
      callback && callback.apply(self, arguments);
    };
    $.ajax(options);
    return this;
  };

  var escape = encodeURIComponent;

  function serialize(params, obj, traditional, scope) {
    var type,
        array = $.isArray(obj),
        hash = $.isPlainObject(obj);
    $.each(obj, function (key, value) {
      type = $.type(value);
      if (scope) key = traditional ? scope : scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']';
      // handle data in serializeArray() format
      if (!scope && array) params.add(value.name, value.value);
      // recurse into nested objects
      else if (type == "array" || !traditional && type == "object") serialize(params, value, traditional, key);else params.add(key, value);
    });
  }

  $.param = function (obj, traditional) {
    var params = [];
    params.add = function (key, value) {
      if ($.isFunction(value)) value = value();
      if (value == null) value = "";
      this.push(escape(key) + '=' + escape(value));
    };
    serialize(params, obj, traditional);
    return params.join('&').replace(/%20/g, '+');
  };
})(zepto);

(function ($) {
  $.fn.serializeArray = function () {
    var name,
        type,
        result = [],
        add = function add(value) {
      if (value.forEach) return value.forEach(add);
      result.push({ name: name, value: value });
    };
    if (this[0]) $.each(this[0].elements, function (_, field) {
      type = field.type, name = field.name;
      if (name && field.nodeName.toLowerCase() != 'fieldset' && !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' && (type != 'radio' && type != 'checkbox' || field.checked)) add($(field).val());
    });
    return result;
  };

  $.fn.serialize = function () {
    var result = [];
    this.serializeArray().forEach(function (elm) {
      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value));
    });
    return result.join('&');
  };

  $.fn.submit = function (callback) {
    if (0 in arguments) this.bind('submit', callback);else if (this.length) {
      var event = $.Event('submit');
      this.eq(0).trigger(event);
      if (!event.isDefaultPrevented()) this.get(0).submit();
    }
    return this;
  };
})(zepto);

(function () {
  // getComputedStyle shouldn't freak out when called
  // without a valid element as argument
  try {
    getComputedStyle(undefined);
  } catch (e) {
    var nativeGetComputedStyle = getComputedStyle;
    window.getComputedStyle = function (element, pseudoElement) {
      try {
        return nativeGetComputedStyle(element, pseudoElement);
      } catch (e) {
        return null;
      }
    };
  }
})();

if (window.jQuery) {
  exports.zepto = zepto = window.jQuery;
}

exports.zepto = zepto;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.plotUtil = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//基本计算方法
var PlotUtilClass = function () {
    function PlotUtilClass() {
        _classCallCheck(this, PlotUtilClass);

        this.HALF_PI = Math.PI / 2;
        this.ZERO_TOLERANCE = 0.0001;
    }

    //获取第三点 


    _createClass(PlotUtilClass, [{
        key: "getThirdPoint",
        value: function getThirdPoint(startPnt, endPnt, angle, distance, clockWise) {
            var azimuth = this.getAzimuth(startPnt, endPnt);
            var alpha = clockWise ? azimuth + angle : azimuth - angle;
            var dx = distance * Math.cos(alpha);
            var dy = distance * Math.sin(alpha);
            return [endPnt[0] + dx, endPnt[1] + dy];
        }

        //计算夹角

    }, {
        key: "getAzimuth",
        value: function getAzimuth(startPoint, endPoint) {
            var azimuth = void 0;
            var angle = Math.asin(Math.abs(endPoint[1] - startPoint[1]) / this.MathDistance(startPoint, endPoint));
            if (endPoint[1] >= startPoint[1] && endPoint[0] >= startPoint[0]) {
                azimuth = angle + Math.PI;
            } else if (endPoint[1] >= startPoint[1] && endPoint[0] < startPoint[0]) {
                azimuth = Math.PI * 2 - angle;
            } else if (endPoint[1] < startPoint[1] && endPoint[0] < startPoint[0]) {
                azimuth = angle;
            } else if (endPoint[1] < startPoint[1] && endPoint[0] >= startPoint[0]) {
                azimuth = Math.PI - angle;
            }
            return azimuth;
        }
    }, {
        key: "MathDistance",
        value: function MathDistance(pnt1, pnt2) {
            return Math.sqrt(Math.pow(pnt1[0] - pnt2[0], 2) + Math.pow(pnt1[1] - pnt2[1], 2));
        }
        //计算闭合曲面上的点

    }, {
        key: "isClockWise",
        value: function isClockWise(pnt1, pnt2, pnt3) {
            return (pnt3[1] - pnt1[1]) * (pnt2[0] - pnt1[0]) > (pnt2[1] - pnt1[1]) * (pnt3[0] - pnt1[0]);
        }
    }, {
        key: "getBisectorNormals",
        value: function getBisectorNormals(t, pnt1, pnt2, pnt3) {
            var normal = this.getNormal(pnt1, pnt2, pnt3);
            var bisectorNormalRight = null,
                bisectorNormalLeft = null,
                dt = null,
                x = null,
                y = null;

            var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
            var uX = normal[0] / dist;
            var uY = normal[1] / dist;
            var d1 = this.MathDistance(pnt1, pnt2);
            var d2 = this.MathDistance(pnt2, pnt3);
            if (dist > this.ZERO_TOLERANCE) {
                if (this.isClockWise(pnt1, pnt2, pnt3)) {
                    dt = t * d1;
                    x = pnt2[0] - dt * uY;
                    y = pnt2[1] + dt * uX;
                    bisectorNormalRight = [x, y];
                    dt = t * d2;
                    x = pnt2[0] + dt * uY;
                    y = pnt2[1] - dt * uX;
                    bisectorNormalLeft = [x, y];
                } else {
                    dt = t * d1;
                    x = pnt2[0] + dt * uY;
                    y = pnt2[1] - dt * uX;
                    bisectorNormalRight = [x, y];
                    dt = t * d2;
                    x = pnt2[0] - dt * uY;
                    y = pnt2[1] + dt * uX;
                    bisectorNormalLeft = [x, y];
                }
            } else {
                x = pnt2[0] + t * (pnt1[0] - pnt2[0]);
                y = pnt2[1] + t * (pnt1[1] - pnt2[1]);
                bisectorNormalRight = [x, y];
                x = pnt2[0] + t * (pnt3[0] - pnt2[0]);
                y = pnt2[1] + t * (pnt3[1] - pnt2[1]);
                bisectorNormalLeft = [x, y];
            }
            return [bisectorNormalRight, bisectorNormalLeft];
        }
    }, {
        key: "getCubicValue",
        value: function getCubicValue(t, startPnt, cPnt1, cPnt2, endPnt) {
            t = Math.max(Math.min(t, 1), 0);
            var tp = 1 - t,
                t2 = t * t;

            var t3 = t2 * t;
            var tp2 = tp * tp;
            var tp3 = tp2 * tp;
            var x = tp3 * startPnt[0] + 3 * tp2 * t * cPnt1[0] + 3 * tp * t2 * cPnt2[0] + t3 * endPnt[0];
            var y = tp3 * startPnt[1] + 3 * tp2 * t * cPnt1[1] + 3 * tp * t2 * cPnt2[1] + t3 * endPnt[1];
            return [x, y];
        }
    }, {
        key: "getNormal",
        value: function getNormal(pnt1, pnt2, pnt3) {
            var dX1 = pnt1[0] - pnt2[0];
            var dY1 = pnt1[1] - pnt2[1];
            var d1 = Math.sqrt(dX1 * dX1 + dY1 * dY1);
            dX1 /= d1;
            dY1 /= d1;
            var dX2 = pnt3[0] - pnt2[0];
            var dY2 = pnt3[1] - pnt2[1];
            var d2 = Math.sqrt(dX2 * dX2 + dY2 * dY2);
            dX2 /= d2;
            dY2 /= d2;
            var uX = dX1 + dX2;
            var uY = dY1 + dY2;
            return [uX, uY];
        }
    }, {
        key: "getArcPoints",
        value: function getArcPoints(center, radius, startAngle, endAngle) {
            var x = null,
                y = null,
                pnts = [],
                angleDiff = endAngle - startAngle;
            angleDiff = angleDiff < 0 ? angleDiff + Math.PI * 2 : angleDiff;
            for (var i = 0; i <= 100; i++) {
                var angle = startAngle + angleDiff * i / 100;
                x = center[0] + radius * Math.cos(angle);
                y = center[1] + radius * Math.sin(angle);
                pnts.push([x, y]);
            }
            return pnts;
        }
    }, {
        key: "getBaseLength",
        value: function getBaseLength(points) {
            return Math.pow(this.wholeDistance(points), 0.99);
        }
    }, {
        key: "wholeDistance",
        value: function wholeDistance(points) {
            var distance = 0;
            var that = this;
            if (points && Array.isArray(points) && points.length > 0) {
                points.forEach(function (item, index) {
                    if (index < points.length - 1) {
                        distance += that.MathDistance(item, points[index + 1]);
                    }
                });
            }
            return distance;
        }
    }, {
        key: "getArrowHeadPoints",
        value: function getArrowHeadPoints(obj) {
            if (!obj) return [];
            var points = obj.points;
            var tailLeft = obj.tailLeft;
            var tailRight = obj.tailRight;
            var headTailFactor = obj.headTailFactor;
            var neckWidthFactor = obj.neckWidthFactor;
            var neckHeightFactor = obj.neckHeightFactor;
            var headWidthFactor = obj.headWidthFactor;
            var headHeightFactor = obj.headHeightFactor;
            var len = this.getBaseLength(points);
            var headHeight = len * headHeightFactor;
            var headPnt = points[points.length - 1];
            len = this.MathDistance(headPnt, points[points.length - 2]);
            var tailWidth = this.MathDistance(tailLeft, tailRight);
            if (headHeight > tailWidth * headTailFactor) {
                headHeight = tailWidth * headTailFactor;
            }
            var headWidth = headHeight * headWidthFactor;
            var neckWidth = headHeight * neckWidthFactor;
            headHeight = headHeight > len ? len : headHeight;
            var neckHeight = headHeight * neckHeightFactor;
            var headEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
            var neckEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
            var headLeft = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, false);
            var headRight = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, true);
            var neckLeft = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, false);
            var neckRight = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, true);
            return [neckLeft, headLeft, headPnt, headRight, neckRight];
        }
    }, {
        key: "getTailPoints",
        value: function getTailPoints(obj) {
            if (!obj) return;
            var points = obj.points;
            var tailWidthFactor = obj.tailWidthFactor;
            var swallowTailFactor = obj.swallowTailFactor;
            var allLen = this.getBaseLength(points);
            var tailWidth = allLen * tailWidthFactor;
            var tailLeft = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, false);
            var tailRight = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, true);
            var len = tailWidth * swallowTailFactor;
            var swallowTailPnt = this.getThirdPoint(points[1], points[0], 0, len, true);
            return [tailLeft, swallowTailPnt, tailRight];
        }
    }, {
        key: "getArrowBodyPoints",
        value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
            var allLen = this.wholeDistance(points);
            var len = this.getBaseLength(points);
            var tailWidth = len * tailWidthFactor;
            var neckWidth = this.MathDistance(neckLeft, neckRight);
            var widthDif = (tailWidth - neckWidth) / 2;
            var tempLen = 0,
                leftBodyPnts = [],
                rightBodyPnts = [];

            for (var i = 1; i < points.length - 1; i++) {
                var angle = this.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
                tempLen += this.MathDistance(points[i - 1], points[i]);
                var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
                var left = this.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
                var right = this.getThirdPoint(points[i - 1], points[i], angle, w, false);
                leftBodyPnts.push(left);
                rightBodyPnts.push(right);
            }
            return leftBodyPnts.concat(rightBodyPnts);
        }
    }, {
        key: "getAngleOfThreePoints",
        value: function getAngleOfThreePoints(pntA, pntB, pntC) {
            var angle = this.getAzimuth(pntB, pntA) - this.getAzimuth(pntB, pntC);
            return angle < 0 ? angle + Math.PI * 2 : angle;
        }
    }, {
        key: "getQBSplinePoints",
        value: function getQBSplinePoints(points) {
            if (points.length <= 2) {
                return points;
            } else {
                var n = 2,
                    bSplinePoints = [];

                var m = points.length - n - 1;
                bSplinePoints.push(points[0]);
                for (var i = 0; i <= m; i++) {
                    for (var t = 0; t <= 1; t += 0.05) {
                        var x = 0,
                            y = 0;

                        for (var k = 0; k <= n; k++) {
                            var factor = this.getQuadricBSplineFactor(k, t);
                            x += factor * points[i + k][0];
                            y += factor * points[i + k][1];
                        }
                        bSplinePoints.push([x, y]);
                    }
                }
                bSplinePoints.push(points[points.length - 1]);
                return bSplinePoints;
            }
        }
    }, {
        key: "getQuadricBSplineFactor",
        value: function getQuadricBSplineFactor(k, t) {
            var res = 0;
            if (k === 0) {
                res = Math.pow(t - 1, 2) / 2;
            } else if (k === 1) {
                res = (-2 * Math.pow(t, 2) + 2 * t + 1) / 2;
            } else if (k === 2) {
                res = Math.pow(t, 2) / 2;
            }
            return res;
        }
    }, {
        key: "Mid",
        value: function Mid(point1, point2) {
            return [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2];
        }
    }, {
        key: "getCircleCenterOfThreePoints",
        value: function getCircleCenterOfThreePoints(point1, point2, point3) {
            var pntA = [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2];
            var pntB = [pntA[0] - point1[1] + point2[1], pntA[1] + point1[0] - point2[0]];
            var pntC = [(point1[0] + point3[0]) / 2, (point1[1] + point3[1]) / 2];
            var pntD = [pntC[0] - point1[1] + point3[1], pntC[1] + point1[0] - point3[0]];
            return this.getIntersectPoint(pntA, pntB, pntC, pntD);
        }
    }, {
        key: "getIntersectPoint",
        value: function getIntersectPoint(pntA, pntB, pntC, pntD) {
            if (pntA[1] === pntB[1]) {
                var _f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
                var _x = _f * (pntA[1] - pntC[1]) + pntC[0];
                var _y = pntA[1];
                return [_x, _y];
            }
            if (pntC[1] === pntD[1]) {
                var _e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
                var _x2 = _e * (pntC[1] - pntA[1]) + pntA[0];
                var _y2 = pntC[1];
                return [_x2, _y2];
            }
            var e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
            var f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
            var y = (e * pntA[1] - pntA[0] - f * pntC[1] + pntC[0]) / (e - f);
            var x = e * y - e * pntA[1] + pntA[0];
            return [x, y];
        }
    }, {
        key: "getBezierPoints",
        value: function getBezierPoints(points) {
            if (points.length <= 2) {
                return points;
            } else {
                var bezierPoints = [];
                var n = points.length - 1;
                for (var t = 0; t <= 1; t += 0.01) {
                    var x = 0,
                        y = 0;

                    for (var index = 0; index <= n; index++) {
                        var factor = this.getBinomialFactor(n, index);
                        var a = Math.pow(t, index);
                        var b = Math.pow(1 - t, n - index);
                        x += factor * a * b * points[index][0];
                        y += factor * a * b * points[index][1];
                    }
                    bezierPoints.push([x, y]);
                }
                // bezierPoints.push(points[n]);
                return bezierPoints;
            }
        }
    }, {
        key: "getFactorial",
        value: function getFactorial(n) {
            var result = 1;
            switch (n) {
                case n <= 1:
                    result = 1;
                    break;
                case n === 2:
                    result = 2;
                    break;
                case n === 3:
                    result = 6;
                    break;
                case n === 24:
                    result = 24;
                    break;
                case n === 5:
                    result = 120;
                    break;
                default:
                    for (var i = 1; i <= n; i++) {
                        result *= i;
                    }
                    break;
            }
            return result;
        }
    }, {
        key: "getBinomialFactor",
        value: function getBinomialFactor(n, index) {
            return this.getFactorial(n) / (this.getFactorial(index) * this.getFactorial(n - index));
        }
    }]);

    return PlotUtilClass;
}();

//外部使用，单例模式


var plotUtil = exports.plotUtil = new PlotUtilClass();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawPolygonEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(63);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//用于外部扩展使用，绘制的点与显示的点不一致的标号

var DrawPolygonEx = exports.DrawPolygonEx = function (_DrawPolygon) {
    _inherits(DrawPolygonEx, _DrawPolygon);

    function DrawPolygonEx() {
        _classCallCheck(this, DrawPolygonEx);

        return _possibleConstructorReturn(this, (DrawPolygonEx.__proto__ || Object.getPrototypeOf(DrawPolygonEx)).apply(this, arguments));
    }

    _createClass(DrawPolygonEx, [{
        key: "getDrawPosition",
        value: function getDrawPosition() {
            return this._positions_show;
        }
    }, {
        key: "updateAttrForDrawing",
        value: function updateAttrForDrawing() {
            if (this._positions_draw == null || this._positions_draw.length < this._minPointNum) {
                this._positions_show = this._positions_draw;
                return;
            }

            this._positions_show = this.getShowPositions(this._positions_draw, this.entity.attribute);
            _Draw.DrawPolygon.prototype.updateAttrForDrawing.call(this);
        }
        //子类中重写 ，根据标绘绘制的点，生成显示的边界点

    }, {
        key: "getShowPositions",
        value: function getShowPositions(positions, attribute) {
            return positions;
        }
        //图形绘制结束后调用

    }, {
        key: "finish",
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            //抛弃多余的无效绘制点
            if (this._positions_draw.length > this._maxPointNum) this._positions_draw.splice(this._maxPointNum, this._positions_draw.length - this._maxPointNum);

            this.entity._positions_draw = this._positions_draw;
            this.entity._positions_show = this._positions_show;

            entity.polygon.hierarchy = new Cesium.CallbackProperty(function (time) {
                var positions = entity._positions_show;
                return new Cesium.PolygonHierarchy(positions);
            }, false);

            this._positions_draw = null;
            this._positions_show = null;
        }
    }, {
        key: "toGeoJSON",
        value: function toGeoJSON(entity) {
            return this.attrClass.toGeoJSON(entity, true); //不用闭合最后一个点
        }
    }]);

    return DrawPolygonEx;
}(_Draw.DrawPolygon);

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditPolygonEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Edit = __webpack_require__(29);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//用于外部扩展使用，绘制的点与显示的点不一致的标号

var EditPolygonEx = exports.EditPolygonEx = function (_EditPolygon) {
    _inherits(EditPolygonEx, _EditPolygon);

    //========== 构造方法 ========== 
    function EditPolygonEx(entity, viewer) {
        _classCallCheck(this, EditPolygonEx);

        var _this = _possibleConstructorReturn(this, (EditPolygonEx.__proto__ || Object.getPrototypeOf(EditPolygonEx)).call(this, entity, viewer));

        _this._hasMidPoint = false;
        return _this;
    }

    //修改坐标会回调，提高显示的效率


    _createClass(EditPolygonEx, [{
        key: "changePositionsToCallback",
        value: function changePositionsToCallback() {
            this._positions_draw = this.entity._positions_draw;
            this._positions_show = this.entity._positions_show;
        }
        //坐标位置相关  

    }, {
        key: "updateAttrForEditing",
        value: function updateAttrForEditing() {
            if (this._positions_draw == null || this._positions_draw.length < this._minPointNum) {
                this._positions_show = this._positions_draw;
                return;
            }
            this._positions_show = this.getShowPositions(this._positions_draw, this.entity.attribute);

            this.entity._positions_show = this._positions_show;
            _Edit.EditPolygon.prototype.updateAttrForEditing.call(this);
        }
        //子类中重写 ，根据标绘绘制的点，生成显示的边界点

    }, {
        key: "getShowPositions",
        value: function getShowPositions(positions, attribute) {
            return positions;
        }
        //图形编辑结束后调用

    }, {
        key: "finish",
        value: function finish() {
            this.entity._positions_show = this._positions_show;
            this.entity._positions_draw = this._positions_draw;
        }
    }]);

    return EditPolygonEx;
}(_Edit.EditPolygon);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr, textAttr) {
    style = style || {};
    if (entityattr == null) {
        //默认值
        entityattr = {
            scale: 1.0,
            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM
        };
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "font_style": //跳过扩展其他属性的参数
            case "font_weight":
            case "font_size":
            case "font_family":
            case "scaleByDistance_near":
            case "scaleByDistance_nearValue":
            case "scaleByDistance_far":
            case "scaleByDistance_farValue":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
            case "background_opacity":
            case "pixelOffsetY":
                break;

            case "text":
                //文字内容
                if (textAttr) {
                    //存在属性时，采用格式化字符串
                    value = (0, _util.template)(value, textAttr);
                }
                entityattr.text = value.replace(new RegExp("<br />", "gm"), "\n");
                break;
            case "color":
                //颜色
                entityattr.fillColor = Cesium.Color.fromCssColorString(value || "#ffffff").withAlpha(Number(style.opacity || 1.0));
                break;

            case "border":
                //是否衬色
                entityattr.style = value ? Cesium.LabelStyle.FILL_AND_OUTLINE : Cesium.LabelStyle.FILL;
                break;
            case "border_color":
                //衬色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#000000").withAlpha(Number(style.opacity || 1.0));
                break;
            case "border_width":
                entityattr.outlineWidth = value;
                break;
            case "background":
                //是否背景色
                entityattr.showBackground = value;
                break;
            case "background_color":
                //背景色
                entityattr.backgroundColor = Cesium.Color.fromCssColorString(value || "#000000").withAlpha(Number(style.background_opacity || style.opacity || 0.5));
                break;
            case "pixelOffset":
                //偏移量
                if (Cesium.defined(value[0]) && Cesium.defined(value[1])) entityattr.pixelOffset = new Cesium.Cartesian2(value[0], value[1]);else entityattr.pixelOffset = value;
                break;
            case "hasPixelOffset":
                //是否存在偏移量
                if (!value) entityattr.pixelOffset = new Cesium.Cartesian2(0, 0);
                break;
            case "pixelOffsetX":
                //偏移量
                entityattr.pixelOffset = new Cesium.Cartesian2(value, style.pixelOffsetY);
                break;
            case "scaleByDistance":
                //是否按视距缩放
                if (value) {
                    entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(style.scaleByDistance_near || 1000), Number(style.scaleByDistance_nearValue || 1.0), Number(style.scaleByDistance_far || 1000000), Number(style.scaleByDistance_farValue || 0.1));
                } else {
                    entityattr.scaleByDistance = undefined;
                }
                break;
            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;

            case "clampToGround":
                //贴地
                if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
                break;
            case "heightReference":
                switch (value) {
                    case "NONE":
                        entityattr.heightReference = Cesium.HeightReference.NONE;
                        break;
                    case "CLAMP_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                        break;
                    case "RELATIVE_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                        break;
                    default:
                        entityattr.heightReference = value;
                        break;
                }
                break;

            case "visibleDepth":
                if (value) entityattr.disableDepthTestDistance = 0;else entityattr.disableDepthTestDistance = Number.POSITIVE_INFINITY; //一直显示，不被地形等遮挡

                break;

        }
    }

    //样式（倾斜、加粗等）
    var fontStyle = (style.font_style || "normal") + " small-caps " + (style.font_weight || "normal") + " " + (style.font_size || "25") + "px " + (style.font_family || "楷体");
    entityattr.font = fontStyle;

    return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
    return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: { type: "Point", coordinates: coordinates[0] }
    };
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.interPolygon = interPolygon;
exports.getHeightRange = getHeightRange;
exports.computeVolume = computeVolume;
exports.updateVolumeByMinHeight = updateVolumeByMinHeight;
exports.updateVolume = updateVolume;
exports.getEllipseOuterPositions = getEllipseOuterPositions;
exports.getRectangleOuterPositions = getRectangleOuterPositions;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _polyline = __webpack_require__(22);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//面内进行贴地(或贴模型)插值, 返回三角网等计算结果
function interPolygon(opts) {
    var scene = opts.scene;

    //坐标数组
    var positions = [];
    var pos = opts.positions;
    for (var i = 0; i < pos.length; i++) {
        positions.push(pos[i].clone());
    }

    //splitNum分割的个数
    var granularity = (0, _util.getGranularity)(positions, opts.splitNum);

    //插值求面的三角网   
    var arrPoly = [];

    var polygonGeometry = new Cesium.PolygonGeometry.fromPositions({
        positions: positions,
        vertexFormat: Cesium.PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,
        granularity: granularity
    });
    var geom = new Cesium.PolygonGeometry.createGeometry(polygonGeometry);

    var i0, i1, i2;
    var cartesian1, cartesian2, cartesian3;
    for (var i = 0; i < geom.indices.length; i += 3) {
        i0 = geom.indices[i];
        i1 = geom.indices[i + 1];
        i2 = geom.indices[i + 2];

        //三角形 点1
        cartesian1 = new Cesium.Cartesian3(geom.attributes.position.values[i0 * 3], geom.attributes.position.values[i0 * 3 + 1], geom.attributes.position.values[i0 * 3 + 2]);
        arrPoly.push(cartesian1);

        //三角形 点2
        cartesian2 = new Cesium.Cartesian3(geom.attributes.position.values[i1 * 3], geom.attributes.position.values[i1 * 3 + 1], geom.attributes.position.values[i1 * 3 + 2]);
        arrPoly.push(cartesian2);

        //三角形 点3
        cartesian3 = new Cesium.Cartesian3(geom.attributes.position.values[i2 * 3], geom.attributes.position.values[i2 * 3 + 1], geom.attributes.position.values[i2 * 3 + 2]);
        arrPoly.push(cartesian3);
    }

    var maxHeight = 0;
    var minHeight = 9999;
    var onlyPoint = Cesium.defaultValue(opts.onlyPoint, false); //只返回点，不需要三角网时

    //格式化每个点
    function onFormatPoint(position, noHeight) {
        var height;
        var point;
        var pointDM;

        if (noHeight) {
            height = (0, _point.getSurfaceHeight)(scene, position, opts);

            var carto = Cesium.Cartographic.fromCartesian(position);
            point = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
            pointDM = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, height);
        } else {
            var carto = Cesium.Cartographic.fromCartesian(position);
            var height = carto.height;

            point = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
            pointDM = position;
        }

        if (maxHeight < height) maxHeight = height;
        if (minHeight > height) minHeight = height;

        return {
            height: height,
            point: point,
            pointDM: pointDM
        };
    }

    function interCallback(raisedPositions, noHeight) {
        var arrSJW = [];
        var obj1, obj2, obj3;
        for (var i = 0; i < raisedPositions.length; i += 3) {
            //三角形 点1 
            obj1 = onFormatPoint(raisedPositions[i], noHeight);
            //三角形 点2 
            obj2 = onFormatPoint(raisedPositions[i + 1], noHeight);
            //三角形 点3 
            obj3 = onFormatPoint(raisedPositions[i + 2], noHeight);

            if (onlyPoint) {
                //只返回点，不需要三角网
                addPointFoyArrOnly(arrSJW, obj1);
                addPointFoyArrOnly(arrSJW, obj2);
                addPointFoyArrOnly(arrSJW, obj3);
            } else {
                //常规返回，三角网
                arrSJW.push({
                    point1: obj1,
                    point2: obj2,
                    point3: obj3
                });
            }
        }

        if (Cesium.defined(opts.minHeight)) {
            minHeight = Math.max(opts.minHeight, minHeight);
            maxHeight = Math.max(maxHeight, minHeight);
        }

        var result = {
            granularity: granularity,
            maxHeight: maxHeight,
            minHeight: minHeight,
            list: arrSJW //三角网 
        };
        var callback = opts.callback || opts.calback; //兼容不同参数名
        if (callback) callback(result);

        return result;
    }

    //是否异步求精确高度 
    if (opts.asyn) {
        //求高度 
        return (0, _polyline.computeSurfacePoints)({
            scene: scene,
            positions: arrPoly,
            has3dtiles: opts.has3dtiles,
            callback: interCallback
        });
    } else {
        return interCallback(arrPoly, true);
    }
}

//判断坐标点是否在数组内
function addPointFoyArrOnly(arr, newItem) {
    var isIn = false;
    var point = newItem.point;
    for (var z = 0; z < arr.length; z++) {
        var item = arr[z].point;
        if (point.x == item.x && point.y == item.y && point.z == item.z) {
            isIn = true;
            break;
        }
    }
    if (!isIn) arr.push(newItem);
}

//计算面内最大、最小高度值
function getHeightRange(positions, scene) {
    var resultInter = interPolygon({
        positions: positions,
        scene: scene
    });

    return {
        has3dtiles: resultInter._has3dtiles,
        maxHeight: resultInter.maxHeight,
        minHeight: resultInter.minHeight
    };
}

//计算三角形空间面积
function getAreaOfTriangle(pos1, pos2, pos3) {
    var a = Cesium.Cartesian3.distance(pos1, pos2);
    var b = Cesium.Cartesian3.distance(pos2, pos3);
    var c = Cesium.Cartesian3.distance(pos3, pos1);
    var S = (a + b + c) / 2;
    return Math.sqrt(S * (S - a) * (S - b) * (S - c));
}

//体积计算 
function computeVolume(opts) {
    var resultInter = interPolygon(opts);
    if (resultInter) resultInter = updateVolumeByMinHeight(resultInter);

    return resultInter;
}

//根据 最低底面高度 重新计算填挖方体积 
function updateVolumeByMinHeight(resultInter) {
    var minHeight = resultInter.minHeight;

    var totalArea = 0; //总面积(横截面/投影底面)
    var totalVolume = 0; //总体积

    for (var i = 0, len = resultInter.list.length; i < len; i++) {
        var item = resultInter.list[i];

        var pt1 = item.point1;
        var pt2 = item.point2;
        var pt3 = item.point3;

        //横截面面积 
        var bottomArea = getAreaOfTriangle(pt1.point, pt2.point, pt3.point);
        item.area = bottomArea;
        totalArea += bottomArea;

        var height1 = pt1.height;
        var height2 = pt2.height;
        var height3 = pt3.height;
        if (height1 < minHeight) height1 = minHeight;
        if (height2 < minHeight) height2 = minHeight;
        if (height3 < minHeight) height3 = minHeight;

        //挖方体积 （横截面面积 * 3个点的平均高） 
        var cutVolume = bottomArea * (height1 - minHeight + height2 - minHeight + height3 - minHeight) / 3;
        item.cutVolume = cutVolume;
        totalVolume = totalVolume + cutVolume;
    }

    resultInter.totalArea = totalArea; //总面积(横截面/投影底面)
    resultInter.totalVolume = totalVolume; //总体积

    return resultInter;
}

//根据 基准面高度 重新计算填挖方体积 
function updateVolume(resultInter, cutHeight) {
    if (!resultInter) return;

    var minHeight = resultInter.minHeight;
    var totalVolume = resultInter.totalVolume; //总体积

    if (cutHeight <= minHeight) {
        resultInter.fillVolume = 0; //填方体积
        resultInter.digVolume = totalVolume; //挖方体积

        return resultInter;
    }

    var totalV = 0; //底部到基准面的总体积 
    var totalBottomV = 0; //挖方体积
    for (var i = 0, len = resultInter.list.length; i < len; i++) {
        var item = resultInter.list[i];

        //底部到基准面的总体积 
        totalV += item.area * (cutHeight - minHeight);

        var pt1 = item.point1;
        var pt2 = item.point2;
        var pt3 = item.point3;

        var height1 = pt1.height;
        var height2 = pt2.height;
        var height3 = pt3.height;
        if (height1 < cutHeight) height1 = cutHeight;
        if (height2 < cutHeight) height2 = cutHeight;
        if (height3 < cutHeight) height3 = cutHeight;

        //挖方体积 （横截面面积 * 3个点的平均高）  
        totalBottomV += item.area * (height1 - cutHeight + height2 - cutHeight + height3 - cutHeight) / 3;
    }

    resultInter.digVolume = totalBottomV; //挖方体积
    resultInter.fillVolume = totalV - (totalVolume - totalBottomV); //填方体积

    return resultInter;
}

//获取圆（或椭圆）边线上的坐标点数组
function getEllipseOuterPositions(opts) {
    var position = opts.position;
    if (!position) return null;

    var count = Cesium.defaultValue(opts.count, 1); //点的数量，总数为count*4
    var semiMajorAxis = Cesium.defaultValue(opts.semiMajorAxis, opts.radius);
    var semiMinorAxis = Cesium.defaultValue(opts.semiMinorAxis, opts.radius);
    var rotation = Cesium.defaultValue(opts.rotation, 0);

    if (!semiMajorAxis || !semiMinorAxis) return [position, position, position];

    //获取椭圆上的坐标点数组
    var cep = Cesium.EllipseGeometryLibrary.computeEllipsePositions({
        center: position,
        semiMajorAxis: semiMajorAxis, //长半轴
        semiMinorAxis: semiMinorAxis, //短半轴
        rotation: rotation,
        granularity: Math.PI / (16 * count)
    }, true, true);

    var arr = cep.outerPositions;
    var positions = [];
    for (var i = 0, len = arr.length; i < len; i += 3) {
        //长半轴上的坐标点
        var pt = new Cesium.Cartesian3(arr[i], arr[i + 1], arr[i + 2]);
        positions.push(pt);
    }
    return positions;
}

//获取矩形（含旋转角度）的边线上的4个顶点坐标点数组
function getRectangleOuterPositions(options) {
    var rectangle = options.rectangle;
    var rotation = Cesium.defaultValue(options.rotation, 0.0);
    var height = Cesium.defaultValue(options.height, 0.0);

    if (rotation == 0) {
        return [Cesium.Cartesian3.fromRadians(rectangle.west, rectangle.south, height), Cesium.Cartesian3.fromRadians(rectangle.east, rectangle.south, height), Cesium.Cartesian3.fromRadians(rectangle.east, rectangle.north, height), Cesium.Cartesian3.fromRadians(rectangle.west, rectangle.north, height)];
    }

    var granularity = Cesium.defaultValue(options.granularity, Cesium.Math.RADIANS_PER_DEGREE);

    var rectangleScratch = new Cesium.Rectangle();
    var nwScratch = new Cesium.Cartographic();
    var computedOptions = Cesium.RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);

    var w_height = computedOptions.height;
    var w_width = computedOptions.width;
    var ellipsoid = Cesium.defaultValue(options.ellipsoid, Cesium.Ellipsoid.WGS84);

    var scratchRectanglePoints = [new Cesium.Cartesian3(), new Cesium.Cartesian3(), new Cesium.Cartesian3(), new Cesium.Cartesian3()];

    Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, scratchRectanglePoints[0]);
    Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, w_width - 1, scratchRectanglePoints[1]);

    Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, w_height - 1, w_width - 1, scratchRectanglePoints[2]);

    Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, w_height - 1, 0, scratchRectanglePoints[3]);

    if (height != 0) {
        scratchRectanglePoints = (0, _point.setPositionsHeight)(scratchRectanglePoints, height);
    }

    return scratchRectanglePoints;
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PointColor = exports.PointType = exports.PixelSize = undefined;
exports.createDragger = createDragger;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Tooltip = __webpack_require__(7);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//拖拽点控制类
var PixelSize = exports.PixelSize = 12; //编辑点的像素大小

//拖拽点分类
var PointType = exports.PointType = {
    Control: 1, //位置控制
    MoveAll: 2, //整体平移(如线面)
    AddMidPoint: 3, //辅助增加新点
    MoveHeight: 4, //上下移动高度
    EditAttr: 5, //辅助修改属性（如半径）
    EditRotation: 6 //旋转角度修改


    //拖拽点分类
};var PointColor = exports.PointColor = {
    Control: Cesium.Color.fromCssColorString("#1c197d"), //位置控制拖拽点
    MoveAll: Cesium.Color.fromCssColorString("#8c003a"), //整体平移(如线面)拖拽点
    MoveHeight: Cesium.Color.fromCssColorString("#9500eb"), //上下移动高度的拖拽点
    EditAttr: Cesium.Color.fromCssColorString("#f531e8"), //辅助修改属性（如半径）的拖拽点
    AddMidPoint: Cesium.Color.fromCssColorString("#04c2c9").withAlpha(0.3) //增加新点，辅助拖拽点
};

function getAttrForType(type, attr) {
    switch (type) {
        case PointType.AddMidPoint:
            attr.color = PointColor.AddMidPoint;
            attr.outlineColor = Cesium.Color.fromCssColorString("#ffffff").withAlpha(0.4);
            break;
        case PointType.MoveAll:
            attr.color = PointColor.MoveAll;
            break;
        case PointType.MoveHeight:
            attr.color = PointColor.MoveHeight;
            break;
        case PointType.EditAttr:
            attr.color = PointColor.EditAttr;
            break;
        case PointType.Control:
        default:
            attr.color = PointColor.Control;
            break;
    }
    return attr;
}

/** 创建Dragger拖动点的公共方法 */
function createDragger(entityCollection, options) {
    var dragger;
    if (options.dragger) {
        dragger = options.dragger;
    } else {
        var attr = {
            scale: 1,
            pixelSize: PixelSize,
            outlineColor: Cesium.Color.fromCssColorString("#ffffff").withAlpha(0.5),
            outlineWidth: 2,
            scaleByDistance: new Cesium.NearFarScalar(1000, 1, 1000000, 0.5),
            disableDepthTestDistance: Number.POSITIVE_INFINITY //一直显示，不被地形等遮挡
        };
        attr = getAttrForType(options.type, attr);

        dragger = entityCollection.add({
            position: Cesium.defaultValue(options.position, Cesium.Cartesian3.ZERO),
            point: attr,
            draw_tooltip: options.tooltip || _Tooltip.message.dragger.def
        });
        dragger.contextmenuItems = false; //不加右键菜单
    }

    dragger._isDragger = true;
    dragger._noMousePosition = true; //不被getCurrentMousePosition拾取
    dragger._pointType = options.type || PointType.Control; //默认是位置控制拖拽点

    dragger.onDragStart = Cesium.defaultValue(options.onDragStart, null);
    dragger.onDrag = Cesium.defaultValue(options.onDrag, null);
    dragger.onDragEnd = Cesium.defaultValue(options.onDragEnd, null);

    return dragger;
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseLayer = exports.BaseLayer = function (_MarsClass) {
    _inherits(BaseLayer, _MarsClass);

    //========== 构造方法 ========== 
    function BaseLayer(viewer, options) {
        _classCallCheck(this, BaseLayer);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (BaseLayer.__proto__ || Object.getPrototypeOf(BaseLayer)).call(this, options));

        if (options instanceof Cesium.Viewer) {
            var temppar = options;
            options = viewer;
            viewer = temppar;
        }
        if (options.calback) {
            _this.on(_MarsClass2.eventType.load, function (event) {
                options.calback(event.tileset);
            });
        }
        if (options.click) {
            _this.on(_MarsClass2.eventType.click, function (event) {
                options.click(event.sourceTarget, event);
            });
        }
        if (options.mouseover) {
            _this.on(_MarsClass2.eventType.mouseOver, function (event) {
                options.mouseover(event.sourceTarget, event);
            });
        }
        if (options.mouseout) {
            _this.on(_MarsClass2.eventType.mouseOut, function (event) {
                options.mouseout(event.sourceTarget, event);
            });
        }
        _this.config = options;
        _this.getVisible = function () {
            return _this.visible;
        };
        _this.setVisible = function (val) {
            _this.visible = val;
        };
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码


        _this.viewer = viewer;
        _this.options = options; //配置的config信息 

        _this.name = options.name;
        _this.hasZIndex = Cesium.defaultValue(options.hasZIndex, false);
        _this.hasOpacity = Cesium.defaultValue(options.hasOpacity, false);
        _this._opacity = Cesium.defaultValue(options.opacity, 1);
        if (options.hasOwnProperty("alpha")) _this._opacity = Number(options.alpha);

        //单体化时，不可调整透明度 
        if (options.dth) {
            _this.hasOpacity = false;

            options.symbol = options.symbol || {};
            options.symbol.styleOptions = options.symbol.styleOptions || {};
            options.symbol.styleOptions.clampToGround = true;
        }

        _this.create();

        _this._visible = false;
        if (options.visible) {
            if (_this.options.visibleTimeout) {
                setTimeout(function () {
                    _this.visible = true;
                }, _this.options.visibleTimeout);
            } else {
                _this.visible = true;
            }

            if (options.flyTo) {
                _this.centerAt(_this.options.flyToDuration || 0);
            }
        }
        return _this;
    }
    //========== 对外属性 ==========  


    _createClass(BaseLayer, [{
        key: 'create',


        //========== 方法========== 
        value: function create() {
            if (this.options.onCreate) {
                this.options.onCreate(this.viewer);
            }
        }
    }, {
        key: 'showError',
        value: function showError(title, error) {
            if (!error) error = '未知错误';

            if (this.viewer) this.viewer.cesiumWidget.showErrorPanel(title, undefined, error);

            marslog.warn('layer错误:' + title + error);
        }

        //添加 

    }, {
        key: 'add',
        value: function add() {
            this._visible = true;
            this.options.visible = this._visible;

            if (this.options.onAdd) {
                this.options.onAdd(this.viewer);
            }
            this.fire(_MarsClass2.eventType.add);
        }
        //移除

    }, {
        key: 'remove',
        value: function remove() {
            this._visible = false;
            this.options.visible = this._visible;

            if (this.options.onRemove) {
                this.options.onRemove(this.viewer);
            }
            this.fire(_MarsClass2.eventType.remove);
        }
        //定位至数据区域

    }, {
        key: 'centerAt',
        value: function centerAt(duration) {
            if (this.options.extent || this.options.center) {
                this.viewer.mars.centerAt(this.options.extent || this.options.center, { duration: duration, isWgs84: true });
            } else if (this.options.onCenterAt) {
                this.options.onCenterAt(duration, this.viewer);
            }
        }
        //设置透明度

    }, {
        key: 'setOpacity',
        value: function setOpacity(value) {
            if (this.options.onSetOpacity) {
                this.options.onSetOpacity(value, this.viewer);
            }
        }
        //设置叠加顺序

    }, {
        key: 'setZIndex',
        value: function setZIndex(value) {
            if (this.options.onSetZIndex) {
                this.options.onSetZIndex(value, this.viewer);
            }
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.visible = false;
            _get(BaseLayer.prototype.__proto__ || Object.getPrototypeOf(BaseLayer.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'visible',
        get: function get() {
            return this._visible;
        },
        set: function set(val) {
            if (this._visible == val) return;

            this._visible = val;
            this.options.visible = val;

            if (val) {
                if (this.options.msg) (0, _util.msg)(this.options.msg);
                this.add();
            } else {
                this.remove();
            }
        }
    }, {
        key: 'opacity',
        get: function get() {
            return this._opacity;
        },
        set: function set(val) {
            this.setOpacity(val);
        }
    }]);

    return BaseLayer;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


BaseLayer.event = {
    add: _MarsClass2.eventType.add,
    remove: _MarsClass2.eventType.remove,
    load: _MarsClass2.eventType.load,
    click: _MarsClass2.eventType.click,
    mouseOver: _MarsClass2.eventType.mouseOver,
    mouseOut: _MarsClass2.eventType.mouseOut
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawPolyline = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _point = __webpack_require__(2);

var _Tooltip = __webpack_require__(7);

var _Attr = __webpack_require__(19);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(25);

var _Draw = __webpack_require__(44);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPolyline = exports.DrawPolyline = function (_DrawBase) {
    _inherits(DrawPolyline, _DrawBase);

    //========== 构造方法 ========== 
    function DrawPolyline(opts) {
        _classCallCheck(this, DrawPolyline);

        var _this = _possibleConstructorReturn(this, (DrawPolyline.__proto__ || Object.getPrototypeOf(DrawPolyline)).call(this, opts));

        _this.type = 'polyline';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditPolyline; //获取编辑对象

        _this._minPointNum = 2; //至少需要点的个数 
        _this._maxPointNum = 9999; //最多允许点的个数 
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawPolyline, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = [];

            if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
            if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

            if (attribute.config) {
                //允许外部传入
                this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
            } else {
                this._minPointNum = this._minPointNum_def;
                this._maxPointNum = this._maxPointNum_def;
            }

            var that = this;
            var addattr = {
                polyline: attr.style2Entity(attribute.style),
                attribute: attribute
            };
            addattr.polyline.positions = new Cesium.CallbackProperty(function (time) {
                return that.getDrawPosition();
            }, false);

            this.entity = dataSource.entities.add(addattr); //创建要素对象
            this.entity._positions_draw = this._positions_draw;
            return this.entity;
        }
        //重新激活绘制

    }, {
        key: 'reCreateFeature',
        value: function reCreateFeature(entity) {
            if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
            if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

            var attribute = entity.attribute;
            if (attribute.config) {
                //允许外部传入
                this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
            } else {
                this._minPointNum = this._minPointNum_def;
                this._maxPointNum = this._maxPointNum_def;
            }

            this.entity = entity;
            this._positions_draw = entity._positions_draw || entity.polyline.positions.getValue(this.viewer.clock.currentTime);;
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.polyline);
        }
        //绑定鼠标事件

    }, {
        key: 'bindEvent',
        value: function bindEvent() {
            var _this2 = this;

            var lastPointTemporary = false;
            this.getHandler().setInputAction(function (event) {
                //单击添加点
                var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.position, _this2.entity);
                if (!point && lastPointTemporary) {
                    //如果未拾取到点，并且存在MOUSE_MOVE时，取最后一个move的点
                    point = _this2._positions_draw[_this2._positions_draw.length - 1];
                }

                if (point) {
                    if (lastPointTemporary) {
                        _this2._positions_draw.pop();
                    }
                    lastPointTemporary = false;

                    //消除双击带来的多余经纬度 
                    if (_this2._positions_draw.length > 1) {
                        var mpt1 = _this2._positions_draw[_this2._positions_draw.length - 1];
                        if (Math.abs(mpt1.x - point.x) < 0.01 && Math.abs(mpt1.y - point.y) < 0.01 && Math.abs(mpt1.z - point.z) < 0.01) _this2._positions_draw.pop();
                    }

                    //在绘制点基础自动增加高度
                    if (_this2.entity.attribute && _this2.entity.attribute.config && _this2.entity.attribute.config.addHeight) point = (0, _point.addPositionsHeight)(point, _this2.entity.attribute.config.addHeight);

                    _this2._positions_draw.push(point);
                    _this2.updateAttrForDrawing();

                    _this2.fire(_MarsClass.eventType.drawAddPoint, { drawtype: _this2.type, entity: _this2.entity, position: point, positions: _this2._positions_draw });

                    if (_this2._positions_draw.length >= _this2._maxPointNum) {
                        //点数满足最大数量，自动结束
                        _this2.disable();
                    }
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

            this.getHandler().setInputAction(function (event) {
                //右击删除上一个点
                _this2._positions_draw.pop(); //删除最后标的一个点

                var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.position, _this2.entity);
                if (point) {
                    if (lastPointTemporary) {
                        _this2._positions_draw.pop();
                    }
                    lastPointTemporary = true;

                    _this2.fire(_MarsClass.eventType.drawRemovePoint, { drawtype: _this2.type, entity: _this2.entity, position: point, positions: _this2._positions_draw });

                    _this2._positions_draw.push(point);
                    _this2.updateAttrForDrawing();
                }
            }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

            this.getHandler().setInputAction(function (event) {
                //鼠标移动

                if (_this2._positions_draw.length <= 1) _this2.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.start);else if (_this2._positions_draw.length < _this2._minPointNum) //点数不满足最少数量
                    _this2.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.cont);else if (_this2._positions_draw.length >= _this2._maxPointNum) //点数满足最大数量
                    _this2.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.end2);else _this2.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.end);

                var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.endPosition, _this2.entity);
                if (point) {
                    if (lastPointTemporary) {
                        _this2._positions_draw.pop();
                    }
                    lastPointTemporary = true;

                    _this2._positions_draw.push(point);
                    _this2.updateAttrForDrawing();

                    _this2.fire(_MarsClass.eventType.drawMouseMove, { drawtype: _this2.type, entity: _this2.entity, position: point, positions: _this2._positions_draw });
                }
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

            this.getHandler().setInputAction(function (event) {
                //双击结束标绘 
                //消除双击带来的多余经纬度 
                if (_this2._positions_draw.length > 1) {
                    var mpt1 = _this2._positions_draw[_this2._positions_draw.length - 1];
                    var mpt2 = _this2._positions_draw[_this2._positions_draw.length - 2];
                    if (Math.abs(mpt1.x - mpt2.x) < 0.01 && Math.abs(mpt1.y - mpt2.y) < 0.01 && Math.abs(mpt1.z - mpt2.z) < 0.01) _this2._positions_draw.pop();
                }

                _this2.endDraw();
            }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
        }
        //外部控制，完成绘制，比如手机端无法双击结束

    }, {
        key: 'endDraw',
        value: function endDraw() {
            if (!this._enabled) {
                return this;
            }

            if (this._positions_draw.length < this._minPointNum) return; //点数不够
            this.updateAttrForDrawing();
            this.disable();
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing(isLoad) {}
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this.getDrawPosition();
            // entity.polyline.positions = new Cesium.CallbackProperty((time)=> {
            //     return entity._positions_draw;
            // }, false);

            //显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示
            if (Cesium.defined(entity.polyline.depthFailMaterial)) {
                entity.polyline.positions = entity._positions_draw;
            } else {
                entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                    return entity._positions_draw;
                }, false);
            }
        }
    }]);

    return DrawPolyline;
}(_Draw.DrawBase);

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHeadingPitchRollByOrientation = getHeadingPitchRollByOrientation;
exports.getHeadingPitchRollByMatrix = getHeadingPitchRollByMatrix;
exports.getHeadingPitchRollByMatrixOld = getHeadingPitchRollByMatrixOld;
exports.getHeadingPitchRollForLine = getHeadingPitchRollForLine;
exports.getRotateCenterPoint = getRotateCenterPoint;
exports.getOnLinePointByLen = getOnLinePointByLen;
exports.getPositionTranslation = getPositionTranslation;
exports.getOffsetLine = getOffsetLine;
exports.getPositionByDirectionAndLen = getPositionByDirectionAndLen;
exports.getPositionByHprAndLen = getPositionByHprAndLen;
exports.getRayEarthPosition = getRayEarthPosition;
exports.getRayEarthPositionByMatrix = getRayEarthPositionByMatrix;
exports.extend2Earth = extend2Earth;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var matrix3Scratch = new Cesium.Matrix3(); //一些涉及矩阵计算的方法

var matrix4Scratch = new Cesium.Matrix4();

// 根据模型的orientation求方位角
function getHeadingPitchRollByOrientation(position, orientation, ellipsoid, fixedFrameTransform) {
    if (!Cesium.defined(orientation) || !Cesium.defined(position)) return new Cesium.HeadingPitchRoll();

    var matrix = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, matrix3Scratch), position, matrix4Scratch);
    var hpr = getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform);
    return hpr;
}

// 根据模型的matrix矩阵求方位角 
function getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform, result) {
    return Cesium.Transforms.fixedFrameToHeadingPitchRoll(matrix, ellipsoid, fixedFrameTransform, result);
}

// 根据模型的matrix矩阵求方位角 
function getHeadingPitchRollByMatrixOld(position, matrix, ellipsoid, fixedFrameTransform) {
    fixedFrameTransform = fixedFrameTransform || Cesium.Transforms.eastNorthUpToFixedFrame;

    // 计算当前模型中心处的变换矩阵
    var m1 = fixedFrameTransform(position, ellipsoid, new Cesium.Matrix4());
    // 矩阵相除
    var m3 = Cesium.Matrix4.multiply(Cesium.Matrix4.inverse(m1, new Cesium.Matrix4()), matrix, new Cesium.Matrix4());
    // 得到旋转矩阵
    var mat3 = Cesium.Matrix4.getMatrix3(m3, new Cesium.Matrix3());
    // 计算四元数
    var q = Cesium.Quaternion.fromRotationMatrix(mat3);
    // 计算旋转角(弧度)
    var hpr = Cesium.HeadingPitchRoll.fromQuaternion(q);
    return hpr;
}

var cartesian3 = new Cesium.Cartesian3();
var matrix4Scratch2 = new Cesium.Matrix4();
var rotationScratch = new Cesium.Matrix3();

//求localStart点到localEnd点的方向
function getHeadingPitchRollForLine(localStart, localEnd, ellipsoid, fixedFrameTransform) {
    ellipsoid = ellipsoid || Cesium.Ellipsoid.WGS84;

    var velocity = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(localEnd, localStart, cartesian3), cartesian3);
    Cesium.Transforms.rotationMatrixFromPositionVelocity(localStart, velocity, ellipsoid, rotationScratch);
    var modelMatrix = Cesium.Matrix4.fromRotationTranslation(rotationScratch, localStart, matrix4Scratch2);

    Cesium.Matrix4.multiplyTransformation(modelMatrix, Cesium.Axis.Z_UP_TO_X_UP, modelMatrix);

    var hpr = getHeadingPitchRollByMatrix(modelMatrix, ellipsoid, fixedFrameTransform);
    return hpr;
}

//获取点point1绕点center的地面法向量旋转顺时针angle角度后新坐标
function getRotateCenterPoint(center, point1, angle) {
    // 计算center的地面法向量
    var chicB = Cesium.Cartographic.fromCartesian(center);
    chicB.height = 0;
    var dB = Cesium.Cartographic.toCartesian(chicB);
    var normaB = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(dB, center, new Cesium.Cartesian3()), new Cesium.Cartesian3());

    // 构造基于center的法向量旋转90度的矩阵
    var Q = Cesium.Quaternion.fromAxisAngle(normaB, Cesium.Math.toRadians(angle));
    var m3 = Cesium.Matrix3.fromQuaternion(Q);
    var m4 = Cesium.Matrix4.fromRotationTranslation(m3);

    // 计算point1点相对center点的坐标A1
    var A1 = Cesium.Cartesian3.subtract(point1, center, new Cesium.Cartesian3());

    //对A1应用旋转矩阵
    var p = Cesium.Matrix4.multiplyByPoint(m4, A1, new Cesium.Cartesian3());
    // 新点的坐标
    var pointNew = Cesium.Cartesian3.add(p, center, new Cesium.Cartesian3());

    return pointNew;
}

//求p1指向p2方向线上，距离p1指定len长度的新的点 ，addBS：true时为距离p2
function getOnLinePointByLen(p1, p2, len, addBS) {
    var mtx4 = Cesium.Transforms.eastNorthUpToFixedFrame(p1);
    var mtx4_inverser = Cesium.Matrix4.inverse(mtx4, new Cesium.Matrix4());
    p1 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p1, new Cesium.Cartesian3());
    p2 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p2, new Cesium.Cartesian3());

    var substrct = Cesium.Cartesian3.subtract(p2, p1, new Cesium.Cartesian3());

    var dis = Cesium.Cartesian3.distance(p1, p2);
    var scale = len / dis; //求比例
    if (addBS) scale += 1;

    var newP = Cesium.Cartesian3.multiplyByScalar(substrct, scale, new Cesium.Cartesian3());
    newP = Cesium.Matrix4.multiplyByPoint(mtx4, newP, new Cesium.Cartesian3());
    return newP;
}

//获取点的offest平移矩阵后点
function getPositionTranslation(position, offest, degree, type, fixedFrameTransform) {
    fixedFrameTransform = fixedFrameTransform || Cesium.Transforms.eastNorthUpToFixedFrame;

    var rotate = Cesium.Math.toRadians(-Cesium.defaultValue(degree, 0)); //转成弧度

    type = (type || "z").toUpperCase();
    var _normal = Cesium.Cartesian3["UNIT_" + type];

    var quaternion = Cesium.Quaternion.fromAxisAngle(_normal, rotate); //quaternion为围绕这个z轴旋转d度的四元数
    var rotateMatrix3 = Cesium.Matrix3.fromQuaternion(quaternion); //rotateMatrix3为根据四元数求得的旋转矩阵

    var pointCartesian3 = new Cesium.Cartesian3(Cesium.defaultValue(offest.x, 0), Cesium.defaultValue(offest.y, 0), Cesium.defaultValue(offest.z, 0)); //point的局部坐标
    var rotateTranslationMatrix4 = Cesium.Matrix4.fromRotationTranslation(rotateMatrix3, Cesium.Cartesian3.ZERO); //rotateTranslationMatrix4为旋转加平移的4x4变换矩阵，这里平移为(0,0,0)，故填个Cesium.Cartesian3.ZERO
    Cesium.Matrix4.multiplyByTranslation(rotateTranslationMatrix4, pointCartesian3, rotateTranslationMatrix4); //rotateTranslationMatrix4 = rotateTranslationMatrix4  X  pointCartesian3
    var originPositionCartesian3 = Cesium.Ellipsoid.WGS84.cartographicToCartesian(Cesium.Cartographic.fromCartesian(position)); //得到局部坐标原点的全局坐标
    var originPositionTransform = fixedFrameTransform(originPositionCartesian3); //m1为局部坐标的z轴垂直于地表，局部坐标的y轴指向正北的4x4变换矩阵
    Cesium.Matrix4.multiplyTransformation(originPositionTransform, rotateTranslationMatrix4, rotateTranslationMatrix4); //rotateTranslationMatrix4 = rotateTranslationMatrix4 X originPositionTransform
    var pointCartesian = new Cesium.Cartesian3();
    Cesium.Matrix4.getTranslation(rotateTranslationMatrix4, pointCartesian); //根据最终变换矩阵m得到p2
    return pointCartesian;
}

//计算平行线，offset正负决定方向（单位米）
function getOffsetLine(positions, offset) {
    var arrNew = [];
    for (var i = 1; i < positions.length; i++) {
        var point1 = positions[i - 1];
        var point2 = positions[i];

        var dir12 = Cesium.Cartesian3.subtract(point1, point2, new Cesium.Cartesian3());
        var dir21left = Cesium.Cartesian3.cross(point1, dir12, new Cesium.Cartesian3());

        var p1offset = computedOffsetData(point1, dir21left, offset * 1000);
        var p2offset = computedOffsetData(point2, dir21left, offset * 1000);

        if (i == 1) {
            arrNew.push(p1offset);
        }
        arrNew.push(p2offset);
    }
    return arrNew;
}

function computedOffsetData(ori, dir, wid) {
    var currRay = new Cesium.Ray(ori, dir);
    return Cesium.Ray.getPoint(currRay, wid, new Cesium.Cartesian3());
}

/**
* 根据 距离方向 和 观察点 计算 目标点
* @param {Object} viewPoint 观察点
* @param {Object} direction 方向(正北方向为0)
* @param {Object} radius 可视距离
*/
function getPositionByDirectionAndLen(position, angle, radius) {
    var matrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);

    //旋转
    var mz = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(angle || 0));
    var rotationZ = Cesium.Matrix4.fromRotationTranslation(mz);
    Cesium.Matrix4.multiply(matrix, rotationZ, matrix);

    var result = Cesium.Matrix4.multiplyByPoint(matrix, new Cesium.Cartesian3(0, radius, 0), new Cesium.Cartesian3());
    return result;
}

/**
* 求某位置指定方向和距离的点
* @param {Object} viewPoint 观察点
* @param {Object} direction 方向
* @param {Object} radius 可视距离
*/
function getPositionByHprAndLen(position, hpr, radiusZ) {
    var orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
    var matrix = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, matrix3Scratch), position, matrix4Scratch);
    var result = Cesium.Matrix4.multiplyByPoint(matrix, new Cesium.Cartesian3(0, 0, -radiusZ), new Cesium.Cartesian3());
    return result;
}

var scratchWC = new Cesium.Cartesian3();
var scratchRay = new Cesium.Ray();
var scratchCartographic2 = new Cesium.Cartographic();

// var matrix3Scratch = new Cesium.Matrix3();
// var matrix4Scratch = new Cesium.Matrix4();


//求点按orientation方向射向地球与地球的交点
function getRayEarthPosition(position, orientation, _reverse, ellipsoid) {
    if (orientation instanceof Cesium.HeadingPitchRoll) {
        orientation = Cesium.Transforms.headingPitchRollQuaternion(position, orientation);
    }

    var matrix = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, matrix3Scratch), position, matrix4Scratch);
    return getRayEarthPositionByMatrix(matrix, _reverse, ellipsoid);
}

//求矩阵射向地球与地球的交点
function getRayEarthPositionByMatrix(_matrix, _reverse, ellipsoid) {
    Cesium.Matrix4.multiplyByPoint(_matrix, Cesium.Cartesian3.ZERO, scratchWC);
    scratchWC.clone(scratchRay.origin);

    var bottomCenter = new Cesium.Cartesian3(0, 0, _reverse ? -100 : 100);
    var groundPosition = extend2Earth(bottomCenter, _matrix, scratchRay, ellipsoid);
    return groundPosition;
}

//求地球交点
function extend2Earth(positionLC, matrix, ray, ellipsoid) {
    ellipsoid = ellipsoid ? ellipsoid : Cesium.Ellipsoid.WGS84;

    Cesium.Matrix4.multiplyByPoint(matrix, positionLC, scratchWC);

    //取延长线与地球相交的点
    Cesium.Cartesian3.subtract(scratchWC, ray.origin, ray.direction);
    Cesium.Cartesian3.normalize(ray.direction, ray.direction);

    //Get the first intersection point of a ray and an ellipsoid.
    var intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);
    var point = null;
    if (intersection) {
        point = Cesium.Ray.getPoint(ray, intersection.start);
    }
    if (point) {
        try {
            Cesium.Cartographic.fromCartesian(point, null, scratchCartographic2);
        } catch (e) {
            return null;
        }
    }
    return point;
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setFillMaterial = setFillMaterial;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _LineFlowMaterial = __webpack_require__(39);

var _CircleWaveMaterial = __webpack_require__(50);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function setFillMaterial(entityattr, style) {
    if (style.material) {
        //material属性优先
        entityattr.material = style.material;
        return entityattr;
    }

    if (style.color || style.fillType) {
        var color = Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));

        switch (style.fillType) {
            default:
            case "color":
                //纯色填充 
                entityattr.material = color;
                break;
            case "image":
                //图片填充  
                var repeat = Cesium.defaultValue(style.image_repeat, 1);
                entityattr.material = new Cesium.ImageMaterialProperty({
                    image: style.image,
                    color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
                    transparent: style.transparent, //是否png透明
                    repeat: new Cesium.Cartesian2(repeat, repeat)
                });
                break;
            case "grid":
                //网格
                var lineCount = Cesium.defaultValue(style.grid_lineCount, 8);
                var lineThickness = Cesium.defaultValue(style.grid_lineThickness, 2.0);
                entityattr.material = new Cesium.GridMaterialProperty({
                    color: color,
                    cellAlpha: Cesium.defaultValue(style.grid_cellAlpha, 0.1),
                    lineCount: new Cesium.Cartesian2(lineCount, lineCount),
                    lineThickness: new Cesium.Cartesian2(lineThickness, lineThickness)
                });
                break;
            case "checkerboard":
                //棋盘 
                var repeat = Cesium.defaultValue(style.checkerboard_repeat, 4);
                entityattr.material = new Cesium.CheckerboardMaterialProperty({
                    evenColor: color,
                    oddColor: Cesium.Color.fromCssColorString(style.checkerboard_oddcolor || "#ffffff").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
                    repeat: new Cesium.Cartesian2(repeat, repeat)
                });
                break;
            case "stripe":
                // 条纹 
                entityattr.material = new Cesium.StripeMaterialProperty({
                    evenColor: color,
                    oddColor: Cesium.Color.fromCssColorString(style.stripe_oddcolor || "#ffffff").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
                    repeat: Cesium.defaultValue(style.stripe_repeat, 6)
                });
                break;
            case "animationLine":
                //流动线 
                entityattr.material = new _LineFlowMaterial.LineFlowMaterial({ //动画线材质
                    color: color,
                    duration: Cesium.defaultValue(style.animationDuration, 2000), //时长，控制速度
                    url: style.animationImage, //图片
                    repeat: new Cesium.Cartesian2(style.animationRepeatX || 1, style.animationRepeatY || 1),
                    axisY: style.animationAxisY,
                    bgUrl: style.bgUrl,
                    bgColor: style.bgColor ? Cesium.Color.fromCssColorString(style.bgColor) : null
                });
                break;
            case "animationCircle":
                //动态圆 
                entityattr.material = new _CircleWaveMaterial.CircleWaveMaterial({
                    duration: Cesium.defaultValue(style.animationDuration, 2000), //时长，控制速度
                    color: Cesium.Color.fromCssColorString(style.color || "#FFFF00").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
                    gradient: Cesium.defaultValue(style.animationGradient, 0),
                    count: Cesium.defaultValue(style.animationCount, 1)
                });
                break;
        }
    }

    //如果未设置任何material，默认设置随机颜色
    if (entityattr.material == null || style.randomColor) {
        entityattr.material = Cesium.Color.fromRandom({
            minimumRed: Cesium.defaultValue(style.minimumRed, 0.0),
            maximumRed: Cesium.defaultValue(style.maximumRed, 0.75),
            minimumGreen: Cesium.defaultValue(style.minimumGreen, 0.0),
            maximumGreen: Cesium.defaultValue(style.maximumGreen, 0.75),
            minimumBlue: Cesium.defaultValue(style.minimumBlue, 0.0),
            maximumBlue: Cesium.defaultValue(style.maximumBlue, 0.75),
            alpha: Cesium.defaultValue(style.opacity, 1.0)
        });
    }

    return entityattr;
} //通用处理方法

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;
exports.line2curve = line2curve;
exports.line2curve2 = line2curve2;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _LineFlowMaterial = __webpack_require__(39);

var _turf = __webpack_require__(33);

var _PlotUtil = __webpack_require__(9);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值
        entityattr = {};
    }

    if (style.clampToGround) {
        entityattr.arcType = Cesium.ArcType.GEODESIC;
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "lineType": //跳过扩展其他属性的参数
            case "color":
            case "opacity":
            case "outline":
            case "outlineWidth":
            case "outlineColor":
            case "outlineOpacity":
            case "flowDuration":
            case "flowImage":
            case "dashLength":
            case "glowPower":
            case "grid_lineCount":
            case "grid_lineThickness":
            case "grid_cellAlpha":
            case "checkerboard_repeat":
            case "checkerboard_oddcolor":
            case "stripe_oddcolor":
            case "stripe_repeat":
            case "animationDuration":
            case "animationImage":
            case "animationRepeatX":
            case "animationRepeatY":
            case "animationAxisY":
            case "animationGradient":
            case "animationCount":
            case "randomColor":
            case "depthFailColor":
            case "depthFailOpacity":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "depthFail":
                if (value) {
                    entityattr.depthFailMaterial = Cesium.Color.fromCssColorString(style.depthFailColor || "#FFFF00").withAlpha(Number(Cesium.defaultValue(style.depthFailOpacity, Cesium.defaultValue(style.opacity, 0.9))));
                    if (style.opacity == 1.0) style.opacity = 0.9; //不透明时，竟然不显示depthFailMaterial？！
                } else {
                    entityattr.depthFailMaterial = undefined;
                }
                break;
            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;
        }
    }

    if (style.color || style.lineType) {
        var color;
        if (style.color) {
            color = Cesium.Color.fromCssColorString(style.color).withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));
        } else if (style.randomColor) {
            color = Cesium.Color.fromRandom({
                minimumRed: Cesium.defaultValue(style.minimumRed, 0.0),
                maximumRed: Cesium.defaultValue(style.maximumRed, 0.75),
                minimumGreen: Cesium.defaultValue(style.minimumGreen, 0.0),
                maximumGreen: Cesium.defaultValue(style.maximumGreen, 0.75),
                minimumBlue: Cesium.defaultValue(style.minimumBlue, 0.0),
                maximumBlue: Cesium.defaultValue(style.maximumBlue, 0.75),
                alpha: Cesium.defaultValue(style.opacity, 1.0)
            });
        } else {
            color = Cesium.Color.fromCssColorString("#FFFF00").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));
        }

        switch (style.lineType) {
            default:
            case "solid":
                //实线 
                if (style.outline) {
                    //存在衬色时
                    entityattr.material = new Cesium.PolylineOutlineMaterialProperty({
                        color: color,
                        outlineWidth: Number(style.outlineWidth || 1.0),
                        outlineColor: Cesium.Color.fromCssColorString(style.outlineColor || "#FFFF00").withAlpha(Number(style.outlineOpacity || style.opacity || 1.0))
                    });
                } else {
                    entityattr.material = color;
                }
                break;
            case "dash":
                //虚线
                if (style.outline) {
                    //存在衬色时
                    entityattr.material = new Cesium.PolylineDashMaterialProperty({
                        dashLength: style.dashLength || style.outlineWidth || 16.0,
                        color: color,
                        gapColor: Cesium.Color.fromCssColorString(style.outlineColor || "#FFFF00").withAlpha(Number(style.outlineOpacity || style.opacity || 1.0))
                    });
                } else {
                    entityattr.material = new Cesium.PolylineDashMaterialProperty({
                        dashLength: style.dashLength || 16.0,
                        color: color
                    });
                }

                break;
            case "glow":
                //发光线
                entityattr.material = new Cesium.PolylineGlowMaterialProperty({
                    glowPower: style.glowPower || 0.1,
                    color: color
                });
                break;
            case "arrow":
                //箭头线
                entityattr.material = new Cesium.PolylineArrowMaterialProperty(color);
                break;
            case "animation":
                //流动线 
                var repeatX = Cesium.defaultValue(style.animationRepeatX, 1);
                var repeatY = Cesium.defaultValue(style.animationRepeatY, 1);
                entityattr.material = new _LineFlowMaterial.LineFlowMaterial({ //动画线材质
                    color: color,
                    duration: style.animationDuration || 2000, //时长，控制速度
                    url: style.animationImage, //图片
                    repeat: new Cesium.Cartesian2(repeatX, repeatY)
                });
                break;
        }
    }

    //材质优先
    if (style.material) entityattr.material = style.material;

    return entityattr;
}

//获取entity的坐标
function getPositions(entity, isShowPositions) {
    if (!isShowPositions && entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw; //曲线等情形时，取绑定的数据

    return entity.polyline.positions.getValue((0, _util.currentTime)());
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity, coordinates) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: {
            type: "LineString",
            coordinates: coordinates
        }
    };
}

//折线转曲线[基于bezierSpline算法]
function line2curve(_positions_draw, closure) {
    var coordinates = _positions_draw.map(function (position) {
        return pointconvert.cartesian2lonlat(position);
    });
    if (closure) //闭合曲线
        coordinates.push(coordinates[0]);
    var defHeight = coordinates[coordinates.length - 1][2];

    var curved = (0, _turf.bezierSpline)({
        type: "Feature",
        geometry: {
            type: "LineString",
            coordinates: coordinates
        }
    });
    var _positions_show = pointconvert.lonlats2cartesians(curved.geometry.coordinates, defHeight);
    return _positions_show;
}

//折线转曲线[基于自己的算法]
function line2curve2(_positions_draw, closure) {
    var points = pointconvert.cartesians2mercators(_positions_draw);
    if (closure) //闭合曲线
        points.push(points[0]);

    var pointsNew = _PlotUtil.plotUtil.getBezierPoints(points);
    var _positions_show = pointconvert.mercators2cartesians(pointsNew);
    return _positions_show;
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defConfigStyle = exports.box = exports.plane = exports.corridor = exports.ellipsoid = exports.rectangle = exports.cylinder = exports.ellipse = exports.circle = exports.polygon = exports.wall = exports.polylineVolume = exports.polyline = exports.model = exports.point = exports.label = exports.billboard = undefined;
exports.getTypeName = getTypeName;
exports.getCoordinates = getCoordinates;
exports.getPositions = getPositions;
exports.getCenterPosition = getCenterPosition;
exports.toGeoJSON = toGeoJSON;
exports.style2Entity = style2Entity;
exports.removeGeoJsonDefVal = removeGeoJsonDefVal;
exports.addGeoJsonDefVal = addGeoJsonDefVal;
exports.getDefStyle = getDefStyle;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

var _Attr = __webpack_require__(34);

var billboard = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(12);

var label = _interopRequireWildcard(_Attr2);

var _Attr3 = __webpack_require__(35);

var point = _interopRequireWildcard(_Attr3);

var _Attr4 = __webpack_require__(31);

var model = _interopRequireWildcard(_Attr4);

var _Attr5 = __webpack_require__(49);

var plane = _interopRequireWildcard(_Attr5);

var _Attr6 = __webpack_require__(51);

var box = _interopRequireWildcard(_Attr6);

var _Attr7 = __webpack_require__(19);

var polyline = _interopRequireWildcard(_Attr7);

var _Attr8 = __webpack_require__(52);

var polylineVolume = _interopRequireWildcard(_Attr8);

var _Attr9 = __webpack_require__(53);

var wall = _interopRequireWildcard(_Attr9);

var _Attr10 = __webpack_require__(54);

var corridor = _interopRequireWildcard(_Attr10);

var _Attr11 = __webpack_require__(21);

var polygon = _interopRequireWildcard(_Attr11);

var _Attr12 = __webpack_require__(40);

var circle = _interopRequireWildcard(_Attr12);

var _Attr13 = __webpack_require__(56);

var cylinder = _interopRequireWildcard(_Attr13);

var _Attr14 = __webpack_require__(57);

var rectangle = _interopRequireWildcard(_Attr14);

var _Attr15 = __webpack_require__(58);

var ellipsoid = _interopRequireWildcard(_Attr15);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var ellipse = circle;

exports.billboard = billboard;
exports.label = label;
exports.point = point;
exports.model = model;
exports.polyline = polyline;
exports.polylineVolume = polylineVolume;
exports.wall = wall;
exports.polygon = polygon;
exports.circle = circle;
exports.ellipse = ellipse;
exports.cylinder = cylinder;
exports.rectangle = rectangle;
exports.ellipsoid = ellipsoid;
exports.corridor = corridor;
exports.plane = plane;
exports.box = box;
function getTypeName(entity) {
    if (entity.polygon) return "polygon";
    if (entity.rectangle) return "rectangle";

    if (entity.polyline) return "polyline";
    if (entity.polylineVolume) return "polylineVolume";
    if (entity.corridor) return "corridor";
    if (entity.wall) return "wall";

    if (entity.ellipse) return "circle";
    if (entity.ellipsoid) return "ellipsoid";
    if (entity.cylinder) return "cylinder";
    if (entity.plane) return "plane";
    if (entity.box) return "box";

    if (entity.billboard) return "billboard";
    if (entity.point) return "point";
    if (entity.model) return "model";
    if (entity.label) return "label";

    return "";
}

function defNullFun(entity) {
    return null;
}

function getAttrClass(entity) {
    if (entity.polygon) return polygon;
    if (entity.rectangle) return rectangle;

    if (entity.polyline) return polyline;
    if (entity.polylineVolume) return polylineVolume;
    if (entity.corridor) return corridor;
    if (entity.wall) return wall;

    if (entity.ellipse) return circle;
    if (entity.cylinder) return cylinder;
    if (entity.ellipsoid) return ellipsoid;
    if (entity.plane) return plane;
    if (entity.box) return box;

    if (entity.point) return point;
    if (entity.billboard) return billboard;
    if (entity.model) return model;
    if (entity.label) return label;

    return {
        getCoordinates: defNullFun,
        getPositions: defNullFun,
        toGeoJSON: defNullFun,
        style2Entity: defNullFun
    };
}

function getCoordinates(entity) {
    return getAttrClass(entity).getCoordinates(entity);
}

function getPositions(entity) {
    return getAttrClass(entity).getPositions(entity);
}

function getCenterPosition(entity) {
    var position;
    if (entity.position) {
        //存在position属性时，直接取
        position = (0, _point.getPositionValue)(entity.position);
        if (position) return position;
    }

    var pots = getPositions(entity);
    if (!pots || pots.length == 0) return null;
    if (pots.length == 1) return pots[0];

    if (entity.polygon) position = (0, _point.centerOfMass)(pots);else position = pots[Math.floor(pots.length / 2)];
    return position;
}

function toGeoJSON(entity) {
    return getAttrClass(entity).toGeoJSON(entity);
}

function style2Entity(style, entity) {
    return getAttrClass(entity).style2Entity(style, entity);
}

//从plot的 标号默认值F12打印 拷贝，方便读取 
var defConfigStyle = exports.defConfigStyle = { "label": { "text": "文字", "color": "#ffffff", "opacity": 1, "font_family": "楷体", "font_size": 30, "border": true, "border_color": "#000000", "border_width": 3, "background": false, "background_color": "#000000", "background_opacity": 0.5, "font_weight": "normal", "font_style": "normal", "scaleByDistance": false, "scaleByDistance_far": 1000000, "scaleByDistance_farValue": 0.1, "scaleByDistance_near": 1000, "scaleByDistance_nearValue": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "clampToGround": false, "visibleDepth": true }, "point": { "pixelSize": 10, "color": "#3388ff", "opacity": 1, "outline": true, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "outlineWidth": 2, "scaleByDistance": false, "scaleByDistance_far": 1000000, "scaleByDistance_farValue": 0.1, "scaleByDistance_near": 1000, "scaleByDistance_nearValue": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 10000, "distanceDisplayCondition_near": 0, "clampToGround": false, "visibleDepth": true }, "billboard": { "opacity": 1, "scale": 1, "rotation": 0, "horizontalOrigin": "CENTER", "verticalOrigin": "BOTTOM", "scaleByDistance": false, "scaleByDistance_far": 1000000, "scaleByDistance_farValue": 0.1, "scaleByDistance_near": 1000, "scaleByDistance_nearValue": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 10000, "distanceDisplayCondition_near": 0, "clampToGround": false, "visibleDepth": true }, "font-point": { "iconClass": "fa fa-automobile", "iconSize": 50, "color": "#00ffff", "opacity": 1, "horizontalOrigin": "CENTER", "verticalOrigin": "CENTER", "rotation": 0, "scaleByDistance": false, "scaleByDistance_far": 1000000, "scaleByDistance_farValue": 0.1, "scaleByDistance_near": 1000, "scaleByDistance_nearValue": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 10000, "distanceDisplayCondition_near": 0, "clampToGround": false, "visibleDepth": true }, "model": { "scale": 1, "heading": 0, "pitch": 0, "roll": 0, "fill": false, "color": "#3388ff", "opacity": 1, "silhouette": false, "silhouetteColor": "#ffffff", "silhouetteSize": 2, "silhouetteAlpha": 0.8, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "clampToGround": false }, "polyline": { "lineType": "solid", "animationDuration": 1000, "animationImage": "img/textures/lineClr.png", "color": "#3388ff", "width": 4, "clampToGround": false, "outline": false, "outlineColor": "#ffffff", "outlineWidth": 2, "depthFail": false, "depthFailColor": "#ff0000", "depthFailOpacity": 0.2, "opacity": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "zIndex": 0 }, "polylineVolume": { "color": "#00FF00", "radius": 10, "shape": "pipeline", "outline": false, "outlineColor": "#ffffff", "opacity": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0 }, "wall": { "extrudedHeight": 50, "fill": true, "fillType": "color", "animationDuration": 1000, "animationImage": "img/textures/fence.png", "animationRepeatX": 1, "animationAxisY": false, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0 }, "corridor": { "height": 0, "width": 100, "cornerType": "ROUNDED", "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "color": "#3388ff", "opacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "clampToGround": false, "zIndex": 0 }, "extrudedCorridor": { "height": 0, "extrudedHeight": 50, "width": 100, "cornerType": "ROUNDED", "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "color": "#00FF00", "opacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "clampToGround": false, "zIndex": 0 }, "polygon": { "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#3388ff", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "clampToGround": false, "zIndex": 0 }, "polygon_clampToGround": { "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#ffff00", "opacity": 0.6, "stRotation": 0, "clampToGround": true, "zIndex": 0 }, "extrudedPolygon": { "extrudedHeight": 100, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "perPositionHeight": true, "zIndex": 0 }, "rectangle": { "height": 0, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#3388ff", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "stRotation": 0, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "clampToGround": false, "zIndex": 0 }, "rectangleImg": { "opacity": 1, "rotation": 0, "clampToGround": true, "zIndex": 0 }, "extrudedRectangle": { "extrudedHeight": 100, "height": 0, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "stRotation": 0, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "zIndex": 0 }, "circle": { "height": 0, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#3388ff", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "clampToGround": false, "zIndex": 0 }, "circle_clampToGround": { "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#ffff00", "opacity": 0.6, "stRotation": 0, "rotation": 0, "clampToGround": true, "zIndex": 0 }, "extrudedCircle": { "extrudedHeight": 100, "height": 0, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "zIndex": 0 }, "ellipse": { "semiMinorAxis": 100, "semiMajorAxis": 100, "height": 0, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#3388ff", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "clampToGround": false, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "zIndex": 0 }, "ellipse_clampToGround": { "semiMinorAxis": 100, "semiMajorAxis": 100, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#ffff00", "opacity": 0.6, "stRotation": 0, "rotation": 0, "clampToGround": true, "zIndex": 0 }, "extrudedEllipse": { "semiMinorAxis": 100, "semiMajorAxis": 100, "extrudedHeight": 100, "height": 0, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "zIndex": 0 }, "cylinder": { "topRadius": 0, "bottomRadius": 100, "length": 100, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "color": "#00FF00", "opacity": 0.6, "outline": false, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0 }, "ellipsoid": { "extentRadii": 100, "widthRadii": 100, "heightRadii": 100, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6 }, "plane": { "dimensionsX": 100, "dimensionsY": 100, "plane_normal": "z", "plane_distance": 0, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0 }, "box": { "dimensionsX": 100, "dimensionsY": 100, "dimensionsZ": 100, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 100000, "distanceDisplayCondition_near": 0, "clampToGround": false } };
defConfigStyle.imagepoint = defConfigStyle.billboard; //兼容历史命名
defConfigStyle.ellipse = defConfigStyle.circle;

// delete defConfigStyle.circle.radius


//剔除与默认值相同的值
function removeGeoJsonDefVal(geojson) {
    if (!geojson.properties || !geojson.properties.type) return geojson;

    var type = geojson.properties.edittype || geojson.properties.type;
    var defStyle = defConfigStyle[type];
    if (!defStyle) return geojson;

    var newgeojson = (0, _util.clone)(geojson);
    if (geojson.properties.style) {
        var newstyle = {};
        for (var i in geojson.properties.style) {
            var val = geojson.properties.style[i];
            if (!Cesium.defined(val)) continue;

            var valDef = defStyle[i];
            if (valDef === val) continue;
            newstyle[i] = val;
        }
        newgeojson.properties.style = newstyle;
    }

    return newgeojson;
}

function addGeoJsonDefVal(properties) {
    //赋默认值 
    var defStyle = defConfigStyle[properties.edittype || properties.type];
    if (defStyle) {
        properties.style = properties.style || {};
        for (var key in defStyle) {
            var val = properties.style[key];
            if (Cesium.defined(val)) continue;

            properties.style[key] = defStyle[key];
        }
    }
    return properties;
}

//获取默认的样式
function getDefStyle(type, style) {
    style = style || {};
    //赋默认值 
    var defStyle = defConfigStyle[type];
    if (defStyle) {
        for (var key in defStyle) {
            var val = style[key];
            if (val != null) continue;

            style[key] = defStyle[key];
        }
    }
    return (0, _util.clone)(style);
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _globe = __webpack_require__(18);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值 
        entityattr = {};
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "color": //跳过扩展其他属性的参数
            case "opacity":
            case "outlineOpacity":

            case "grid_lineCount":
            case "grid_lineThickness":
            case "grid_cellAlpha":
            case "checkerboard_repeat":
            case "checkerboard_oddcolor":
            case "stripe_oddcolor":
            case "stripe_repeat":
            case "animationDuration":
            case "animationImage":
            case "animationRepeatX":
            case "animationRepeatY":
            case "animationAxisY":
            case "animationGradient":
            case "animationCount":
            case "randomColor":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outline":
                //边线
                if (entityattr[key] instanceof Cesium.CallbackProperty) {
                    //回调时不覆盖
                } else {
                    entityattr[key] = value;
                }
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || style.color || "#FFFF00").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
                break;
            case "extrudedHeight":
                //高度 
                if ((0, _util.isNumber)(value)) {
                    var maxHight = 0;
                    if (entityattr.hierarchy) {
                        var positions = getPositions({ polygon: entityattr });
                        maxHight = (0, _point.getMaxHeight)(positions);
                    }
                    entityattr.extrudedHeight = Number(value) + maxHight;
                } else {
                    entityattr.extrudedHeight = value;
                }
                break;
            case "clampToGround":
                //贴地
                entityattr.perPositionHeight = !value;
                break;

            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
            case "stRotation":
                //材质旋转角度 
                entityattr.stRotation = Cesium.Math.toRadians(value);
                break;
            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;
        }
    }

    //设置填充材质
    globe.setFillMaterial(entityattr, style);

    return entityattr;
}

//获取entity的坐标
function getPositions(entity, isShowPositions) {
    if (!isShowPositions && entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw; //箭头标绘等情形时，取绑定的数据

    var arr = entity.polygon.hierarchy.getValue((0, _util.currentTime)());
    var positions = getHierarchyVal(arr);
    return positions;
}

function getHierarchyVal(arr) {
    if (arr && arr instanceof Cesium.PolygonHierarchy) {
        if (arr.holes.length > 0) {
            return getHierarchyVal(arr.holes[arr.holes.length - 1]); //PolygonHierarchy
        }
        return arr.positions;
    }
    return arr;
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity, noAdd) {
    var coordinates = getCoordinates(entity);

    if (!noAdd && coordinates.length > 0) coordinates.push(coordinates[0]);

    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: {
            type: "Polygon",
            coordinates: [coordinates]
        }
    };
}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.interPolyline = interPolyline;
exports.computeSurfaceLine = computeSurfaceLine;
exports.computeSurfacePoints = computeSurfacePoints;
exports.computeStepSurfaceLine = computeStepSurfaceLine;
exports.interLine = interLine;
exports.getLinkedPointList = getLinkedPointList;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _layer = __webpack_require__(23);

var _util = __webpack_require__(1);

var _tileset = __webpack_require__(27);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//路线进行贴地(或贴模型)插值, splitNum为次数 
function interPolyline(opts) {
    var positions = opts.positions;
    var scene = opts.scene;

    var granularity = (0, _util.getGranularity)(positions, opts.splitNum || 100);
    if (granularity <= 0) granularity = null;

    var flatPositions = Cesium.PolylinePipeline.generateArc({
        positions: positions,
        height: opts.height, //未传入时，内部默认为0
        minDistance: opts.minDistance, //插值间隔(米)，优先级高于granularity
        granularity: granularity //splitNum分割的个数
    });

    var arr = [];
    for (var i = 0; i < flatPositions.length; i += 3) {
        var position = Cesium.Cartesian3.unpack(flatPositions, i);
        if (scene && Cesium.defaultValue(opts.surfaceHeight, true)) {
            var height = (0, _point.getSurfaceHeight)(scene, position, opts);
            var car = Cesium.Cartographic.fromCartesian(position);
            position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
        }
        arr.push(position);
    }
    return arr;
}

//计算贴地(或贴模型)路线（异步）
var surfaceLineWork = {
    start: function start(params) {
        this.params = params;
        this.scene = params.viewer ? params.viewer.scene : params.scene;

        var positions = params.positions;
        if (positions == null || positions.length == 0) {
            //无数据
            this.end(positions);
            return;
        }
        this.positions = positions;

        //线中间插值
        var _split = Cesium.defaultValue(params.split, true);
        if (_split) {
            positions = interPolyline({
                scene: this.scene,
                positions: positions,
                height: params.height,
                minDistance: params.minDistance,
                surfaceHeight: params.splitSurfaceHeight,
                splitNum: Cesium.defaultValue(params.splitNum, 100)
            });

            var positionsClone = [];
            for (var i = 0, len = positions.length; i < len; ++i) {
                positionsClone.push(positions[i].clone());
            }
            this.positions = positionsClone;
        }

        var _has3dtiles = Cesium.defaultValue(params.has3dtiles, Cesium.defined((0, _tileset.pick3DTileset)(this.scene, positions))); //是否在3ditiles上面
        var _hasTerrain = (0, _layer.hasTerrain)(this.scene); //是否有地形

        this._has3dtiles = _has3dtiles;
        this._hasTerrain = _hasTerrain;

        if (!_hasTerrain && !_has3dtiles) {
            //无地形和无模型时，直接返回
            this.end(positions);
            return;
        }

        //开始分析
        if (_hasTerrain) {
            this.clampToTerrain(positions);
        } else {
            this.clampTo3DTileset(positions);
        }
        return this;
    },
    clampToTerrain: function clampToTerrain(positions) {
        var ellipsoid = this.scene.globe.ellipsoid;
        var cartographicArray = ellipsoid.cartesianArrayToCartographicArray(positions);

        //用于缺少地形数据时，赋值的高度
        var tempHeight = Cesium.Cartographic.fromCartesian(positions[0]).height;

        var that = this;
        Cesium.when(Cesium.sampleTerrainMostDetailed(this.scene.terrainProvider, cartographicArray), function (samples) {
            samples = that.removeNullData(samples);

            var noHeight = false;
            var offset = Cesium.defaultValue(that.params.offset, 0); //增高高度，便于可视

            for (var i = 0; i < samples.length; ++i) {
                if (samples[i].height == null) {
                    noHeight = true;
                    samples[i].height = tempHeight;
                } else {
                    samples[i].height = offset + samples[i].height * that.scene._terrainExaggeration;
                }
            }

            var raisedPositions = ellipsoid.cartographicArrayToCartesianArray(samples);

            if (that._has3dtiles) {
                that.clampTo3DTileset(raisedPositions);
            } else {
                that.end(raisedPositions, noHeight);
            }
        });
    },
    clampTo3DTileset: function clampTo3DTileset(positions) {
        var that = this;
        var positionsClone = [];
        for (var i = 0, len = positions.length; i < len; ++i) {
            positionsClone.push(positions[i].clone());
        }
        this.scene.clampToHeightMostDetailed(positionsClone, this.params.objectsToExclude, 0.2).then(function (clampedCartesians) {
            clampedCartesians = that.removeNullData(clampedCartesians);
            if (clampedCartesians.length == 0) {
                clampedCartesians = positions;
            }
            that.end(clampedCartesians);
        });
    },
    end: function end(raisedPositions, noHeight) {
        var callback = this.params.callback || this.params.calback; //兼容不同参数名
        if (callback) {
            callback(raisedPositions, noHeight, this.positions);
        }
    },
    removeNullData: function removeNullData(samples) {
        var arrNew = [];
        for (var i = 0; i < samples.length; ++i) {
            if (samples[i] != null) {
                arrNew.push(samples[i]);
            }
        }
        return arrNew;
    }
};

//对外接口,求路线的贴地线
function computeSurfaceLine(params) {
    return surfaceLineWork.start(params);
}

//对外接口,求多个点的的贴地新坐标（不插值）
function computeSurfacePoints(params) {
    params.split = false;
    return surfaceLineWork.start(params);
}

//对外接口,按2个坐标点分段计算 求路线的贴地线
function computeStepSurfaceLine(opts) {
    var positions = opts.positions;

    var params = {};
    for (var key in opts) {
        if (key == "positions" || key == "callback" || key == "calback") continue;
        params[key] = opts[key];
    }

    var index = 0;
    var allcount = positions.length - 1;
    function getLineFD() {
        if (index >= allcount) {
            if (opts.callback) opts.callback();
            if (opts.end) opts.end();

            //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
            if (opts.calback) opts.calback();
            if (opts.calbakEnd) opts.calbakEnd();
            //兼容v2.2之前旧版本处理,非升级用户可删除上面代码
            return;
        }

        params.positions = [positions[index], positions[index + 1]];
        params.callback = function (raisedPositions, noHeight) {
            if (opts.endItem) {
                opts.endItem(raisedPositions, noHeight, index);
            }

            //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
            if (opts.calbakStep) {
                opts.calbakStep(raisedPositions, noHeight, index);
            }
            //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

            index++;
            getLineFD();
        };
        surfaceLineWork.start(params);
    }
    getLineFD();
}

//插值线（高度值按原高度等比计算）
function interLine(positions, opts) {
    if (!positions || positions.length < 2) return positions;

    opts = opts || {};

    var granularity;
    if (opts.splitNum) {
        //splitNum分割的个数
        granularity = (0, _util.getGranularity)(positions, opts.splitNum);
        if (granularity <= 0) granularity = null;
    }

    var arr = [positions[0]];
    for (var index = 1, length = positions.length; index < length; index++) {
        var startP = positions[index - 1];
        var endP = positions[index];

        var interPositions = Cesium.PolylinePipeline.generateArc({
            positions: [startP, endP],
            minDistance: opts.minDistance, //插值间隔(米)，优先级高于granularity
            granularity: granularity //splitNum分割的个数
        });

        //剖面的数据 
        var h1 = Cesium.Cartographic.fromCartesian(startP).height;
        var h2 = Cesium.Cartographic.fromCartesian(endP).height;
        var hstep = (h2 - h1) / interPositions.length;

        for (var i = 3, len = interPositions.length; i < len; i += 3) {
            var position = Cesium.Cartesian3.unpack(interPositions, i);

            var car = Cesium.Cartographic.fromCartesian(position);

            var height = Number((h1 + hstep * i).toFixed(1));
            position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);

            arr.push(position);
        }
    }
    return arr;
}

/**
 * 计算曲线链路的点集（a点到b点的，空中曲线）
 * @param startPoint 开始节点
 * @param endPoint 结束节点
 * @param angularityFactor 曲率
 * @param numOfSingleLine 点集数量
 * @returns {Array}
 */
function getLinkedPointList(startPoint, endPoint, angularityFactor, numOfSingleLine) {
    var result = [];

    var startPosition = Cesium.Cartographic.fromCartesian(startPoint);
    var endPosition = Cesium.Cartographic.fromCartesian(endPoint);

    var startLon = startPosition.longitude * 180 / Math.PI;
    var startLat = startPosition.latitude * 180 / Math.PI;
    var endLon = endPosition.longitude * 180 / Math.PI;
    var endLat = endPosition.latitude * 180 / Math.PI;

    var dist = Math.sqrt((startLon - endLon) * (startLon - endLon) + (startLat - endLat) * (startLat - endLat));

    //var dist = Cesium.Cartesian3.distance(startPoint, endPoint);
    var angularity = dist * angularityFactor;

    var startVec = Cesium.Cartesian3.clone(startPoint);
    var endVec = Cesium.Cartesian3.clone(endPoint);

    var startLength = Cesium.Cartesian3.distance(startVec, Cesium.Cartesian3.ZERO);
    var endLength = Cesium.Cartesian3.distance(endVec, Cesium.Cartesian3.ZERO);

    Cesium.Cartesian3.normalize(startVec, startVec);
    Cesium.Cartesian3.normalize(endVec, endVec);

    if (Cesium.Cartesian3.distance(startVec, endVec) == 0) {
        return result;
    }

    //var cosOmega = Cesium.Cartesian3.dot(startVec, endVec);
    //var omega = Math.acos(cosOmega);

    var omega = Cesium.Cartesian3.angleBetween(startVec, endVec);

    result.push(startPoint);
    for (var i = 1; i < numOfSingleLine - 1; i++) {
        var t = i * 1.0 / (numOfSingleLine - 1);
        var invT = 1 - t;

        var startScalar = Math.sin(invT * omega) / Math.sin(omega);
        var endScalar = Math.sin(t * omega) / Math.sin(omega);

        var startScalarVec = Cesium.Cartesian3.multiplyByScalar(startVec, startScalar, new Cesium.Cartesian3());
        var endScalarVec = Cesium.Cartesian3.multiplyByScalar(endVec, endScalar, new Cesium.Cartesian3());

        var centerVec = Cesium.Cartesian3.add(startScalarVec, endScalarVec, new Cesium.Cartesian3());

        var ht = t * Math.PI;
        var centerLength = startLength * invT + endLength * t + Math.sin(ht) * angularity;
        centerVec = Cesium.Cartesian3.multiplyByScalar(centerVec, centerLength, centerVec);

        result.push(centerVec);
    }

    result.push(endPoint);

    return result;
}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.hasTerrain = hasTerrain;
exports.getEllipsoidTerrain = getEllipsoidTerrain;
exports.getTerrainProvider = getTerrainProvider;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _util = __webpack_require__(1);

var _BaseLayer = __webpack_require__(15);

var _GroupLayer = __webpack_require__(98);

var _TileLayer = __webpack_require__(41);

var _SuperMapImgLayer = __webpack_require__(99);

var _GraticuleLayer = __webpack_require__(100);

var _CustomFeatureGridLayer = __webpack_require__(42);

var _POILayer = __webpack_require__(103);

var _WFSLayer = __webpack_require__(104);

var _GeoJsonLayer = __webpack_require__(43);

var _WaterLayer = __webpack_require__(105);

var _GltfLayer = __webpack_require__(106);

var _Tiles3dLayer = __webpack_require__(107);

var _KmlLayer = __webpack_require__(108);

var _CzmlLayer = __webpack_require__(109);

var _TerrainLayer = __webpack_require__(110);

var _DrawLayer = __webpack_require__(111);

var _BaiduImageryProvider = __webpack_require__(112);

var _TencentImageryProvider = __webpack_require__(113);

var _FeatureGridImageryProvider = __webpack_require__(114);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

exports.BaseLayer = _BaseLayer.BaseLayer;

exports.GroupLayer = _GroupLayer.GroupLayer;

exports.TileLayer = _TileLayer.TileLayer;

exports.SuperMapImgLayer = _SuperMapImgLayer.SuperMapImgLayer;

exports.GraticuleLayer = _GraticuleLayer.GraticuleLayer;

exports.CustomFeatureGridLayer = _CustomFeatureGridLayer.CustomFeatureGridLayer;

exports.POILayer = _POILayer.POILayer;

exports.WFSLayer = _WFSLayer.WFSLayer;

exports.GeoJsonLayer = _GeoJsonLayer.GeoJsonLayer;

exports.WaterLayer = _WaterLayer.WaterLayer;

exports.GltfLayer = _GltfLayer.GltfLayer;

exports.Tiles3dLayer = _Tiles3dLayer.Tiles3dLayer;

exports.KmlLayer = _KmlLayer.KmlLayer;

exports.CzmlLayer = _CzmlLayer.CzmlLayer;

exports.TerrainLayer = _TerrainLayer.TerrainLayer;

exports.DrawLayer = _DrawLayer.DrawLayer;

exports.BaiduImageryProvider = _BaiduImageryProvider.BaiduImageryProvider;

exports.TencentImageryProvider = _TencentImageryProvider.TencentImageryProvider;

exports.FeatureGridImageryProvider = _FeatureGridImageryProvider.FeatureGridImageryProvider;

//类库外部的类
var exLayer = {};
exports.regLayerForConfig = function (type, layerClass) {
    exLayer[type] = layerClass;
};

//创建图层
exports.createLayer = function createLayer(viewer, item, serverURL) {

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    if (item instanceof Cesium.Viewer) {
        var temppar = item;
        item = viewer;
        viewer = temppar;
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    var layer;

    if (item.url) {
        if (serverURL) {
            item.url = item.url.replace('$serverURL$', serverURL);
        }
        item.url = item.url.replace('$hostname$', location.hostname).replace('$host$', location.host);
    }

    switch (item.type) {
        //===============地图数组====================
        case "group":
            //示例：{ "name": "电子地图", "type": "group","layers": [    ]}
            if (item.layers && item.layers.length > 0) {
                var arrVec = [];
                for (var index = 0; index < item.layers.length; index++) {
                    var temp = createLayer(viewer, item.layers[index], serverURL);
                    if (temp == null) continue;
                    arrVec.push(temp);
                }
                var newItem = {};
                for (var key in item) {
                    newItem[key] = item[key];
                }
                newItem._layers = arrVec;
                layer = new _GroupLayer.GroupLayer(viewer, newItem);
            }
            break;
        case "base":
            layer = new _BaseLayer.BaseLayer(viewer, item);
            break;
        case "www_bing": //bing地图 
        case "www_osm": //OSM开源地图 
        case "www_google": //谷歌国内
        case "www_gaode": //高德
        case "www_baidu": //百度 
        case "www_tencent": //腾讯
        case "www_tdt": //天地图
        case "mapbox":
        case "www_mapbox":
        case "mapboxstyle":
        case "www_mapboxstyle":
        case "arcgis_cache":
        case "arcgis":
        case "arcgis_tile":
        case "arcgis_dynamic":
        case "wmts":
        case "tms":
        case "wms":
        case "xyz":
        case "tile":
        case "single":
        case "image":
        case "gee":
        case "custom_tilecoord": //瓦片信息
        case "custom_grid":
            //网格线 
            //瓦片图层
            layer = new _TileLayer.TileLayer(viewer, item);
            layer.isTile = true;
            break;
        case "sm_img": //超图底图支持
        case "supermap_img":
            //瓦片图层
            layer = new _SuperMapImgLayer.SuperMapImgLayer(viewer, item);
            layer.isTile = true;
            break;
        case "www_poi":
            //在线poi数据
            layer = new _POILayer.POILayer(viewer, item);
            break;
        case "custom_featuregrid":
            //自定义矢量网格图层 
            layer = new _CustomFeatureGridLayer.CustomFeatureGridLayer(viewer, item);
            break;
        case "custom_graticule":
            layer = new _GraticuleLayer.GraticuleLayer(viewer, item);
            break;

        case "3dtiles":
            layer = new _Tiles3dLayer.Tiles3dLayer(viewer, item);
            break;
        case "gltf":
            layer = new _GltfLayer.GltfLayer(viewer, item);
            break;
        case "geojson":
            layer = new _GeoJsonLayer.GeoJsonLayer(viewer, item);
            break;
        case "geojson-draw":
            //基于框架内部draw绘制保存的geojson数据的加载
            layer = new _DrawLayer.DrawLayer(viewer, item);
            break;
        case "water":
        case "geojson-water":
            layer = new _WaterLayer.WaterLayer(viewer, item);
            break;
        case "kml":
            layer = new _KmlLayer.KmlLayer(viewer, item);
            break;
        case "czml":
            layer = new _CzmlLayer.CzmlLayer(viewer, item);
            break;
        case "wfs":
            layer = new _WFSLayer.WFSLayer(viewer, item);
            break;
        case "terrain":
            if (serverURL && item.terrain && item.terrain.url) {
                item.terrain.url = item.terrain.url.replace('$serverURL$', serverURL);
            }
            layer = new _TerrainLayer.TerrainLayer(viewer, item);
            break;
        default:
            if (exLayer[item.type]) {
                layer = new exLayer[item.type](viewer, item);
            }
            if (layer == null) {
                try {
                    marslog.warn("配置中的图层未处理：" + JSON.stringify(item));
                } catch (e) {}
            }
            break;
    }

    return layer;
};

//创建地图底图
exports.createImageryProvider = function (item, serverURL) {
    if (item.url) {
        if (serverURL) {
            item.url = item.url.replace('$serverURL$', serverURL);
        }
        item.url = item.url.replace('$hostname$', location.hostname).replace('$host$', location.host);
    }

    var opts = {};
    for (var key in item) {
        var value = item[key];
        if (value == null) continue;

        switch (key) {
            default:
                //直接赋值
                opts[key] = value;
                break;
            case "crs":
                value = (value + "").toUpperCase();
                if (value == "4326" || value == "EPSG4326" || value == "EPSG:4326") {
                    opts.tilingScheme = new Cesium.GeographicTilingScheme({
                        numberOfLevelZeroTilesX: item.numberOfLevelZeroTilesX || 2,
                        numberOfLevelZeroTilesY: item.numberOfLevelZeroTilesY || 1
                    });
                } else if (value == "4490" || value == "EPSG4490" || value == "EPSG:4490") {
                    opts.tilingScheme = new Cesium.GeographicTilingScheme({
                        numberOfLevelZeroTilesX: item.numberOfLevelZeroTilesX || 2,
                        numberOfLevelZeroTilesY: item.numberOfLevelZeroTilesY || 1
                    });
                    opts.is4490 = true;
                } else {
                    opts.tilingScheme = new Cesium.WebMercatorTilingScheme({
                        numberOfLevelZeroTilesX: item.numberOfLevelZeroTilesX || 1,
                        numberOfLevelZeroTilesY: item.numberOfLevelZeroTilesY || 1
                    });
                }
                break;
            case "rectangle":
                opts.rectangle = Cesium.Rectangle.fromDegrees(value.xmin, value.ymin, value.xmax, value.ymax);
                break;
            case "bbox":
                //[xmin,ymin,xmax,ymax]
                opts.rectangle = Cesium.Rectangle.fromDegrees(value[0], value[1], value[2], value[3]);
                break;
        }
    }

    //4490坐标系z值是+1的
    if (opts.is4490 && opts.url) {
        opts.url = opts.url.replace('{z}', '{z4490}');
        opts.url = opts.url.replace('{arc_z}', '{arc_z4490}');
        opts.url = opts.url.replace('{arc_Z}', '{arc_Z4490}');
    }

    if (opts.url && (opts.proxy || opts.headers || opts.queryParameters)) {
        opts = (0, _util.getProxyUrl)(opts);
    }

    var layer;
    switch (opts.type_new || opts.type) {
        //===============地图底图==================== 
        case "single":
        case "image":
            layer = new Cesium.SingleTileImageryProvider(opts);
            break;
        case "xyz":
        case "tile":
            opts.customTags = opts.customTags || {};
            opts.customTags["z4490"] = function (imageryProvider, x, y, level) {
                return level + 1;
            };
            layer = new Cesium.UrlTemplateImageryProvider(opts);
            break;
        case "wms":
            layer = new Cesium.WebMapServiceImageryProvider(opts);
            break;
        case "tms":
            if (!opts.url) opts.url = Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII');
            layer = new Cesium.TileMapServiceImageryProvider(opts);
            break;
        case "wmts":
            if (opts.is4490) {
                opts.tileMatrixLabels = [].concat(_toConsumableArray(Array(20).keys())).map(function (item) {
                    return (item + 1).toString();
                });
            }
            layer = new Cesium.WebMapTileServiceImageryProvider(opts);
            break;
        case "gee":
            //谷歌地球
            layer = new Cesium.GoogleEarthEnterpriseImageryProvider({
                metadata: new Cesium.GoogleEarthEnterpriseMetadata(opts)
            });
            break;
        case "mapbox": //mapbox
        case "www_mapbox":
            opts.accessToken = Cesium.defaultValue(opts.accessToken, 'pk.eyJ1IjoibWFyc2dpcyIsImEiOiJja2Fod2xlanIwNjJzMnhvMXBkMnNqcjVpIn0.WnxikCaN2KV_zn9tLZO77A');
            layer = new Cesium.MapboxImageryProvider(opts);
            break;
        case "mapboxstyle":
        case "www_mapboxstyle":
            opts.accessToken = Cesium.defaultValue(opts.accessToken, 'pk.eyJ1IjoibWFyc2dpcyIsImEiOiJja2Fod2xlanIwNjJzMnhvMXBkMnNqcjVpIn0.WnxikCaN2KV_zn9tLZO77A');
            layer = new Cesium.MapboxStyleImageryProvider(opts);
            break;
        case "arcgis":
        case "arcgis_tile":
        case "arcgis_dynamic":
            layer = new Cesium.ArcGisMapServerImageryProvider(opts);
            break;
        case "sm_img": //超图底图支持
        case "supermap_img":
            layer = new Cesium.SuperMapImageryProvider(opts);
            break;
        case "arcgis_cache":
            // 示例 /google/_alllayers/L{arc_z}/R{arc_y}/C{arc_x}.jpg
            if (!Cesium.UrlTemplateImageryProvider.prototype.padLeft0) {
                Cesium.UrlTemplateImageryProvider.prototype.padLeft0 = function (numStr, n) {
                    numStr = String(numStr);
                    var len = numStr.length;
                    while (len < n) {
                        numStr = "0" + numStr;
                        len++;
                    }
                    return numStr;
                };
            }
            opts.customTags = {
                //小写
                "arc_x": function arc_x(imageryProvider, x, y, level) {
                    return imageryProvider.padLeft0(x.toString(16), 8);
                },
                "arc_y": function arc_y(imageryProvider, x, y, level) {
                    return imageryProvider.padLeft0(y.toString(16), 8);
                },
                "arc_z": function arc_z(imageryProvider, x, y, level) {
                    return imageryProvider.padLeft0(level.toString(), 2);
                },
                "arc_z4490": function arc_z4490(imageryProvider, x, y, level) {
                    return imageryProvider.padLeft0((level + 1).toString(), 2);
                },
                //大写
                "arc_X": function arc_X(imageryProvider, x, y, level) {
                    return imageryProvider.padLeft0(x.toString(16), 8).toUpperCase();
                },
                "arc_Y": function arc_Y(imageryProvider, x, y, level) {
                    return imageryProvider.padLeft0(y.toString(16), 8).toUpperCase();
                },
                "arc_Z": function arc_Z(imageryProvider, x, y, level) {
                    return imageryProvider.padLeft0(level.toString(), 2).toUpperCase();
                },
                "arc_Z4490": function arc_Z4490(imageryProvider, x, y, level) {
                    return imageryProvider.padLeft0((level + 1).toString(), 2).toUpperCase();
                }
            };

            layer = new Cesium.UrlTemplateImageryProvider(opts);
            break;

        //===============互联网常用地图==================== 

        case "www_tdt":
            //天地图
            var _layer;
            var maxLevel = 18;
            switch (opts.layer) {
                default:
                case "vec_d":
                    _layer = "vec";
                    break;
                case "vec_z":
                    _layer = "cva";
                    break;
                case "img_d":
                    _layer = "img";
                    break;
                case "img_z":
                    _layer = "cia";
                    break;
                case "ter_d":
                    _layer = "ter";
                    maxLevel = 14;
                    break;
                case "ter_z":
                    _layer = "cta";
                    maxLevel = 14;
                    break;
            }

            var _key;
            if (opts.key == null || opts.key.length == 0) _key = '2a0e637a8772d92b123ee8866dee4a82'; //默认
            else _key = getOneKey(opts.key);

            if (item.crs == '4326') {
                //wgs84                  
                var _url = 'https://t{s}.tianditu.gov.cn/' + _layer + '_c/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=' + _layer + '&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=' + _key;

                if (opts.proxy || opts.headers || opts.queryParameters) {
                    //存在代理等参数时
                    _url = (0, _util.getProxyUrl)({
                        url: _url.replace('{s}', '0'),
                        proxy: opts.proxy,
                        headers: opts.headers,
                        queryParameters: opts.queryParameters
                    }).url;
                }

                layer = new Cesium.WebMapTileServiceImageryProvider(_extends({
                    subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
                    maximumLevel: maxLevel
                }, opts, {

                    url: _url,
                    layer: _layer,
                    style: 'default',
                    format: 'tiles',
                    tileMatrixSetID: 'c',
                    tileMatrixLabels: [].concat(_toConsumableArray(Array(18).keys())).map(function (item) {
                        return (item + 1).toString();
                    }),
                    tilingScheme: new Cesium.GeographicTilingScheme() //WebMercatorTilingScheme、GeographicTilingScheme
                }));
            } else {
                //墨卡托 
                var _url = 'https://t{s}.tianditu.gov.cn/' + _layer + '_w/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=' + _layer + '&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=' + _key;

                if (opts.proxy || opts.headers || opts.queryParameters) {
                    //存在代理等参数时
                    _url = (0, _util.getProxyUrl)({
                        url: _url.replace('{s}', '0'),
                        proxy: opts.proxy,
                        headers: opts.headers,
                        queryParameters: opts.queryParameters
                    }).url;
                }

                layer = new Cesium.WebMapTileServiceImageryProvider(_extends({
                    subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
                    maximumLevel: maxLevel
                }, opts, {

                    url: _url,
                    layer: _layer,
                    style: 'default',
                    format: 'tiles',
                    tileMatrixSetID: 'w',
                    tileMatrixLabels: [].concat(_toConsumableArray(Array(18).keys())).map(function (item) {
                        return item.toString();
                    }),
                    tilingScheme: new Cesium.WebMercatorTilingScheme()
                }));
            }
            break;
        case "www_gaode":
            //高德
            var _url;
            switch (opts.layer) {
                case "vec":
                default:
                    //style=7是立体的，style=8是灰色平面的
                    _url = 'https://' + (opts.bigfont ? 'wprd' : 'webrd') + '0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=7&x={x}&y={y}&z={z}';
                    break;
                case "img_d":
                    _url = 'https://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}';
                    break;
                case "img_z":
                    _url = 'https://webst0{s}.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scale=1&style=8';
                    break;
                case "time":
                    var time = new Date().getTime();
                    _url = 'https://tm.amap.com/trafficengine/mapabc/traffictile?v=1.0&;t=1&x={x}&y={y}&z={z}&&t=' + time;
                    break;
            }

            if (opts.proxy || opts.headers || opts.queryParameters) {
                //存在代理等参数时
                _url = (0, _util.getProxyUrl)({
                    url: _url.replace('{s}', '1'),
                    proxy: opts.proxy,
                    headers: opts.headers,
                    queryParameters: opts.queryParameters
                }).url;
            }
            layer = new Cesium.UrlTemplateImageryProvider(_extends({
                subdomains: ['1', '2', '3', '4'],
                maximumLevel: 18
            }, opts, {
                url: _url
            }));
            break;
        case "www_baidu":
            //百度
            layer = new _BaiduImageryProvider.BaiduImageryProvider(opts);
            break;
        case "www_tencent":
            //腾讯
            layer = new _TencentImageryProvider.TencentImageryProvider(opts);
            break;

        case "www_google":
            //谷歌国内   
            var _url;

            if (item.crs == '4326' || item.crs == 'wgs84') {
                //无偏移
                switch (opts.layer) {
                    default:
                    case "img_d":
                        // _url = 'http://www.google.cn/maps/vt?lyrs=s&x={x}&y={y}&z={z}';
                        // _url = 'http://mt{s}.google.cn/vt/lyrs=s&x={x}&y={y}&z={z}';
                        _url = "http://mt3.google.cn/vt?lyrs=s@187&hl=us&gl=us&x={x}&y={y}&z={z}";
                        break;
                }
            } else {
                //有偏移  
                switch (opts.layer) {
                    case "vec":
                    default:
                        _url = 'http://mt{s}.google.cn/vt/lyrs=m@207000000&hl=zh-CN&gl=CN&src=app&x={x}&y={y}&z={z}&s=Galile';
                        break;
                    case "img_d":
                        _url = 'http://mt{s}.google.cn/vt/lyrs=s&hl=zh-CN&gl=CN&x={x}&y={y}&z={z}&s=Gali';
                        break;
                    case "img_z":
                        _url = 'http://mt{s}.google.cn/vt/imgtp=png32&lyrs=h@207000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galil';
                        break;
                    case "ter":
                        _url = 'http://mt{s}.google.cn/vt/lyrs=t@131,r@227000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galile';
                        break;
                }
            }

            if (opts.proxy || opts.headers || opts.queryParameters) {
                //存在代理等参数时
                _url = (0, _util.getProxyUrl)({
                    url: _url.replace('{s}', '1'),
                    proxy: opts.proxy,
                    headers: opts.headers,
                    queryParameters: opts.queryParameters
                }).url;
            }
            layer = new Cesium.UrlTemplateImageryProvider(_extends({
                subdomains: ['1', '2', '3'],
                maximumLevel: 20
            }, opts, {
                url: _url
            }));
            break;

        case "www_osm":
            //OSM开源地图 
            var _url = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';

            if (opts.proxy || opts.headers || opts.queryParameters) {
                //存在代理等参数时
                _url = (0, _util.getProxyUrl)({
                    url: _url.replace('{s}', 'a'),
                    proxy: opts.proxy,
                    headers: opts.headers,
                    queryParameters: opts.queryParameters
                }).url;
            }
            layer = new Cesium.UrlTemplateImageryProvider(_extends({
                subdomains: "abc",
                maximumLevel: 18
            }, opts, {
                url: _url
            }));
            break;
        case "www_bing":
            //bing地图 

            var _url = 'https://dev.virtualearth.net';

            if (opts.proxy || opts.headers || opts.queryParameters) {
                //存在代理等参数时
                _url = (0, _util.getProxyUrl)({
                    url: _url,
                    proxy: opts.proxy,
                    headers: opts.headers,
                    queryParameters: opts.queryParameters
                }).url;
            }
            opts.key = opts.key || 'AtkX3zhnRe5fyGuLU30uZw8r3sxdBDnpQly7KfFTCB2rGlDgXBG3yr-qEiQEicEc';

            //无标记影像 Aerial,
            //有英文标记影像   AerialWithLabels,
            //矢量道路  Road 
            //OrdnanceSurvey,
            //CollinsBart
            var style = opts.layer || Cesium.BingMapsStyle.Aerial;
            layer = new Cesium.BingMapsImageryProvider(_extends({
                mapStyle: style
            }, opts, {
                url: _url
            }));
            break;

        //===============内部定义的图层====================
        case "custom_grid":
            //网格线  
            opts.cells = opts.cells || 2;
            opts.color = Cesium.Color.fromCssColorString(opts.color || 'rgba(255,255,255,1)');
            opts.glowWidth = opts.glowWidth || 3;
            if (opts.glowColor) opts.glowColor = Cesium.Color.fromCssColorString(opts.glowColor);else opts.glowColor = opts.color.withAlpha(0.3);
            opts.backgroundColor = Cesium.Color.fromCssColorString(opts.backgroundColor || 'rgba(0,0,0,0)');

            layer = new Cesium.GridImageryProvider(opts);
            break;
        case "custom_tilecoord":
            //瓦片信息
            layer = new Cesium.TileCoordinatesImageryProvider(opts);
            break;
        case "custom_featuregrid":
            //自定义矢量网格图层
            layer = new _FeatureGridImageryProvider.FeatureGridImageryProvider(opts);
            break;
        default:
            try {
                marslog.warn("配置中的图层未处理：" + JSON.stringify(item));
            } catch (e) {}
            break;
    }
    layer.config = opts;

    return layer;
};

function getOneKey(arr) {
    var n = Math.floor(Math.random() * arr.length + 1) - 1;
    return arr[n];
}

//===================================== 地形相关 ================================= 

var _ellipsoid = new Cesium.EllipsoidTerrainProvider({
    ellipsoid: Cesium.Ellipsoid.WGS84
});

//是否无地形
function hasTerrain(viewer) {
    return !(viewer.terrainProvider == _ellipsoid || viewer.terrainProvider instanceof Cesium.EllipsoidTerrainProvider);
}
function getEllipsoidTerrain() {
    return _ellipsoid;
}
function getTerrainProvider(cfg) {
    cfg = cfg || { type: "ion" };
    cfg.requestWaterMask = Cesium.defaultValue(cfg.requestWaterMask, true);
    cfg.requestVertexNormals = Cesium.defaultValue(cfg.requestVertexNormals, true);

    var terrainProvider;
    switch (cfg.type) {
        default:
            //默认是自定义的 
            terrainProvider = new Cesium.CesiumTerrainProvider((0, _util.getProxyUrl)(cfg));
            break;
        case "ion":
        case "cesium":
            //cesium官方在线的
            terrainProvider = new Cesium.CesiumTerrainProvider({
                url: Cesium.IonResource.fromAssetId(1),
                requestWaterMask: cfg.requestWaterMask,
                requestVertexNormals: cfg.requestVertexNormals
            });
            break;
        case "gee":
        case "google":
            //谷歌地球地形服务
            terrainProvider = new Cesium.GoogleEarthEnterpriseTerrainProvider({
                metadata: new Cesium.GoogleEarthEnterpriseMetadata((0, _util.getProxyUrl)(cfg))
            });
            break;
        case "arcgis":
            //ArcGIS地形服务 
            terrainProvider = new Cesium.ArcGISTiledElevationTerrainProvider((0, _util.getProxyUrl)(cfg));
            break;
        case "ellipsoid":
            terrainProvider = _ellipsoid;
            break;
    }

    return terrainProvider;
}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawPoint = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(35);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(12);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(59);

var _Draw = __webpack_require__(44);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPoint = exports.DrawPoint = function (_DrawBase) {
    _inherits(DrawPoint, _DrawBase);

    //========== 构造方法 ========== 
    function DrawPoint(opts) {
        _classCallCheck(this, DrawPoint);

        var _this = _possibleConstructorReturn(this, (DrawPoint.__proto__ || Object.getPrototypeOf(DrawPoint)).call(this, opts));

        _this.type = 'point';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditPoint; //获取编辑对象

        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawPoint, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = null;

            //绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
            var _drawShow = Cesium.defaultValue(attribute.drawShow, false);

            var that = this;
            var addattr = {
                show: _drawShow,
                _drawShow: _drawShow, //edit编辑时使用
                position: new Cesium.CallbackProperty(function (time) {
                    return that.getDrawPosition();
                }, false),
                point: attr.style2Entity(attribute.style),
                attribute: attribute
            };

            if (attribute.style && attribute.style.label) {
                //同时加文字
                addattr.label = (0, _Attr2.style2Entity)(attribute.style.label);
            }

            this.entity = dataSource.entities.add(addattr); //创建要素对象
            //子类使用
            if (this.createFeatureEx) this.createFeatureEx(attribute.style, this.entity);
            return this.entity;
        }
        //重新激活绘制

    }, {
        key: 'reCreateFeature',
        value: function reCreateFeature(entity) {
            this.entity = entity;
            this._positions_draw = entity.position;
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            if (style && style.label) {
                //同时加文字
                (0, _Attr2.style2Entity)(style.label, entity.label);
            }
            if (entity.featureEx) {
                entity.featureEx.updateStyle(style);
            }
            return attr.style2Entity(style, entity.point);
        }
        //绑定鼠标事件

    }, {
        key: 'bindEvent',
        value: function bindEvent() {
            var _this2 = this;

            this.getHandler().setInputAction(function (event) {
                var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.endPosition, _this2.entity);
                if (point) {
                    _this2._positions_draw = point;
                    if (_this2.entity.featureEx) {
                        _this2.entity.featureEx.position = point;
                    }
                }
                _this2.tooltip.showAt(event.endPosition, _this2.entity.draw_tooltip || _Tooltip.message.draw.point.start);

                _this2.fire(_MarsClass.eventType.drawMouseMove, { drawtype: _this2.type, entity: _this2.entity, position: point });
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

            this.getHandler().setInputAction(function (event) {
                var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.position, _this2.entity);
                if (point) {
                    _this2._positions_draw = point;
                }

                if (_this2._positions_draw) _this2.disable();
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }
        //获取外部entity的坐标到_positions_draw

    }, {
        key: 'setDrawPositionByEntity',
        value: function setDrawPositionByEntity(entity) {
            var positions = this.getPositions(entity);
            this._positions_draw = positions[0];
        }
        //图形绘制结束,更新属性

    }, {
        key: 'finish',
        value: function finish() {
            this.entity.show = true;

            this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象     
            this.entity.position = this.getDrawPosition();
            if (this.entity.featureEx) {
                this.entity.featureEx.position = this.getDrawPosition();
                this.entity.featureEx.finish();
            }
        }
    }]);

    return DrawPoint;
}(_Draw.DrawBase);

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditPolyline = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(28);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPolyline = exports.EditPolyline = function (_EditBase) {
    _inherits(EditPolyline, _EditBase);

    //========== 构造方法 ========== 
    function EditPolyline(entity, viewer) {
        _classCallCheck(this, EditPolyline);

        var _this = _possibleConstructorReturn(this, (EditPolyline.__proto__ || Object.getPrototypeOf(EditPolyline)).call(this, entity, viewer));

        _this._positions_draw = [];
        _this._hasMidPoint = true;
        _this.hasClosure = false; //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点  
        return _this;
    }

    //取enity对象的对应矢量数据


    _createClass(EditPolyline, [{
        key: 'getGraphic',
        value: function getGraphic() {
            return this.entity.polyline;
        }
        //坐标位置相关

    }, {
        key: 'getPosition',
        value: function getPosition() {
            return this._positions_draw;
        }
        //外部更新位置

    }, {
        key: 'setPositions',
        value: function setPositions(positions) {
            this._positions_draw = positions;
            this.updateAttrForEditing();
            this.finish();
        }
        //修改坐标会回调，提高显示的效率

    }, {
        key: 'changePositionsToCallback',
        value: function changePositionsToCallback() {
            this._positions_draw = this.entity._positions_draw || this.getGraphic().positions.getValue(this.viewer.clock.currentTime);
        }
    }, {
        key: 'updateAttrForEditing',
        value: function updateAttrForEditing() {
            //显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示
            if (this.entity.attribute.type == "polyline" && Cesium.defined(this.entity.polyline.depthFailMaterial)) {
                this.entity.polyline.positions = this.getPosition();
            }
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            this.entity._positions_draw = this.getPosition();

            var entity = this.entity;
            if (this.entity.attribute.type == "polyline") {
                //显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示
                if (Cesium.defined(entity.polyline.depthFailMaterial)) {
                    entity.polyline.positions = entity._positions_draw;
                } else {
                    entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                        return entity._positions_draw;
                    }, false);
                }
            }
        }
    }, {
        key: 'isClampToGround',
        value: function isClampToGround() {
            return this.entity.attribute.style.clampToGround;
        }
        //是否可在中间新增点 

    }, {
        key: 'hasMidPoint',
        value: function hasMidPoint() {
            return this._hasMidPoint && this.getPosition().length < this._maxPointNum;
        }
        //子类用，根据属性更新坐标

    }, {
        key: 'updatePositionsHeightByAttr',
        value: function updatePositionsHeightByAttr(position) {
            return position;
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {
            var that = this;

            var positions = this.getPosition();

            var clampToGround = this.isClampToGround();
            var hasMidPoint = this.hasMidPoint();

            for (var i = 0, len = positions.length; i < len; i++) {
                var loc = positions[i];

                loc = this.updatePositionsHeightByAttr(loc);
                if (clampToGround) {
                    //贴地时求贴模型和贴地的高度
                    loc = (0, _point.setPositionSurfaceHeight)(this.viewer, loc);
                    positions[i] = loc;
                }

                //各顶点
                var dragger = draggerCtl.createDragger(this.entityCollection, {
                    position: loc,
                    //clampToGround: clampToGround,
                    onDrag: function onDrag(dragger, position) {
                        position = that.updatePositionsHeightByAttr(position);
                        dragger.position = position;
                        positions[dragger.index] = position;

                        if (that.heightDraggers && that.heightDraggers.length > 0) {
                            that.updateDraggers();
                        } else {
                            //============新增点拖拽点处理=============
                            if (hasMidPoint) {
                                var draggersIdx;
                                var nextPositionIdx;
                                //与前一个点之间的中点 
                                if (that.hasClosure || !that.hasClosure && dragger.index != 0) {
                                    if (dragger.index == 0) {
                                        draggersIdx = len * 2 - 1;
                                        nextPositionIdx = len - 1;
                                    } else {
                                        draggersIdx = dragger.index * 2 - 1;
                                        nextPositionIdx = dragger.index - 1;
                                    }
                                    var nextPosition = positions[nextPositionIdx];
                                    var midpoint = Cesium.Cartesian3.midpoint(position, nextPosition, new Cesium.Cartesian3());
                                    midpoint = that.updatePositionsHeightByAttr(midpoint);
                                    if (clampToGround) {
                                        //贴地时求贴模型和贴地的高度 
                                        midpoint = (0, _point.setPositionSurfaceHeight)(that.viewer, midpoint);
                                    }
                                    that.draggers[draggersIdx].position = midpoint;
                                }

                                //与后一个点之间的中点
                                if (that.hasClosure || !that.hasClosure && dragger.index != len - 1) {
                                    if (dragger.index == len - 1) {
                                        draggersIdx = dragger.index * 2 + 1;
                                        nextPositionIdx = 0;
                                    } else {
                                        draggersIdx = dragger.index * 2 + 1;
                                        nextPositionIdx = dragger.index + 1;
                                    }
                                    var midpoint = Cesium.Cartesian3.midpoint(position, positions[nextPositionIdx], new Cesium.Cartesian3());
                                    midpoint = that.updatePositionsHeightByAttr(midpoint);
                                    if (clampToGround) {
                                        //贴地时求贴模型和贴地的高度 
                                        midpoint = (0, _point.setPositionSurfaceHeight)(that.viewer, midpoint);
                                    }
                                    that.draggers[draggersIdx].position = midpoint;
                                }
                            }

                            //============整体平移移动点处理============= 
                            positionMove = (0, _point.centerOfMass)(positions);
                            positionMove = that.updatePositionsHeightByAttr(positionMove);
                            if (clampToGround) {
                                //贴地时求贴模型和贴地的高度
                                positionMove = (0, _point.setPositionSurfaceHeight)(that.viewer, positionMove);
                            }
                            draggerMove.position = positionMove;
                        }
                    }
                });
                dragger.index = i;
                this.draggers.push(dragger);

                //中间点，拖动后新增点
                if (hasMidPoint && (this.hasClosure || !this.hasClosure && i < len - 1)) {
                    var nextIndex = (i + 1) % len;
                    var midpoint = Cesium.Cartesian3.midpoint(loc, positions[nextIndex], new Cesium.Cartesian3());
                    midpoint = that.updatePositionsHeightByAttr(midpoint);
                    if (clampToGround) {
                        //贴地时求贴模型和贴地的高度 
                        midpoint = (0, _point.setPositionSurfaceHeight)(this.viewer, midpoint);
                    }

                    var draggerMid = draggerCtl.createDragger(this.entityCollection, {
                        position: midpoint,
                        type: draggerCtl.PointType.AddMidPoint,
                        tooltip: _Tooltip.message.dragger.addMidPoint,
                        //clampToGround: clampToGround,
                        onDragStart: function onDragStart(dragger, position) {
                            positions.splice(dragger.index, 0, position); //插入点 
                        },
                        onDrag: function onDrag(dragger, position) {
                            positions[dragger.index] = position;
                        },
                        onDragEnd: function onDragEnd(dragger, position) {
                            that.updateDraggers();
                        }
                    });
                    draggerMid.index = nextIndex;
                    this.draggers.push(draggerMid);
                }
            }

            //整体平移移动点 
            var positionMove = (0, _point.centerOfMass)(positions);
            positionMove = this.updatePositionsHeightByAttr(positionMove);
            if (clampToGround) {
                //贴地时求贴模型和贴地的高度
                positionMove = (0, _point.setPositionSurfaceHeight)(this.viewer, positionMove);
            }

            var draggerMove = draggerCtl.createDragger(this.entityCollection, {
                position: positionMove,
                type: draggerCtl.PointType.MoveAll,
                tooltip: _Tooltip.message.dragger.moveAll,
                onDrag: function onDrag(dragger, position) {
                    // dragger.position = position;

                    //记录差值 
                    var diff = Cesium.Cartesian3.subtract(position, positionMove, new Cesium.Cartesian3());
                    positionMove = position;

                    positions.forEach(function (pos, index, arr) {
                        var newPos = Cesium.Cartesian3.add(pos, diff, new Cesium.Cartesian3());
                        positions[index] = newPos;
                    });

                    //=====全部更新========== 
                    that.updateDraggers();
                }
            });
            this.draggers.push(draggerMove);

            //创建高程拖拽点
            if (this.getGraphic().extrudedHeight) this.bindHeightDraggers();
        }
        //子类用，高度调整拖拽点  

    }, {
        key: 'bindHeightDraggers',
        value: function bindHeightDraggers(positions) {
            var that = this;

            this.heightDraggers = [];

            positions = positions || this.getPosition();
            var extrudedHeight = that.getGraphic().extrudedHeight.getValue(this.viewer.clock.currentTime);

            for (var i = 0, len = positions.length; i < len; i++) {
                var loc = positions[i];
                loc = (0, _point.setPositionsHeight)(loc, extrudedHeight);

                var dragger = draggerCtl.createDragger(this.entityCollection, {
                    position: loc,
                    type: draggerCtl.PointType.MoveHeight,
                    tooltip: _Tooltip.message.dragger.moveHeight,
                    onDrag: function onDrag(dragger, position) {
                        var thisHeight = Cesium.Cartographic.fromCartesian(position).height;
                        that.getGraphic().extrudedHeight = thisHeight;

                        var maxHeight = (0, _point.getMaxHeight)(that.getPosition());
                        that.entity.attribute.style.extrudedHeight = that.formatNum(thisHeight - maxHeight, 2);

                        that.updateHeightDraggers(thisHeight);
                    }
                });

                this.draggers.push(dragger);
                this.heightDraggers.push(dragger);
            }
        }
    }, {
        key: 'updateHeightDraggers',
        value: function updateHeightDraggers(extrudedHeight) {
            for (var i = 0; i < this.heightDraggers.length; i++) {
                var heightDragger = this.heightDraggers[i];

                var position = (0, _point.setPositionsHeight)((0, _point.getPositionValue)(heightDragger.position, this.viewer.clock.currentTime), extrudedHeight);
                heightDragger.position.setValue(position);
            }
        }
    }]);

    return EditPolyline;
}(_Edit.EditBase);

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureBase = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _index = __webpack_require__(20);

var _Draw = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//显示测量结果文本的字体
var defaultLabelStyle = (0, _index.getDefStyle)("label", {
    "color": "#ffffff",
    "font_size": 20,
    "border": true,
    "border_color": "#000000",
    "border_width": 3,
    "background": true,
    "background_color": "#000000",
    "background_opacity": 0.5,
    "scaleByDistance": true,
    "scaleByDistance_far": 800000,
    "scaleByDistance_farValue": 0.5,
    "scaleByDistance_near": 1000,
    "scaleByDistance_nearValue": 1,
    "pixelOffset": [0, -15],
    "visibleDepth": false //一直显示，不被地形等遮挡
});

var MeasureBase = exports.MeasureBase = function (_MarsClass) {
    _inherits(MeasureBase, _MarsClass);

    //========== 构造方法 ========== 
    function MeasureBase(options, target) {
        _classCallCheck(this, MeasureBase);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (MeasureBase.__proto__ || Object.getPrototypeOf(MeasureBase)).call(this, options));

        if (options instanceof Cesium.Viewer) {
            target.viewer = options;
            options = target;
            target = null;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.viewer = options.viewer;
        _this.config = options;
        _this.target = target || _this; //用于抛出的事件对象

        //文本样式
        if (Cesium.defined(options.label)) {
            _this.labelStyle = _extends({}, defaultLabelStyle, options.label);
        } else {
            _this.labelStyle = _extends({}, defaultLabelStyle);
        }

        //标绘对象
        _this.drawControl = options.draw;
        if (!_this.drawControl) {
            _this.drawControl = new _Draw.Draw(viewer, _extends({
                hasEdit: false
            }, options));
            _this.hasDelDraw = true;
        }

        _this._bindEvent();
        return _this;
    }

    _createClass(MeasureBase, [{
        key: '_bindEvent',
        value: function _bindEvent() {
            var _this2 = this;

            //事件监听
            this.drawControl.on(_Draw.Draw.event.drawAddPoint, function (e) {
                var entity = e.entity;
                if (entity.type != _this2.type) return;
                _this2.entity = entity;
                _this2.showAddPointLength(entity);

                _this2.target.fire(_Draw.Draw.event.drawAddPoint, e);
            });
            this.drawControl.on(_Draw.Draw.event.drawRemovePoint, function (e) {
                if (e.entity.type != _this2.type) return;
                _this2.showRemoveLastPointLength(e);
                _this2.target.fire(_Draw.Draw.event.drawRemovePoint, e);
            });
            this.drawControl.on(_Draw.Draw.event.drawMouseMove, function (e) {
                var entity = e.entity;
                if (entity.type != _this2.type) return;
                _this2.entity = entity;
                _this2.showMoveDrawing(entity);
                _this2.target.fire(_Draw.Draw.event.drawMouseMove, e);
            });

            this.drawControl.on(_Draw.Draw.event.drawCreated, function (e) {
                var entity = e.entity;
                if (entity.type != _this2.type) return;

                _this2.entity = entity;
                _this2.showDrawEnd(entity);
                _this2.bindDeleteContextmenu(entity);
                _this2.entity = null;
                _this2.target.fire(_Draw.Draw.event.drawCreated, e);
            });
        }
    }, {
        key: 'showAddPointLength',
        value: function showAddPointLength(entity) {}
    }, {
        key: 'showRemoveLastPointLength',
        value: function showRemoveLastPointLength(e) {}
    }, {
        key: 'showMoveDrawing',
        value: function showMoveDrawing(entity) {}
    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {}
    }, {
        key: 'startDraw',
        value: function startDraw(options) {
            var _this3 = this;

            this.options = options || {};
            this.options.style = this.options.style || {};

            //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
            if (this.options.calback) {
                this.target.off(_MarsClass2.eventType.change);
                this.target.on(_MarsClass2.eventType.change, function (e) {
                    _this3.options.calback(e.value, e.label, e);
                });
            }
            if (this.options.onStart) {
                this.target.off(_MarsClass2.eventType.start);
                this.target.on(_MarsClass2.eventType.start, this.options.onStart);
            }
            if (this.options.onEnd) {
                this.target.off(_MarsClass2.eventType.end);
                this.target.on(_MarsClass2.eventType.end, this.options.onEnd);
            }
            //兼容v2.2之前旧版本处理,非升级用户可删除上面代码


            var entity = this._startDraw(this.options);
            entity.type = this.type;
        }
    }, {
        key: '_startDraw',
        value: function _startDraw() {}

        //取消并停止绘制
        //如果上次未完成绘制就单击了新的，清除之前未完成的。

    }, {
        key: 'stopDraw',
        value: function stopDraw() {
            this.clearLastNoEnd();
            this.drawControl.stopDraw();
        }

        //外部控制，完成绘制，比如手机端无法双击结束 

    }, {
        key: 'endDraw',
        value: function endDraw() {
            if (this.entity) {
                this.showMoveDrawing(this.entity);
                this.entity = null;
            }
            this.drawControl.endDraw();
        }

        /*清除测量*/

    }, {
        key: 'clear',
        value: function clear() {
            this.stopDraw();
            this.drawControl.deleteAll();

            this.target.fire(_MarsClass2.eventType.delete, {
                mtype: this.type
            });
        }
    }, {
        key: 'bindDeleteContextmenu',


        //右键菜单
        value: function bindDeleteContextmenu(entity) {
            var that = this;
            entity.contextmenuItems = entity.contextmenuItems || [];
            entity.contextmenuItems.push({
                text: '删除测量',
                iconCls: 'fa fa-trash-o',
                visible: function visible(e) {
                    that.drawControl.closeTooltip();

                    var entity = e.target;
                    if (entity.inProgress && !entity.editing) return false;else return true;
                },
                callback: function callback(e) {
                    var entity = e.target;

                    if (Cesium.defined(entity._totalLable)) {
                        that.dataSource.entities.remove(entity._totalLable);
                        delete entity._totalLable;
                    }
                    if (Cesium.defined(entity.arrEntityEx) && entity.arrEntityEx.length > 0) {
                        var arrLables = entity.arrEntityEx;
                        if (arrLables && arrLables.length > 0) {
                            for (var i = 0, len = arrLables.length; i < len; i++) {
                                that.dataSource.entities.remove(arrLables[i]);
                            }
                        }
                        delete entity.arrEntityEx;
                    }
                    if (entity._exLine) {
                        that.dataSource.entities.remove(entity._exLine);
                        delete entity._exLine;
                    }

                    that.drawControl.deleteEntity(entity);

                    that.drawControl.closeTooltip();
                    that.viewer.mars.popup.close();

                    that.target.fire(_MarsClass2.eventType.delete, {
                        mtype: that.type,
                        entity: entity
                    });
                }
            });
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.clear();

            if (this.hasDelDraw) {
                this.drawControl.destroy();
                delete this.drawControl;
            }
            _get(MeasureBase.prototype.__proto__ || Object.getPrototypeOf(MeasureBase.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'draw',
        get: function get() {
            return this.drawControl;
        }
    }, {
        key: 'dataSource',
        get: function get() {
            return this.drawControl.dataSource;
        }
    }]);

    return MeasureBase;
}(_MarsClass2.MarsClass);
//[静态属性]本类中支持的事件类型常量


MeasureBase.event = {
    start: _MarsClass2.eventType.start,
    change: _MarsClass2.eventType.change,
    end: _MarsClass2.eventType.end,
    delete: _MarsClass2.eventType.delete
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getCenter = getCenter;
exports.updateMatrix = updateMatrix;
exports.pick3DTileset = pick3DTileset;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//获取模型的中心点信息
//3dtiles相关计算常用方法
function getCenter(tileset, transform) {
    var result = {};

    //记录模型原始的中心点
    var boundingSphere = tileset.boundingSphere;
    var position = boundingSphere.center;
    var catographic = Cesium.Cartographic.fromCartesian(position);

    var height = Number(catographic.height.toFixed(2));
    var longitude = Number(Cesium.Math.toDegrees(catographic.longitude).toFixed(6));
    var latitude = Number(Cesium.Math.toDegrees(catographic.latitude).toFixed(6));
    result = { x: longitude, y: latitude, z: height };

    marslog.log("模型内部原始位置:" + JSON.stringify(result));

    //如果tileset自带世界矩阵矩阵，那么计算放置的经纬度和heading
    if (transform) {
        var matrix = Cesium.Matrix4.fromArray(tileset._root.transform);
        var pos = Cesium.Matrix4.getTranslation(matrix, new Cesium.Cartesian3());
        var wpos = Cesium.Cartographic.fromCartesian(pos);
        if (Cesium.defined(wpos)) {
            result.x = Number(Cesium.Math.toDegrees(wpos.longitude).toFixed(6));
            result.y = Number(Cesium.Math.toDegrees(wpos.latitude).toFixed(6));
            result.z = Number(wpos.height.toFixed(2));

            //取旋转矩阵
            var rotmat = Cesium.Matrix4.getMatrix3(matrix, new Cesium.Matrix3());
            //默认的旋转矩阵
            var defrotmat = Cesium.Matrix4.getMatrix3(Cesium.Transforms.eastNorthUpToFixedFrame(pos), new Cesium.Matrix3());

            //计算rotmat 的x轴，在defrotmat 上 旋转
            var xaxis = Cesium.Matrix3.getColumn(defrotmat, 0, new Cesium.Cartesian3());
            var yaxis = Cesium.Matrix3.getColumn(defrotmat, 1, new Cesium.Cartesian3());
            var zaxis = Cesium.Matrix3.getColumn(defrotmat, 2, new Cesium.Cartesian3());

            var dir = Cesium.Matrix3.getColumn(rotmat, 0, new Cesium.Cartesian3());

            dir = Cesium.Cartesian3.cross(dir, zaxis, dir);
            dir = Cesium.Cartesian3.cross(zaxis, dir, dir);
            dir = Cesium.Cartesian3.normalize(dir, dir);

            var heading = Cesium.Cartesian3.angleBetween(xaxis, dir);

            var ay = Cesium.Cartesian3.angleBetween(yaxis, dir);

            if (ay > Math.PI * 0.5) {
                heading = 2 * Math.PI - heading;
            }
            result.rotation_x = 0;
            result.rotation_y = 0;
            result.rotation_z = Number(Cesium.Math.toDegrees(heading).toFixed(1));

            result.heading = result.rotation_z; //兼容v1老版本

            marslog.log("模型内部世界矩阵:" + JSON.stringify(result));
        }
    }

    return result;
}

//变换轴，兼容旧版本数据z轴方向不对的情况
//如果可以修改模型json源文件，可以在json文件里面加了一行来修正："gltfUpAxis" : "Z", 
function updateAxis(matrix, axis) {
    if (axis == null) return matrix;

    var rightaxis;
    switch (axis.toUpperCase()) {
        case "Y_UP_TO_Z_UP":
            rightaxis = Cesium.Axis.Y_UP_TO_Z_UP;
            break;
        case "Z_UP_TO_Y_UP":
            rightaxis = Cesium.Axis.Z_UP_TO_Y_UP;
            break;
        case "X_UP_TO_Z_UP":
            rightaxis = Cesium.Axis.X_UP_TO_Z_UP;
            break;
        case "Z_UP_TO_X_UP":
            rightaxis = Cesium.Axis.Z_UP_TO_X_UP;
            break;
        case "X_UP_TO_Y_UP":
            rightaxis = Cesium.Axis.X_UP_TO_Y_UP;
            break;
        case "Y_UP_TO_X_UP":
            rightaxis = Cesium.Axis.Y_UP_TO_X_UP;
            break;
    }
    if (rightaxis == null) return matrix;

    return Cesium.Matrix4.multiplyTransformation(matrix, rightaxis, matrix);
}

//变换模型位置等
function updateMatrix(tileset, opts) {
    var matrix;

    //有自带世界矩阵矩阵 
    if (Cesium.defined(tileset._root) && Cesium.defined(tileset._root.transform) && opts.transform) {

        //平移
        var position = Cesium.Cartesian3.fromDegrees(opts.x, opts.y, opts.z);
        matrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);

        //旋转 
        var mx = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(opts.rotation_x || 0));
        var my = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(opts.rotation_y || 0));
        var mz = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(opts.rotation_z || 0));
        var rotationX = Cesium.Matrix4.fromRotationTranslation(mx);
        var rotationY = Cesium.Matrix4.fromRotationTranslation(my);
        var rotationZ = Cesium.Matrix4.fromRotationTranslation(mz);

        //旋转、平移矩阵相乘
        Cesium.Matrix4.multiply(matrix, rotationX, matrix);
        Cesium.Matrix4.multiply(matrix, rotationY, matrix);
        Cesium.Matrix4.multiply(matrix, rotationZ, matrix);

        //缩放
        if (opts.scale > 0 && opts.scale != 1) //缩放比例
            Cesium.Matrix4.multiplyByUniformScale(matrix, opts.scale, matrix);

        //变换轴
        if (opts.axis) matrix = updateAxis(matrix, opts.axis);

        tileset._root.transform = matrix;
    } else {
        //普通,此种方式[x，y不能多次更改]
        var boundingSphere = tileset.boundingSphere;
        var catographic = Cesium.Cartographic.fromCartesian(boundingSphere.center);
        var surface = Cesium.Cartesian3.fromRadians(catographic.longitude, catographic.latitude, 0.0);
        var offset = Cesium.Cartesian3.fromDegrees(opts.x, opts.y, opts.z);

        var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3());
        matrix = Cesium.Matrix4.fromTranslation(translation);

        tileset.modelMatrix = matrix;
    }
    return matrix;
}

//获取坐标点处的3dtiles模型，用于计算贴地时进行判断（和视角有关系，不一定精确）
function pick3DTileset(scene, positions) {
    if (!positions) return null;

    if (scene instanceof Cesium.Viewer) //兼容scene传入viewer
        scene = scene.scene;

    //判断场景下是否有3dtiles模型 
    // var has3dtiles = false;
    // for (var i = 0, len = scene.primitives.length; i < len; ++i) {
    //     var p = scene.primitives.get(i);
    //     if (p instanceof Cesium.Cesium3DTileset) {
    //         has3dtiles = true;
    //         break;
    //     }
    // }
    // if (!has3dtiles) return null; //没有3dtiles模型时，直接return

    if (positions instanceof Cesium.Cartesian3) positions = [positions];

    for (var i = 0, len = positions.length; i < len; ++i) {
        var position = positions[i];
        var coorPX = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position);
        if (!Cesium.defined(coorPX)) continue;

        var pickedObject = scene.pick(coorPX, 10, 10);
        if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.primitive) && pickedObject.primitive instanceof Cesium.Cesium3DTileset) {
            // Cesium.defined(pickedObject.primitive.isCesium3DTileset)
            return pickedObject.primitive;
        }
    }

    return null;
}

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditBase = exports.EditBase = function (_MarsClass) {
    _inherits(EditBase, _MarsClass);

    //========== 构造方法 ========== 
    function EditBase(entity, viewer) {
        _classCallCheck(this, EditBase);

        var _this = _possibleConstructorReturn(this, (EditBase.__proto__ || Object.getPrototypeOf(EditBase)).call(this));

        _this.entity = entity;
        _this.viewer = viewer;

        _this.draggers = [];
        _this._minPointNum = 1; //至少需要点的个数 (值是draw中传入)
        _this._maxPointNum = 9999; //最多允许点的个数 (值是draw中传入)
        return _this;
    }

    _createClass(EditBase, [{
        key: 'fire',
        value: function fire(type, data, propagate) {
            if (this._fire) this._fire(type, data, propagate);
        }
    }, {
        key: 'formatNum',
        value: function formatNum(num, digits) {
            return (0, _point.formatNum)(num, digits);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(val) {
            this.viewer._container.style.cursor = val ? 'crosshair' : '';
        }
        //激活绘制

    }, {
        key: 'activate',
        value: function activate() {
            if (this._enabled) {
                return this;
            }
            this._enabled = true;

            this.entity.inProgress = true;
            this.changePositionsToCallback();
            this.bindDraggers();
            this.bindEvent();

            this.fire(_MarsClass2.eventType.editStart, { edittype: this.entity.attribute.type, entity: this.entity });

            return this;
        }
        //释放绘制

    }, {
        key: 'disable',
        value: function disable() {
            if (!this._enabled) {
                return this;
            }
            this._enabled = false;

            this.destroyEvent();
            this.destroyDraggers();
            this.finish();

            this.entity.inProgress = false;
            this.fire(_MarsClass2.eventType.editStop, { edittype: this.entity.attribute.type, entity: this.entity });
            this.tooltip.setVisible(false);

            return this;
        }
    }, {
        key: 'changePositionsToCallback',
        value: function changePositionsToCallback() {}
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {}
        //拖拽点 事件

    }, {
        key: 'bindEvent',
        value: function bindEvent() {
            var _this2 = this;

            var scratchBoundingSphere = new Cesium.BoundingSphere();
            var zOffset = new Cesium.Cartesian3();

            var draggerHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.canvas);
            draggerHandler.dragger = null;

            //选中后拖动
            draggerHandler.setInputAction(function (event) {
                var pickedObject = _this2.viewer.scene.pick(event.position);
                if (Cesium.defined(pickedObject)) {
                    var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;
                    if (entity && Cesium.defaultValue(entity._isDragger, false)) {
                        _this2.viewer.scene.screenSpaceCameraController.enableRotate = false;
                        _this2.viewer.scene.screenSpaceCameraController.enableTilt = false;
                        _this2.viewer.scene.screenSpaceCameraController.enableTranslate = false;
                        _this2.viewer.scene.screenSpaceCameraController.enableInputs = false;

                        if (_this2.viewer.mars && _this2.viewer.mars.popup) _this2.viewer.mars.popup.close(entity);

                        draggerHandler.dragger = entity;
                        draggerHandler.dragger.show = Cesium.defaultValue(entity._drawShow, false);

                        _this2.setCursor(true);

                        if (draggerHandler.dragger.onDragStart) {
                            var position = (0, _point.getPositionValue)(draggerHandler.dragger.position);
                            draggerHandler.dragger.onDragStart(draggerHandler.dragger, position);
                        }

                        _this2.fire(_MarsClass2.eventType.editMouseDown, {
                            edittype: _this2.entity.attribute.type,
                            entity: _this2.entity,
                            position: event.position
                        });
                    }
                }
            }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

            draggerHandler.setInputAction(function (event) {
                var dragger = draggerHandler.dragger;
                if (dragger) {
                    switch (dragger._pointType) {
                        case draggerCtl.PointType.MoveHeight:
                            //改变高度垂直拖动
                            var dy = event.endPosition.y - event.startPosition.y;

                            var position = (0, _point.getPositionValue)(dragger.position, _this2.viewer.clock.currentTime);
                            var tangentPlane = new Cesium.EllipsoidTangentPlane(position);

                            scratchBoundingSphere.center = position;
                            scratchBoundingSphere.radius = 1;

                            var metersPerPixel = _this2.viewer.scene.frameState.camera.getPixelSize(scratchBoundingSphere, _this2.viewer.scene.frameState.context.drawingBufferWidth, _this2.viewer.scene.frameState.context.drawingBufferHeight) * 1.5;

                            Cesium.Cartesian3.multiplyByScalar(tangentPlane.zAxis, -dy * metersPerPixel, zOffset);
                            var newPosition = Cesium.Cartesian3.clone(position);
                            Cesium.Cartesian3.add(position, zOffset, newPosition);

                            dragger.position = newPosition;
                            if (dragger.onDrag) {
                                dragger.onDrag(dragger, newPosition, position);
                            }
                            _this2.updateAttrForEditing();
                            break;
                        default:
                            //默认修改位置
                            _this2.tooltip.showAt(event.endPosition, _Tooltip.message.edit.end);

                            var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.endPosition, _this2.entity);

                            if (point) {
                                dragger.position = point;
                                if (dragger.onDrag) {
                                    dragger.onDrag(dragger, point);
                                }
                                _this2.updateAttrForEditing();
                            }
                            break;
                    }
                    _this2.fire(_MarsClass2.eventType.editMouseMove, {
                        edittype: _this2.entity.attribute.type,
                        entity: _this2.entity,
                        position: event.endPosition
                    });
                } else {
                    _this2.tooltip.setVisible(false);

                    var pickedObject = _this2.viewer.scene.pick(event.endPosition);
                    if (Cesium.defined(pickedObject)) {
                        var entity = pickedObject.id;
                        if (entity && Cesium.defaultValue(entity._isDragger, false) && entity.draw_tooltip) {
                            var draw_tooltip = entity.draw_tooltip;

                            //可删除时，提示右击删除
                            if (draggerCtl.PointType.Control == entity._pointType && _this2._positions_draw && _this2._positions_draw.length && _this2._positions_draw.length > _this2._minPointNum) draw_tooltip += _Tooltip.message.del.def;

                            if (_this2.viewer.mars.contextmenu && _this2.viewer.mars.contextmenu.show && _this2.viewer.mars.contextmenu.target == entity) {
                                //删除右键菜单打开了不显示tooltip

                            } else {
                                _this2.tooltip.showAt(event.endPosition, draw_tooltip);
                            }
                        }
                    }
                }
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

            draggerHandler.setInputAction(function (event) {
                var dragger = draggerHandler.dragger;
                if (dragger) {
                    _this2.setCursor(false);
                    dragger.show = true;

                    var position = (0, _point.getPositionValue)(dragger.position, _this2.viewer.clock.currentTime);

                    if (dragger.onDragEnd) {
                        dragger.onDragEnd(dragger, position);
                    }
                    _this2.fire(_MarsClass2.eventType.editMovePoint, { edittype: _this2.entity.attribute.type, entity: _this2.entity, position: position });

                    draggerHandler.dragger = null;

                    _this2.viewer.scene.screenSpaceCameraController.enableRotate = true;
                    _this2.viewer.scene.screenSpaceCameraController.enableTilt = true;
                    _this2.viewer.scene.screenSpaceCameraController.enableTranslate = true;
                    _this2.viewer.scene.screenSpaceCameraController.enableInputs = true;
                }
            }, Cesium.ScreenSpaceEventType.LEFT_UP);

            //右击删除一个点
            draggerHandler.setInputAction(function (event) {
                //右击删除上一个点
                var pickedObject = _this2.viewer.scene.pick(event.position);
                if (Cesium.defined(pickedObject)) {
                    var entity = pickedObject.id;
                    if (entity && Cesium.defaultValue(entity._isDragger, false) && draggerCtl.PointType.Control == entity._pointType) {
                        var isDelOk = _this2.deletePointForDragger(entity, event.position);

                        if (isDelOk) _this2.fire(_MarsClass2.eventType.editRemovePoint, { edittype: _this2.entity.attribute.type, entity: _this2.entity });
                    }
                }
            }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

            this.draggerHandler = draggerHandler;
        }
    }, {
        key: 'destroyEvent',
        value: function destroyEvent() {
            this.viewer.scene.screenSpaceCameraController.enableRotate = true;
            this.viewer.scene.screenSpaceCameraController.enableTilt = true;
            this.viewer.scene.screenSpaceCameraController.enableTranslate = true;
            this.viewer.scene.screenSpaceCameraController.enableInputs = true;

            this.setCursor(false);

            if (this.draggerHandler) {
                if (this.draggerHandler.dragger) this.draggerHandler.dragger.show = true;

                this.draggerHandler.destroy();
                this.draggerHandler = null;
            }
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {}
    }, {
        key: 'updateDraggers',
        value: function updateDraggers() {
            if (!this._enabled) {
                return this;
            }

            this.destroyDraggers();
            this.bindDraggers();
        }
    }, {
        key: 'destroyDraggers',
        value: function destroyDraggers() {
            for (var i = 0, len = this.draggers.length; i < len; i++) {
                this.entityCollection.remove(this.draggers[i]);
            }
            this.draggers = [];
        }
        //删除点

    }, {
        key: 'deletePointForDragger',
        value: function deletePointForDragger(dragger, position) {
            if (!this._positions_draw) return;
            if (this._positions_draw.length - 1 < this._minPointNum) {
                this.tooltip.showAt(position, _Tooltip.message.del.min + this._minPointNum);
                return false;
            }

            var index = dragger.index;
            if (index >= 0 && index < this._positions_draw.length) {
                this._positions_draw.splice(index, 1);
                this.updateDraggers();
                this.updateAttrForEditing();
                return true;
            } else {
                return false;
            }
        }
    }, {
        key: 'updateAttrForEditing',
        value: function updateAttrForEditing() {}
    }, {
        key: 'destroy',
        value: function destroy() {
            this.disable();
            _get(EditBase.prototype.__proto__ || Object.getPrototypeOf(EditBase.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'entityCollection',
        get: function get() {
            return this.entity.entityCollection;
        }
    }]);

    return EditBase;
}(_MarsClass2.MarsClass);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditPolygon = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Attr = __webpack_require__(21);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(25);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPolygon = exports.EditPolygon = function (_EditPolyline) {
    _inherits(EditPolygon, _EditPolyline);

    //========== 构造方法 ========== 
    function EditPolygon(entity, viewer) {
        _classCallCheck(this, EditPolygon);

        //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
        var _this = _possibleConstructorReturn(this, (EditPolygon.__proto__ || Object.getPrototypeOf(EditPolygon)).call(this, entity, viewer));

        _this.hasClosure = true;
        return _this;
    }

    //取enity对象的对应矢量数据


    _createClass(EditPolygon, [{
        key: 'getGraphic',
        value: function getGraphic() {
            return this.entity.polygon;
        }
        //修改坐标会回调，提高显示的效率

    }, {
        key: 'changePositionsToCallback',
        value: function changePositionsToCallback() {
            this._positions_draw = this.entity._positions_draw || attr.getPositions(this.entity);
        }
    }, {
        key: 'isClampToGround',
        value: function isClampToGround() {
            return this.entity.attribute.style.hasOwnProperty('clampToGround') ? this.entity.attribute.style.clampToGround : !this.entity.attribute.style.perPositionHeight;
        }
    }, {
        key: 'updateAttrForEditing',
        value: function updateAttrForEditing() {
            var style = this.entity.attribute.style;
            if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) {
                //存在extrudedHeight高度设置时
                var maxHight = (0, _point.getMaxHeight)(this.getPosition());
                this.getGraphic().extrudedHeight = maxHight + Number(style.extrudedHeight);
            }
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            this.entity._positions_draw = this.getPosition();
        }
    }]);

    return EditPolygon;
}(_Edit.EditPolyline);

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getLength = getLength;
exports.getClampLength = getClampLength;
exports.getArea = getArea;
exports.getAreaOfTriangle = getAreaOfTriangle;
exports.getClampArea = getClampArea;
exports.getAngle = getAngle;
exports.getSlope = getSlope;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _pointconvert = __webpack_require__(4);

var _polygon = __webpack_require__(13);

var _Slope = __webpack_require__(75);

var _turf = __webpack_require__(33);

var _polyline = __webpack_require__(22);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//计算空间距离，单位：米
function getLength(positions) {
    if (!Cesium.defined(positions) || positions.length < 2) return 0;

    var distance = 0;
    for (var i = 1, len = positions.length; i < len; i++) {
        distance += Cesium.Cartesian3.distance(positions[i - 1], positions[i]);
    }
    return distance;
}

//计算计算地表贴地距离，单位：米
function getClampLength(positions, options) {
    var all_distance = 0;
    var arrDistance = [];

    (0, _polyline.computeStepSurfaceLine)({
        scene: options.scene,
        positions: positions,
        splitNum: options.splitNum,
        has3dtiles: options.has3dtiles,
        //计算每个分段后的回调方法
        endItem: function endItem(raisedPositions, noHeight, index) {
            var distance = getLength(raisedPositions);
            if (noHeight && options.disTerrainScale) {
                distance = distance * options.disTerrainScale; //求高度失败，概略估算值
            }
            all_distance += distance;

            arrDistance.push(distance);

            if (options.endItem) options.endItem({
                index: index,
                positions: raisedPositions,
                distance: distance,
                arrDistance: arrDistance,
                all_distance: all_distance
            });
        },
        //计算全部完成的回调方法
        end: function end() {
            var callback = options.callback || options.calback; //兼容不同参数名 
            if (callback) callback(all_distance, arrDistance);
        }
    });
}

//计算地表投影平面面积，单位：平方米
function getArea(positions, noAdd) {
    var coordinates = (0, _pointconvert.cartesians2lonlats)(positions);

    if (!noAdd && coordinates.length > 0) coordinates.push(coordinates[0]);

    //API: http://turfjs.org/docs/#area
    var area = (0, _turf.area)({
        type: "Feature",
        geometry: {
            type: "Polygon",
            coordinates: [coordinates]
        }
    });
    return area;
}

//计算三角形空间面积
function getAreaOfTriangle(pos1, pos2, pos3) {
    var a = Cesium.Cartesian3.distance(pos1, pos2);
    var b = Cesium.Cartesian3.distance(pos2, pos3);
    var c = Cesium.Cartesian3.distance(pos3, pos1);
    var S = (a + b + c) / 2;
    return Math.sqrt(S * (S - a) * (S - b) * (S - c));
}

//计算贴地面积 
function getClampArea(positions, options) {
    function _restultArea(resultInter) {
        var area = 0; //总面积(贴地三角面) 
        for (var i = 0, len = resultInter.list.length; i < len; i++) {
            var item = resultInter.list[i];
            var pt1 = item.point1;
            var pt2 = item.point2;
            var pt3 = item.point3;

            //求面积 
            area += getAreaOfTriangle(pt1.pointDM, pt2.pointDM, pt3.pointDM);
        }
        return area;
    }
    var _callback = options.callback || options.calback; //兼容不同参数名
    var resultInter = (0, _polygon.interPolygon)({
        positions: positions,
        scene: options.scene,
        splitNum: options.splitNum,
        has3dtiles: options.has3dtiles,
        asyn: options.asyn,
        callback: function callback(resultInter) {
            var area = _restultArea(resultInter);
            if (_callback) _callback(area, resultInter);
        }
    });

    if (options.asyn) return null;else {
        var area = _restultArea(resultInter);
        if (_callback) _callback(area, resultInter);
        return area;
    }
}

//求地表方位角，返回：0-360度
function getAngle(firstPoint, endPoints) {
    var carto1 = Cesium.Cartographic.fromCartesian(firstPoint);
    var carto2 = Cesium.Cartographic.fromCartesian(endPoints);
    if (!carto1 || !carto2) return 0;

    var pt1 = {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [Cesium.Math.toDegrees(carto1.longitude), Cesium.Math.toDegrees(carto1.latitude), carto1.height]
        }
    };
    var pt2 = {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [Cesium.Math.toDegrees(carto2.longitude), Cesium.Math.toDegrees(carto2.latitude), carto2.height]
        }
        //API: http://turfjs.org/docs/#rhumbBearing
    };var bearing = Math.round((0, _turf.rhumbBearing)(pt1, pt2));
    return bearing;
}

//求多个点的  坡度坡向
function getSlope(options) {
    var slope = new _Slope.Slope({
        viewer: options.viewer,
        positions: options.positions,
        splitNum: 1,
        radius: options.radius, //缓冲半径（影响坡度坡向的精度）
        count: options.count, //缓冲的数量（影响坡度坡向的精度）会求周边(count*4)个点
        has3dtiles: options.has3dtiles,
        point: Cesium.defaultValue(options.point, { show: false }),
        arrow: Cesium.defaultValue(options.arrow, { show: false })
    });
    if (options.endItem) {
        slope.on(_MarsClass.eventType.endItem, options.endItem);
    }
    slope.on(_MarsClass.eventType.end, function (e) {
        if (options.callback) options.callback(e);
        slope.destroy();
    });
    return slope;
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值
        entityattr = {};
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "silhouette": //跳过扩展其他属性的参数
            case "silhouetteColor":
            case "silhouetteAlpha":
            case "silhouetteSize":
            case "fill":
            case "color":
            case "opacity":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "modelUrl":
                //模型uri
                entityattr.uri = value;
                break;

            case "clampToGround":
                //贴地
                if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
                break;
            case "heightReference":
                switch (value) {
                    case "NONE":
                        entityattr.heightReference = Cesium.HeightReference.NONE;
                        break;
                    case "CLAMP_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                        break;
                    case "RELATIVE_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                        break;
                    default:
                        entityattr.heightReference = value;
                        break;
                }
                break;

            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;

            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
        }
    }

    //轮廓
    if (style.silhouette) {
        entityattr.silhouetteColor = Cesium.Color.fromCssColorString(style.silhouetteColor || "#FFFFFF").withAlpha(Number(style.silhouetteAlpha || 1.0));
        entityattr.silhouetteSize = Number(style.silhouetteSize || 1.0);
    } else entityattr.silhouetteSize = 0.0;

    //透明度、颜色
    var opacity = Cesium.defaultValue(style.opacity, 1);
    if (style.fill) entityattr.color = Cesium.Color.fromCssColorString(style.color || "#FFFFFF").withAlpha(opacity);else entityattr.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(opacity);

    return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
    return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: { type: "Point", coordinates: coordinates[0] }
    };
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.config2Entity = config2Entity;
exports.style2Entity = style2Entity;
exports.createDthEntity = createDthEntity;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(34);

var _Attr2 = __webpack_require__(12);

var _Attr3 = __webpack_require__(31);

var _Attr4 = __webpack_require__(35);

var _Attr5 = __webpack_require__(19);

var _Attr6 = __webpack_require__(21);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var nullColor = new Cesium.Color(0.0, 0.0, 0.0, 0.01);

//根据config配置，更新entitys
function config2Entity(entities, config, lblAddFun) {
    for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];

        //属性 
        if (typeof config.getAttrVal === 'function') {
            var attr = config.getAttrVal(entity);
            entity.properties = attr || {}; //重新绑定，后续使用
        }

        //样式  
        var symbol = config.symbol;
        if (symbol) {
            if (typeof symbol === 'function') {
                //完全自定义的回调方法，自行处理entity
                symbol(entity, entity.properties);
            } else {
                setConfigSymbol(entity, config, lblAddFun);
            }
        }

        //popup、鼠标事件等
        bindMourseEvnet(entity, config);
    }

    return entities;
}

//根据config配置，更新entitys
function style2Entity(entities, style, lblAddFun) {
    for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];
        //样式  
        setConfigSymbol(entity, { symbol: { styleOptions: style }, lblAddFun: lblAddFun });
    }
    return entities;
}

//外部配置的symbol
function setConfigSymbol(entity, config, lblAddFun) {
    var attr = entity.properties;
    if (attr && attr.type && attr.attr) {
        //说明是内部标绘生产的geojson
        attr = attr.attr;
    }
    attr = (0, _util.getAttrVal)(attr);

    var symbol = config.symbol;
    var styleOpt = symbol.styleOptions;

    if (symbol.styleField) {
        //存在多个symbol，按styleField进行分类
        var styleFieldVal = attr[symbol.styleField];
        var styleOptField = symbol.styleFieldOptions[styleFieldVal];
        if (styleOptField != null) {
            styleOpt = (0, _util.clone)(styleOpt);
            styleOpt = _extends({}, styleOpt, styleOptField);
        }
    }

    //外部使用代码示例
    // var layerWork = viewer.mars.getLayer(301087, "id")
    // layerWork.config.symbol.callback = function (attr, entity, styleOpt) {
    //     var val = attr.floor;
    //     if (val < 10)
    //         return { color: "#ff0000" };
    //     else
    //         return { color: "#0000ff" };
    // }
    var callback = symbol.callback || symbol.calback; //兼容不同参数名
    if (typeof callback === 'function') {
        //只是动态返回symbol的自定义的回调方法，返回style
        styleOpt = (0, _util.clone)(styleOpt);
        var styleOptField = callback(attr, entity, styleOpt);
        if (!styleOptField) return;

        styleOpt = _extends({}, styleOpt, styleOptField);
    }
    styleOpt = styleOpt || {};

    //兼容v1历史的 label.field 定义方式
    if (styleOpt.label && styleOpt.label.field) styleOpt.label.text = "{" + styleOpt.label.field + "}";

    var entityCollection = entity.entityCollection; //entity原有的集合

    //添加文本的统一回调方法 ，默认为entity方式，可以外部处理。
    function defaultLblAdd(position, labelattr, attr) {
        if (labelattr.text == "") return null;

        if (Cesium.defined(labelattr.height)) {
            position = (0, _point.setPositionsHeight)(position, labelattr.height);
        }

        var lblEx = entityCollection.add({
            position: position,
            label: labelattr,
            properties: attr
        });
        return lblEx;
    }
    lblAddFun = lblAddFun || defaultLblAdd;

    if (entity.polyline) {
        (0, _Attr5.style2Entity)(styleOpt, entity.polyline);

        //线时，加上文字标签 
        if (styleOpt.label && styleOpt.label.text) {
            if (entity._labelEx) {
                (0, _Attr2.style2Entity)(styleOpt.label, entity._labelEx.label, attr);
            } else {
                //计算中心点
                var pots = (0, _Attr5.getPositions)(entity);
                var position = pots[Math.floor(pots.length / 2)];
                if (styleOpt.label.position) {
                    if (styleOpt.label.position == "center") {
                        position = (0, _point.centerOfMass)(pots, styleOpt.label.height);
                    } else if ((0, _util.isNumber)(styleOpt.label.position)) {
                        position = pots[styleOpt.label.position];
                    }
                }

                //文本属性 
                var labelattr = (0, _Attr2.style2Entity)(styleOpt.label, null, attr);
                labelattr.heightReference = Cesium.defaultValue(labelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                var lblEx = lblAddFun(position, labelattr, attr);
                if (lblEx) bindMourseEvnet(lblEx, config);
                entity._labelEx = lblEx;
            }
        }
    }
    if (entity.polygon) {
        (0, _Attr6.style2Entity)(styleOpt, entity.polygon);
        //是建筑物时
        if (config.buildings) {
            var floor = Number(attr[config.buildings.cloumn] || 1); //层数

            var height = 3.5; //层高
            var heightCfg = config.buildings.height;
            if ((0, _util.isNumber)(heightCfg)) {
                height = heightCfg;
            } else if ((0, _util.isString)(heightCfg)) {
                height = attr[heightCfg] || height;
            }

            entity.polygon.extrudedHeight = floor * height;
        }
        //是建筑物单体化时
        if (config.dth) {
            entity.polygon.classificationType = Cesium.ClassificationType.BOTH;
            if (!Cesium.defined(styleOpt.color)) entity.polygon.material = nullColor;
            entity.polygon.perPositionHeight = false;
            entity.polygon.zIndex = 99;
        }

        //加上线宽
        if (styleOpt.outlineWidth && styleOpt.outlineWidth > 1) {
            entity.polygon.outline = false;
            var outlineStyle = _extends({}, styleOpt, {
                "outline": false,
                "color": styleOpt.outlineColor,
                "width": styleOpt.outlineWidth,
                "opacity": styleOpt.outlineOpacity
            }, styleOpt.outlineStyle || {});
            if (entity._outlineEx) {
                (0, _Attr5.style2Entity)(outlineStyle, entity._outlineEx.polyline);
            } else {
                var polyline = (0, _Attr5.style2Entity)(outlineStyle);
                polyline.positions = (0, _Attr6.getPositions)(entity);
                var lineEx = entityCollection.add({
                    polyline: polyline,
                    properties: attr
                });
                bindMourseEvnet(lineEx, config);
                entity._outlineEx = lineEx;
            }
        }

        //面时，加上文字标签 
        if (styleOpt.label && styleOpt.label.text) {
            if (entity._labelEx) {
                (0, _Attr2.style2Entity)(styleOpt.label, entity._labelEx.label, attr);
            } else {
                //计算中心点 
                var position = (0, _point.centerOfMass)((0, _Attr6.getPositions)(entity), styleOpt.label.height);

                //文本属性            
                var labelattr = (0, _Attr2.style2Entity)(styleOpt.label, null, attr);
                labelattr.heightReference = Cesium.defaultValue(labelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                var lblEx = lblAddFun(position, labelattr, attr);
                if (lblEx) bindMourseEvnet(lblEx, config);
                entity._labelEx = lblEx;
            }
        }
    }

    //entity本身存在文字标签 
    if (entity.label) {
        styleOpt.label = styleOpt.label || styleOpt || {};

        if (!Cesium.defined(styleOpt.label.clampToGround) && !Cesium.defined(styleOpt.label.heightReference)) styleOpt.label.heightReference = Cesium.defaultValue(styleOpt.label.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

        (0, _Attr2.style2Entity)(styleOpt.label, entity.label, attr);
    } else {
        //外部完全自定义的方式
        if (styleOpt.label && typeof styleOpt.label === 'function') {
            styleOpt.label(entity, attr, function (position, styleLbl) {
                //文本属性
                var labelattr = (0, _Attr2.style2Entity)(styleLbl, null, attr);
                labelattr.heightReference = Cesium.defaultValue(labelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                var lblEx = lblAddFun(position, labelattr, attr);
                if (lblEx) bindMourseEvnet(lblEx, config);
            });
        }
    }

    //图标时
    if (entity.billboard) {
        if (!Cesium.defined(styleOpt.clampToGround) && !Cesium.defined(styleOpt.heightReference)) styleOpt.heightReference = Cesium.defaultValue(styleOpt.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);
        // 可采用格式化字符串
        styleOpt.image = (0, _util.template)(styleOpt.image, attr);

        (0, _Attr.style2Entity)(styleOpt, entity.billboard);

        //支持小模型
        if (styleOpt.model) {
            if (entity._modelEx) {
                (0, _Attr3.style2Entity)(styleOpt.model, entity._modelEx.model);
            } else {
                var modelattr = (0, _Attr3.style2Entity)(styleOpt.model);
                modelattr.heightReference = Cesium.defaultValue(modelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                var modelEx = entityCollection.add({
                    position: entity.position,
                    model: modelattr,
                    properties: attr
                });
                bindMourseEvnet(lblEx, config);
                entity._modelEx = modelEx;
            }
        }

        //支持point
        if (styleOpt.point) {
            if (entity._pointEx) {
                (0, _Attr4.style2Entity)(styleOpt.point, entity._pointEx.point);
            } else {
                var modelattr = (0, _Attr4.style2Entity)(styleOpt.point);
                modelattr.heightReference = Cesium.defaultValue(modelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                var pointEx = entityCollection.add({
                    position: entity.position,
                    point: modelattr,
                    properties: attr
                });
                bindMourseEvnet(lblEx, config);
                entity._pointEx = pointEx;
            }
        }

        //加上文字标签 (entity本身不存在label时)
        if (styleOpt.label && styleOpt.label.text && !entity.label) {
            if (entity._labelEx) {
                (0, _Attr2.style2Entity)(styleOpt.label, entity._labelEx.label, attr);
            } else {
                //计算中心点 
                var position = entity.position;

                //文本属性      
                var labelattr = (0, _Attr2.style2Entity)(styleOpt.label, null, attr);
                labelattr.heightReference = Cesium.defaultValue(labelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                var lblEx = lblAddFun(position, labelattr, attr);
                if (lblEx) bindMourseEvnet(lblEx, config);
                entity._labelEx = lblEx;
            }
        }
    }

    //记录下样式配置
    entity.styleOpt = styleOpt;
}

//鼠标事件，popup tooltip
function bindMourseEvnet(entity, config) {
    //popup弹窗
    if (config.columns || config.popup) {
        entity.popup = (0, _util.bindLayerPopup)(config.popup, function (entity) {
            var attr = entity.properties || entity.attribute;
            if (attr && attr.type && attr.attr) {
                //说明是内部标绘生产的geojson
                attr = attr.attr;
            }
            if ((0, _util.isString)(attr)) return attr;else return (0, _util.getPopupForConfig)(config, attr);
        });
    }
    if (config.tooltip) {
        entity.tooltip = (0, _util.bindLayerPopup)(config.tooltip, function (entity) {
            var attr = entity.properties || entity.attribute;
            if (attr && attr.type && attr.attr) {
                //说明是内部标绘生产的geojson
                attr = attr.attr;
            }

            if ((0, _util.isString)(attr)) return attr;else return (0, _util.getPopupForConfig)({ popup: config.tooltip }, attr);
        });
    }

    if (config.eventTarget) {
        entity.eventTarget = config.eventTarget;
    } else {
        if (config.click) {
            entity.click = config.click;
        }
        if (config.mouseover) {
            entity.mouseover = config.mouseover;
        }
        if (config.mouseout) {
            entity.mouseout = config.mouseout;
        }
    }

    if (config.contextmenuItems) {
        entity.contextmenuItems = config.contextmenuItems;
    }
}

//单体化处理 
var nullColor = new Cesium.Color(0.0, 0.0, 0.0, 0.01);
var highlighted_hierarchy; //单体化坐标位置

var highlighColor; //高亮时颜色
var highlightedEntity; //单体化显示的面

function mouseover(entity) {
    //移入 
    highlighted_hierarchy = entity.polygon.hierarchy.getValue((0, _util.currentTime)());
    highlightedEntity.polygon.show = true;

    highlightedEntity.properties = entity.properties;
    highlightedEntity.tooltip = entity.tooltip ? entity.tooltip : null;
    highlightedEntity.popup = entity.popup ? entity.popup : null;
}

function mouseout() {
    //移出
    if (Cesium.defined(highlightedEntity)) {
        highlightedEntity.polygon.show = false;
    }
}

//创建单体化显示的面【每个对象只用一次】
function createDthEntity(dataSource, styleOpt) {
    styleOpt = styleOpt || {};

    if (!highlightedEntity) {
        //高亮时颜色
        highlighColor = Cesium.Color.fromCssColorString(Cesium.defaultValue(styleOpt.color, "#ffff00")).withAlpha(Cesium.defaultValue(styleOpt.opacity, 0.3)); //高亮时颜色

        //单体化显示的面
        highlightedEntity = dataSource.entities.add({
            name: "单体化高亮面",
            noMouseMove: true, //标识下，内部不监听其移入事件 
            polygon: {
                perPositionHeight: false,
                classificationType: Cesium.ClassificationType.BOTH,
                material: highlighColor,
                hierarchy: new Cesium.CallbackProperty(function (time) {
                    return highlighted_hierarchy;
                }, false),
                zIndex: 0
            }
        });
    }

    return {
        mouseover: mouseover,
        mouseout: mouseout
    };
}

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__33__;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值
        entityattr = {
            scale: 1,
            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM
        };
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "scaleByDistance_near": //跳过扩展其他属性的参数
            case "scaleByDistance_nearValue":
            case "scaleByDistance_far":
            case "scaleByDistance_farValue":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "opacity":
                //透明度
                entityattr.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(Cesium.defaultValue(value, 1.0));
                break;
            case "rotation":
                //旋转角度
                entityattr.rotation = Cesium.Math.toRadians(value);
                break;
            case "pixelOffset":
                //偏移量 
                if (Cesium.defined(value[0]) && Cesium.defined(value[1])) entityattr.pixelOffset = new Cesium.Cartesian2(value[0], value[1]);else entityattr.pixelOffset = value;
                break;
            case "scaleByDistance":
                //是否按视距缩放
                if (value) {
                    entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(Cesium.defaultValue(style.scaleByDistance_near, 1000)), Number(Cesium.defaultValue(style.scaleByDistance_nearValue, 1.0)), Number(Cesium.defaultValue(style.scaleByDistance_far, 1000000)), Number(Cesium.defaultValue(style.scaleByDistance_farValue, 0.1)));
                } else {
                    entityattr.scaleByDistance = undefined;
                }
                break;
            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;
            case "clampToGround":
                //贴地
                if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
                break;
            case "heightReference":
                switch (value) {
                    case "NONE":
                        entityattr.heightReference = Cesium.HeightReference.NONE;
                        break;
                    case "CLAMP_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                        break;
                    case "RELATIVE_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                        break;
                    default:
                        entityattr.heightReference = value;
                        break;
                }
                break;
            case "horizontalOrigin":
                switch (value) {
                    case "CENTER":
                        entityattr.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
                        break;
                    case "LEFT":
                        entityattr.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
                        break;
                    case "RIGHT":
                        entityattr.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
                        break;
                    default:
                        entityattr.horizontalOrigin = value;
                        break;
                }
                break;
            case "verticalOrigin":
                switch (value) {
                    case "CENTER":
                        entityattr.verticalOrigin = Cesium.VerticalOrigin.CENTER;
                        break;
                    case "TOP":
                        entityattr.verticalOrigin = Cesium.VerticalOrigin.TOP;
                        break;
                    case "BOTTOM":
                        entityattr.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
                        break;
                    default:
                        entityattr.verticalOrigin = value;
                        break;
                }
                break;
            case "visibleDepth":
                if (value) entityattr.disableDepthTestDistance = 0;else entityattr.disableDepthTestDistance = Number.POSITIVE_INFINITY; //一直显示，不被地形等遮挡

                break;
        }
    }

    return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
    return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: { type: "Point", coordinates: coordinates[0] }
    };
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值
        entityattr = {};
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":
            case "scaleByDistance_near":
            case "scaleByDistance_nearValue":
            case "scaleByDistance_far":
            case "scaleByDistance_farValue":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                break;
            case "color":
                //填充颜色
                entityattr.color = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                break;

            case "pixelOffset":
                //偏移量
                if (Cesium.defined(value[0]) && Cesium.defined(value[1])) entityattr.pixelOffset = new Cesium.Cartesian2(value[0], value[1]);else entityattr.pixelOffset = value;
                break;
            case "scaleByDistance":
                //是否按视距缩放
                if (value) {
                    entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(style.scaleByDistance_near || 1000), Number(style.scaleByDistance_nearValue || 1.0), Number(style.scaleByDistance_far || 1000000), Number(style.scaleByDistance_farValue || 0.1));
                } else {
                    entityattr.scaleByDistance = undefined;
                }
                break;

            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;
            case "clampToGround":
                //贴地
                if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
                break;
            case "heightReference":
                switch (value) {
                    case "NONE":
                        entityattr.heightReference = Cesium.HeightReference.NONE;
                        break;
                    case "CLAMP_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                        break;
                    case "RELATIVE_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                        break;
                    default:
                        entityattr.heightReference = value;
                        break;
                }
                break;

            case "visibleDepth":
                if (value) entityattr.disableDepthTestDistance = 0;else entityattr.disableDepthTestDistance = Number.POSITIVE_INFINITY; //一直显示，不被地形等遮挡

                break;
        }
    }

    //无边框时，需设置宽度为0
    if (!style.outline) entityattr.outlineWidth = 0.0;

    return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
    return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: { type: "Point", coordinates: coordinates[0] }
    };
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureArea = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _measure = __webpack_require__(30);

var measureUtil = _interopRequireWildcard(_measure);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(12);

var _MeasureBase2 = __webpack_require__(26);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureArea = exports.MeasureArea = function (_MeasureBase) {
    _inherits(MeasureArea, _MeasureBase);

    //========== 构造方法 ========== 
    function MeasureArea(opts, target) {
        _classCallCheck(this, MeasureArea);

        var _this = _possibleConstructorReturn(this, (MeasureArea.__proto__ || Object.getPrototypeOf(MeasureArea)).call(this, opts, target));

        _this.totalLable = null; //面积label
        return _this;
    }

    _createClass(MeasureArea, [{
        key: 'clearLastNoEnd',


        //清除未完成的数据
        value: function clearLastNoEnd() {
            if (this.totalLable != null) this.dataSource.entities.remove(this.totalLable);
            this.totalLable = null;
        }
        //开始绘制

    }, {
        key: '_startDraw',
        value: function _startDraw(options) {
            var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
                horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                show: false
            });

            this.totalLable = this.dataSource.entities.add({
                label: entityattr,
                _noMousePosition: true,
                attribute: {
                    unit: options.unit,
                    type: options.type
                }
            });

            return this.drawControl.startDraw({
                type: "polygon",
                style: _extends({
                    color: "#00fff2",
                    outline: true,
                    outlineColor: "#fafa5a",
                    outlineWidth: 1,
                    opacity: 0.4,
                    clampToGround: false }, options.style)
            });
        }
        //绘制增加一个点后，显示该分段的长度

    }, {
        key: 'showAddPointLength',
        value: function showAddPointLength(entity) {
            this.showMoveDrawing(entity); //兼容手机端
        }
        //绘制中删除了最后一个点

    }, {
        key: 'showRemoveLastPointLength',
        value: function showRemoveLastPointLength(e) {
            var positions = this.drawControl.getPositions(e.entity);
            if (positions.length < 3) {
                this.totalLable.label.show = false;
            }
        }
        //绘制过程移动中，动态显示长度信息

    }, {
        key: 'showMoveDrawing',
        value: function showMoveDrawing(entity) {
            var positions = this.drawControl.getPositions(entity);
            if (positions.length < 3) {
                this.totalLable.label.show = false;
                return;
            }

            var area = measureUtil.getArea(positions);
            this.totalLable.attribute.value = area;
            this.totalLable.showText = function (unit) {
                var areastr = util.formatArea(this.attribute.value, unit);
                this.label.text = "面积:" + areastr;
                return areastr;
            };
            var areastr = this.totalLable.showText(this.options.unit);

            //求中心点  
            var ptcenter = (0, _point.centerOfMass)(positions);
            this.totalLable.position = ptcenter;
            this.totalLable.label.show = true;

            this.target.fire(_MarsClass.eventType.change, {
                mtype: this.type,
                value: area,
                label: areastr
            });
        }
        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            if (entity.polygon == null) return;

            entity._totalLable = this.totalLable;
            this.totalLable = null;

            this.target.fire(_MarsClass.eventType.end, {
                mtype: this.type,
                entity: entity,
                value: entity._totalLable.attribute.value
            });
        }
    }, {
        key: 'type',
        get: function get() {
            return "area";
        }
    }]);

    return MeasureArea;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureLength = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _measure = __webpack_require__(30);

var measureUtil = _interopRequireWildcard(_measure);

var _Attr = __webpack_require__(12);

var _MeasureBase2 = __webpack_require__(26);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureLength = exports.MeasureLength = function (_MeasureBase) {
    _inherits(MeasureLength, _MeasureBase);

    //========== 构造方法 ========== 
    function MeasureLength(opts, target) {
        _classCallCheck(this, MeasureLength);

        var _this = _possibleConstructorReturn(this, (MeasureLength.__proto__ || Object.getPrototypeOf(MeasureLength)).call(this, opts, target));

        _this.arrLables = []; //各线段label
        _this.totalLable = null; //总长label 
        _this.disTerrainScale = 1.2; //贴地时的概略比例
        return _this;
    }

    _createClass(MeasureLength, [{
        key: 'clearLastNoEnd',

        //清除未完成的数据
        value: function clearLastNoEnd() {
            if (Cesium.defined(this.totalLable)) this.dataSource.entities.remove(this.totalLable);
            if (Cesium.defined(this.arrLables) && this.arrLables.length > 0) {
                var arrLables = this.arrLables;
                if (arrLables && arrLables.length > 0) {
                    for (var i = 0, len = arrLables.length; i < len; i++) {
                        this.dataSource.entities.remove(arrLables[i]);
                    }
                }
            }
            this.totalLable = null;
            this.arrLables = [];
        }

        //开始绘制

    }, {
        key: '_startDraw',
        value: function _startDraw(options) {
            this.stopDraw();

            //总长label 
            var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
                horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                show: false
            });
            this.totalLable = this.dataSource.entities.add({
                label: entityattr,
                _noMousePosition: true,
                attribute: {
                    unit: options.unit,
                    type: options.type
                }
            });
            this.arrLables = [];

            return this.drawControl.startDraw({
                type: "polyline",
                config: {
                    addHeight: options.addHeight,
                    maxPointNum: options.maxPointNum
                },
                style: _extends({
                    "lineType": "glow",
                    "color": "#ebe12c",
                    "width": 9,
                    "glowPower": 0.1,
                    "clampToGround": false, //是否贴地 
                    "depthFail": true,
                    "depthFailColor": "#ebe12c"
                }, options.style)
            });
        }

        //绘制增加一个点后，显示该分段的长度

    }, {
        key: 'showAddPointLength',
        value: function showAddPointLength(entity) {
            var positions = this.drawControl.getPositions(entity);

            var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
                horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                show: true
            });

            var tempSingleLabel = this.dataSource.entities.add({
                position: positions[positions.length - 1],
                label: entityattr,
                _noMousePosition: true,
                attribute: {
                    unit: this.options.unit,
                    type: this.options.type
                }
            });

            if (positions.length == 1) {
                tempSingleLabel.label.text = "起点";
                //tempSingleLabel.attribute.value = 0;
            } else {
                var distance = measureUtil.getLength(positions);
                var lastLen = measureUtil.getLength([positions[positions.length - 2], positions[positions.length - 1]]); //最后2点间距离
                //屏蔽比较小的数值
                // if (lastLen < 5)
                //     tempSingleLabel.show = false;

                tempSingleLabel.attribute.value = distance;
                tempSingleLabel.attribute.valueFD = lastLen;
                tempSingleLabel.showText = function (unit) {
                    var distancestr = util.formatLength(this.attribute.value, unit);
                    if (this.attribute.value != this.attribute.valueFD) {
                        var lastLenStr = util.formatLength(this.attribute.valueFD, unit);
                        this.label.text = distancestr + "\n(+" + lastLenStr + ")";
                    } else {
                        this.label.text = distancestr;
                    }
                };
                tempSingleLabel.showText(this.options.unit);
            }
            this.arrLables.push(tempSingleLabel);
        }
    }, {
        key: 'showRemoveLastPointLength',
        value: function showRemoveLastPointLength(e) {
            var label = this.arrLables.pop();
            this.dataSource.entities.remove(label);

            this.showMoveDrawing(e.entity);
            this.totalLable.position = e.position;
        }
        //绘制过程移动中，动态显示长度信息

    }, {
        key: 'showMoveDrawing',
        value: function showMoveDrawing(entity) {
            var positions = this.drawControl.getPositions(entity);
            if (positions.length < 2) {
                this.totalLable.label.show = false;
                return;
            }

            var distance = measureUtil.getLength(positions);
            var distancestr = util.formatLength(distance, this.options.unit);

            //最后2点间距离
            var lastLen = measureUtil.getLength([positions[positions.length - 2], positions[positions.length - 1]]);
            if (lastLen == 0 && positions.length > 2) {
                lastLen = measureUtil.getLength([positions[positions.length - 3], positions[positions.length - 2]]);
            }
            this.totalLable.attribute.value = distance;
            this.totalLable.attribute.valueFD = lastLen;
            this.totalLable.showText = function (unit) {
                var distancestr = util.formatLength(this.attribute.value, unit);
                if (this.attribute.value != this.attribute.valueFD) {
                    var lastLenStr = util.formatLength(this.attribute.valueFD, unit);
                    this.label.text = "总长:" + distancestr + "\n(+" + lastLenStr + ")";
                } else {
                    this.label.text = "总长:" + distancestr;
                }
            };
            this.totalLable.showText(this.options.unit);
            this.totalLable.position = positions[positions.length - 1];
            this.totalLable.label.show = true;

            this.target.fire(_MarsClass.eventType.change, {
                mtype: this.type,
                value: distance,
                label: distancestr
            });
        }
        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            var positions = this.drawControl.getPositions(entity);
            var count = this.arrLables.length - positions.length;
            if (count >= 0) {
                for (var i = this.arrLables.length - 1; i >= positions.length - 1; i--) {
                    this.dataSource.entities.remove(this.arrLables[i]);
                }
                this.arrLables.splice(positions.length - 1, count + 1);
            }
            entity._totalLable = this.totalLable;
            entity.arrEntityEx = this.arrLables;

            this.totalLable = null;
            this.arrLables = [];

            if (this.type == "length") {
                this.target.fire(_MarsClass.eventType.end, {
                    mtype: this.type,
                    entity: entity,
                    value: entity._totalLable.attribute.value
                });
            }
        }
    }, {
        key: 'type',
        get: function get() {
            return "length";
        }
    }]);

    return MeasureLength;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ArrowParent = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//箭头的父类 
var ArrowParent = exports.ArrowParent = function () {
    function ArrowParent() {
        _classCallCheck(this, ArrowParent);

        this.plotUtil = _PlotUtil.plotUtil;
    }

    _createClass(ArrowParent, [{
        key: "getArrowHeadPoints",
        value: function getArrowHeadPoints(points, tailLeft, tailRight) {
            var len = this.plotUtil.getBaseLength(points);
            var headHeight = len * this.headHeightFactor;
            var headPnt = points[points.length - 1];
            len = this.plotUtil.MathDistance(headPnt, points[points.length - 2]);
            var tailWidth = this.plotUtil.MathDistance(tailLeft, tailRight);
            if (headHeight > tailWidth * this.headTailFactor) {
                headHeight = tailWidth * this.headTailFactor;
            }
            var headWidth = headHeight * this.headWidthFactor;
            var neckWidth = headHeight * this.neckWidthFactor;
            headHeight = headHeight > len ? len : headHeight;
            var neckHeight = headHeight * this.neckHeightFactor;
            var headEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
            var neckEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
            var headLeft = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
            var headRight = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
            var neckLeft = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
            var neckRight = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
            return [neckLeft, headLeft, headPnt, headRight, neckRight];
        }
    }, {
        key: "getArrowBodyPoints",
        value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
            var allLen = this.plotUtil.wholeDistance(points);
            var len = this.plotUtil.getBaseLength(points);
            var tailWidth = len * tailWidthFactor;
            var neckWidth = this.plotUtil.MathDistance(neckLeft, neckRight);
            var widthDif = (tailWidth - neckWidth) / 2;
            var tempLen = 0,
                leftBodyPnts = [],
                rightBodyPnts = [];

            for (var i = 1; i < points.length - 1; i++) {
                var angle = this.plotUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
                tempLen += this.plotUtil.MathDistance(points[i - 1], points[i]);
                var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
                var left = this.plotUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
                var right = this.plotUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
                leftBodyPnts.push(left);
                rightBodyPnts.push(right);
            }
            return leftBodyPnts.concat(rightBodyPnts);
        }
    }]);

    return ArrowParent;
}();

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LineFlowMaterial = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _LineFlowMaterial = __webpack_require__(95);

var _LineFlowMaterial2 = _interopRequireDefault(_LineFlowMaterial);

var _LineFlowMaterial3 = __webpack_require__(96);

var _LineFlowMaterial4 = _interopRequireDefault(_LineFlowMaterial3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultColor = new Cesium.Color(0, 0, 0, 0);
var defaultBgColor = new Cesium.Color(1, 1, 1);

//线状 流动效果 材质

var LineFlowMaterial = exports.LineFlowMaterial = function () {
    //========== 构造方法 ========== 
    function LineFlowMaterial(options) {
        _classCallCheck(this, LineFlowMaterial);

        options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

        this._definitionChanged = new Cesium.Event();
        this._color = undefined;
        this._colorSubscription = undefined;

        this.color = Cesium.defaultValue(options.color, defaultColor); //颜色
        this.url = Cesium.defaultValue(options.url, undefined); //背景图片颜色
        if (!this.url) return;

        this.axisY = Boolean(options.axisY);
        this.bgUrl = Cesium.defaultValue(options.bgUrl, undefined); //背景图片颜色
        this.bgColor = Cesium.defaultValue(options.bgColor, defaultBgColor); //背景图片颜色
        this._duration = options.duration || 1000; //时长

        var _material = getImageMaterial(this.url, this.bgUrl, options.repeat, Boolean(options.axisY), this.bgColor);

        this._materialType = _material.type; //材质类型
        this._materialImage = _material.image; //材质图片
        this._time = undefined;
    }

    //========== 对外属性 ==========   


    _createClass(LineFlowMaterial, [{
        key: "getType",


        //========== 方法 ==========
        /**
         * Gets the {@link Cesium.Material} type at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the type.
         * @returns {String} The type of material.
         */
        value: function getType(time) {
            return this._materialType;
        }

        /**
         * Gets the value of the property at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */

    }, {
        key: "getValue",
        value: function getValue(time, result) {
            if (!Cesium.defined(result)) {
                result = {};
            }
            result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
            result.image = this._materialImage;
            if (this._time === undefined) {
                this._time = new Date().getTime();
            }
            result.time = (new Date().getTime() - this._time) / this._duration;
            return result;
        }

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cesium.Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */

    }, {
        key: "equals",
        value: function equals(other) {
            return this === other || //
            other instanceof LineFlowMaterial && Cesium.Property.equals(this._color, other._color);
        }
    }, {
        key: "isConstant",
        get: function get() {
            return false;
        }
    }, {
        key: "definitionChanged",
        get: function get() {
            return this._definitionChanged;
        }
    }]);

    return LineFlowMaterial;
}();

Object.defineProperties(LineFlowMaterial.prototype, {
    /**
     * Gets or sets the Cesium.Property specifying the {@link Cesium.Color} of the line.
     * @memberof PolylineGlowMaterialProperty.prototype
     * @type {Cesium.Property}
     */
    color: Cesium.createPropertyDescriptor('color')
});

//静态方法，处理材质
var cacheIdx = 0;
var nameEx = "AnimationLine";
function getImageMaterial(imgurl, bgUrl, repeat, axisY, bgColor) {
    cacheIdx++;
    var typeName = nameEx + cacheIdx + "Type";
    var imageName = nameEx + cacheIdx + "Image";

    Cesium.Material[typeName] = typeName;
    Cesium.Material[imageName] = imgurl;

    if (bgUrl) {
        //存在2张url的，用叠加融合的效果
        Cesium.Material._materialCache.addMaterial(Cesium.Material[typeName], {
            fabric: {
                type: Cesium.Material.PolylineArrowLinkType,
                uniforms: {
                    color: new Cesium.Color(1, 0, 0, 1.0),
                    image: Cesium.Material[imageName],
                    time: 0,
                    repeat: repeat || new Cesium.Cartesian2(1.0, 1.0),
                    axisY: axisY,
                    image2: bgUrl,
                    bgColor: bgColor
                },
                source: _LineFlowMaterial4.default
            },
            translucent: function translucent() {
                return true;
            }
        });
    } else {
        Cesium.Material._materialCache.addMaterial(Cesium.Material[typeName], {
            fabric: {
                type: typeName,
                uniforms: {
                    color: new Cesium.Color(1, 0, 0, 1.0),
                    image: Cesium.Material[imageName],
                    time: 0,
                    repeat: repeat || new Cesium.Cartesian2(1.0, 1.0),
                    axisY: axisY
                },
                source: _LineFlowMaterial2.default
            },
            translucent: function translucent() {
                return true;
            }
        });
    }

    return {
        type: Cesium.Material[typeName],
        image: Cesium.Material[imageName]
    };
}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;
exports.getOutlinePositions = getOutlinePositions;
exports.getOutlineCoordinates = getOutlineCoordinates;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

var _globe = __webpack_require__(18);

var globe = _interopRequireWildcard(_globe);

var _polygon = __webpack_require__(13);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值 
        entityattr = {
            fill: true
        };
    }
    //贴地时，剔除高度相关属性
    if (style.clampToGround) {
        if (style.hasOwnProperty('height')) delete style.height;
        if (style.hasOwnProperty('extrudedHeight')) delete style.extrudedHeight;
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];

        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":
            case "color":
            case "animation":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outline":
                //边线
                if (entityattr[key] instanceof Cesium.CallbackProperty) {
                    //回调时不覆盖
                } else {
                    entityattr[key] = value;
                }
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
                break;
            case "rotation":
                //旋转角度
                entityattr.rotation = Cesium.Math.toRadians(value);
                if (!style.stRotation) entityattr.stRotation = Cesium.Math.toRadians(value);
                break;
            case "stRotation":
                entityattr.stRotation = Cesium.Math.toRadians(value);
                break;
            case "height":
                entityattr.height = value;
                if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) entityattr.extrudedHeight = Number(style.extrudedHeight) + Number(value);
                break;
            case "extrudedHeight":
                if ((0, _util.isNumber)(value)) {
                    entityattr.extrudedHeight = Number(entityattr.height || style.height || 0) + Number(value);
                } else {
                    entityattr.extrudedHeight = value;
                }
                break;
            case "radius":
                //半径（圆）
                entityattr.semiMinorAxis = Number(value);
                entityattr.semiMajorAxis = Number(value);
                break;
            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;
            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
        }
    }

    //设置填充材质
    globe.setFillMaterial(entityattr, style);

    return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
    return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: { type: "Point", coordinates: coordinates[0] }
    };
}

//获取entity对应的 边界 的坐标
function getOutlinePositions(entity, noAdd, count) {
    var time = (0, _util.currentTime)();

    //获取圆（或椭圆）边线上的坐标点数组
    var outerPositions = (0, _polygon.getEllipseOuterPositions)({
        position: (0, _point.getPositionValue)(entity.position),
        semiMajorAxis: entity.ellipse.semiMajorAxis && entity.ellipse.semiMajorAxis.getValue(time), //长半轴
        semiMinorAxis: entity.ellipse.semiMinorAxis && entity.ellipse.semiMinorAxis.getValue(time), //短半轴
        rotation: entity.ellipse.rotation && entity.ellipse.rotation.getValue(time),
        count: Cesium.defaultValue(count, 90) //共返回360个点
    });

    if (!noAdd && outerPositions) outerPositions.push(outerPositions[0]);

    return outerPositions;
}

//获取entity对应的 边界 的坐标（geojson规范的格式）
function getOutlineCoordinates(entity, noAdd, count) {
    var positions = getOutlinePositions(entity, noAdd, count);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TileLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _BaseLayer2 = __webpack_require__(15);

var _layer = __webpack_require__(23);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TileLayer = exports.TileLayer = function (_BaseLayer) {
    _inherits(TileLayer, _BaseLayer);

    //========== 构造方法 ========== 
    function TileLayer(viewer, options) {
        _classCallCheck(this, TileLayer);

        var _this = _possibleConstructorReturn(this, (TileLayer.__proto__ || Object.getPrototypeOf(TileLayer)).call(this, viewer, options));

        _this.hasOpacity = true;
        _this.hasZIndex = true;
        return _this;
    }

    _createClass(TileLayer, [{
        key: 'add',


        //添加 
        value: function add() {
            if (this.imageryLayer != null) {
                this.remove();
            }

            this.addEx();
            var imageryProvider = this.createImageryProvider(this.options);
            if (!Cesium.defined(imageryProvider)) return;

            var options = this.options;

            var imageryOpt = {
                show: true, alpha: this._opacity
            };
            if (Cesium.defined(options.rectangle) && Cesium.defined(options.rectangle.xmin) && Cesium.defined(options.rectangle.xmax) && Cesium.defined(options.rectangle.ymin) && Cesium.defined(options.rectangle.ymax)) {
                var xmin = options.rectangle.xmin;
                var xmax = options.rectangle.xmax;
                var ymin = options.rectangle.ymin;
                var ymax = options.rectangle.ymax;
                var rectangle = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);
                this.rectangle = rectangle;
                imageryOpt.rectangle = rectangle;
            }
            if (Cesium.defined(options.bbox) && options.bbox.length && options.bbox.length == 4) {
                var rectangle = Cesium.Rectangle.fromDegrees(options.bbox[0], options.bbox[1], options.bbox[2], options.bbox[3]); //[xmin,ymin,xmax,ymax]
                this.rectangle = rectangle;
                imageryOpt.rectangle = rectangle;
            }

            if (Cesium.defined(options.brightness)) imageryOpt.brightness = options.brightness;
            if (Cesium.defined(options.contrast)) imageryOpt.contrast = options.contrast;
            if (Cesium.defined(options.hue)) imageryOpt.hue = options.hue;
            if (Cesium.defined(options.saturation)) imageryOpt.saturation = options.saturation;
            if (Cesium.defined(options.gamma)) imageryOpt.gamma = options.gamma;
            if (Cesium.defined(options.maximumAnisotropy)) imageryOpt.maximumAnisotropy = options.maximumAnisotropy;
            if (Cesium.defined(options.minimumTerrainLevel)) imageryOpt.minimumTerrainLevel = options.minimumTerrainLevel;
            if (Cesium.defined(options.maximumTerrainLevel)) imageryOpt.maximumTerrainLevel = options.maximumTerrainLevel;

            this.imageryLayer = new Cesium.ImageryLayer(imageryProvider, imageryOpt);
            this.imageryLayer.eventTarget = this;
            this.imageryLayer.config = this.options;

            var that = this;
            this.imageryLayer.onLoadTileStart = function (imagery) {
                that.fire(_MarsClass.eventType.loadTileStart, { imagery: imagery });
            };
            this.imageryLayer.onLoadTileEnd = function (imagery) {
                that.fire(_MarsClass.eventType.loadTileEnd, { imagery: imagery });
            };
            this.imageryLayer.onLoadTileError = function (imagery) {
                that.fire(_MarsClass.eventType.loadTileError, { imagery: imagery });
            };

            this.viewer.imageryLayers.add(this.imageryLayer);

            this.setZIndex(this.options.order);

            _get(TileLayer.prototype.__proto__ || Object.getPrototypeOf(TileLayer.prototype), 'add', this).call(this);

            this.fire(_MarsClass.eventType.load, {
                imageryLayer: this.imageryLayer
            });
        }
        //方便外部继承覆盖该方法

    }, {
        key: 'createImageryProvider',
        value: function createImageryProvider(config) {
            return (0, _layer.createImageryProvider)(config); //调用layer.js
        }
    }, {
        key: 'addEx',
        value: function addEx() {}
        //子类使用

        //移除

    }, {
        key: 'remove',
        value: function remove() {
            if (this.imageryLayer == null) return;

            this.removeEx();
            this.viewer.imageryLayers.remove(this.imageryLayer, true);
            this.imageryLayer = null;
            _get(TileLayer.prototype.__proto__ || Object.getPrototypeOf(TileLayer.prototype), 'remove', this).call(this);
        }
    }, {
        key: 'removeEx',
        value: function removeEx() {}
        //子类使用

        //定位至数据区域

    }, {
        key: 'centerAt',
        value: function centerAt(duration) {
            if (this.imageryLayer == null) return;

            if (this.options.extent || this.options.center) {
                this.viewer.mars.centerAt(this.options.extent || this.options.center, { duration: duration, isWgs84: true });
            } else if (Cesium.defined(this.rectangle)) {
                this.viewer.camera.flyTo({
                    destination: this.rectangle,
                    duration: duration
                });
            } else {
                var rectangle = this.imageryLayer.imageryProvider.rectangle; //arcgis图层等，读取配置信息
                if (Cesium.defined(rectangle) && rectangle != Cesium.Rectangle.MAX_VALUE && rectangle.west > 0 && rectangle.south > 0 && rectangle.east > 0 && rectangle.north > 0) {
                    this.viewer.camera.flyTo({
                        destination: rectangle,
                        duration: duration
                    });
                }
            }
        }
        //设置透明度

    }, {
        key: 'setOpacity',
        value: function setOpacity(value) {
            this._opacity = value;
            if (this.imageryLayer == null) return;

            this.imageryLayer.alpha = value;
        }
        //设置叠加顺序

    }, {
        key: 'setZIndex',
        value: function setZIndex(order) {
            if (this.imageryLayer == null || order == null) return;

            //先移动到最顶层
            this.viewer.imageryLayers.raiseToTop(this.imageryLayer);

            var layers = this.viewer.imageryLayers._layers;
            for (var i = layers.length - 1; i >= 0; i--) {
                if (layers[i] == this.imageryLayer) continue;
                var _temp = layers[i].config;
                if (_temp && _temp.order) {
                    if (order < _temp.order) {
                        this.viewer.imageryLayers.lower(this.imageryLayer); //下移一个位置
                    }
                }
            }
        }
    }, {
        key: 'layer',
        get: function get() {
            return this.imageryLayer;
        }
    }]);

    return TileLayer;
}(_BaseLayer2.BaseLayer);
//[静态属性]本类中支持的事件类型常量


TileLayer.event = {
    loadTileStart: _MarsClass.eventType.loadTileStart,
    loadTileEnd: _MarsClass.eventType.loadTileEnd,
    loadTileError: _MarsClass.eventType.loadTileError,
    load: _MarsClass.eventType.load,
    click: _MarsClass.eventType.click,
    mouseOver: _MarsClass.eventType.mouseOver,
    mouseOut: _MarsClass.eventType.mouseOut
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomFeatureGridLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _FeatureGridLayer2 = __webpack_require__(102);

var _config2Entity2 = __webpack_require__(32);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //分块加载矢量数据公共类


var CustomFeatureGridLayer = exports.CustomFeatureGridLayer = function (_FeatureGridLayer) {
    _inherits(CustomFeatureGridLayer, _FeatureGridLayer);

    //========== 构造方法 ========== 
    function CustomFeatureGridLayer(viewer, options) {
        _classCallCheck(this, CustomFeatureGridLayer);

        var _this = _possibleConstructorReturn(this, (CustomFeatureGridLayer.__proto__ || Object.getPrototypeOf(CustomFeatureGridLayer)).call(this, viewer, options));

        _this._cacheGrid = {}; //网格缓存,存放矢量对象id集合
        _this._cacheFeature = {}; //矢量对象缓存,存放矢量对象和其所对应的网格集合  
        _this.hasOpacity = true;
        return _this;
    }

    //========== 方法==========


    _createClass(CustomFeatureGridLayer, [{
        key: '_addImageryCache',
        value: function _addImageryCache(opts) {
            this._cacheGrid[opts.key] = { opts: opts, isLoading: true };

            var that = this;

            this.getDataForGrid(opts, function (arrdata) {
                if (that._visible) that._showData(opts, arrdata);
            });
        }
    }, {
        key: 'getDataForGrid',
        value: function getDataForGrid(opts, callback) {
            //子类可继承, callback为回调方法,callback参数传数据数组

            //直接使用本类,传参方式
            if (this.options.getDataForGrid) {
                this.options.getDataForGrid(opts, callback);
            }
        }
    }, {
        key: 'checkHasBreak',
        value: function checkHasBreak(cacheKey) {
            if (!this._visible || !this._cacheGrid[cacheKey]) {
                return true;
            }
            return false;
        }
    }, {
        key: '_showData',
        value: function _showData(opts, arrdata) {
            var cacheKey = opts.key;
            if (this.checkHasBreak[cacheKey]) {
                return; //异步请求结束时,如果已经卸载了网格就直接跳出。
            }

            var that = this;

            var arrIds = [];
            for (var i = 0, len = arrdata.length; i < len; i++) {
                var attributes = arrdata[i];
                var id = attributes[this.options.IdName || 'id'];

                var layer = this._cacheFeature[id];
                if (layer) {
                    //已存在
                    layer.grid.push(cacheKey);
                    this.updateEntity(layer.entity, attributes);
                } else {
                    var entity = this.createEntity(opts, attributes, function (entity) {
                        if (that.options.debuggerTileInfo) {
                            //测试用
                            entity._temp_id = id;
                            entity.popup = function (entity) {
                                return JSON.stringify(that._cacheFeature[entity._temp_id].grid);
                            };
                        }
                        that._cacheFeature[id] = {
                            grid: [cacheKey],
                            entity: entity
                        };
                        if (that.options.onEachEntity) //添加到地图后回调方法
                            that.options.onEachEntity(entity, that);
                    });
                    if (entity != null) {
                        if (that.options.debuggerTileInfo) {
                            //测试用
                            entity._temp_id = id;
                            entity.popup = function (entity) {
                                return JSON.stringify(that._cacheFeature[entity._temp_id].grid);
                            };
                        }
                        that._cacheFeature[id] = {
                            grid: [cacheKey],
                            entity: entity
                        };
                        if (that.options.onEachEntity) //添加到地图后回调方法
                            that.options.onEachEntity(entity, that);
                    }
                }
                arrIds.push(id);
            }

            this._cacheGrid[cacheKey] = this._cacheGrid[cacheKey] || {};
            this._cacheGrid[cacheKey].ids = arrIds;
            this._cacheGrid[cacheKey].isLoading = false;
        }
    }, {
        key: 'createEntity',
        value: function createEntity(opts, attributes, callback) {
            //子类可以继承,根据数据创造entity

            //直接使用本类,传参方式
            if (this.options.createEntity) {
                return this.options.createEntity(opts, attributes, callback);
            }
            return null;
        }
    }, {
        key: 'updateEntity',
        value: function updateEntity(enetity, attributes) {
            //子类可以继承,更新entity（动态数据时有用）

            //直接使用本类,传参方式
            if (this.options.updateEntity) {
                this.options.updateEntity(enetity, attributes);
            }
        }
    }, {
        key: 'removeEntity',
        value: function removeEntity(enetity) {
            //子类可以继承,移除entity

            //直接使用本类,传参方式
            if (this.options.removeEntity) {
                this.options.removeEntity(enetity);
            } else {
                this.dataSource.entities.remove(enetity);
            }
        }
    }, {
        key: '_removeImageryCache',
        value: function _removeImageryCache(opts) {
            var cacheKey = opts.key;
            var layers = this._cacheGrid[cacheKey];
            if (layers) {
                if (layers.ids) {
                    for (var i = 0; i < layers.ids.length; i++) {
                        var id = layers.ids[i];
                        var layer = this._cacheFeature[id];
                        if (layer) {
                            layer.grid.remove(cacheKey);
                            if (layer.grid.length == 0) {
                                delete this._cacheFeature[id];
                                this.removeEntity(layer.entity);
                            }
                        }
                    }
                }
                delete this._cacheGrid[cacheKey];
            }
        }
    }, {
        key: '_removeAllImageryCache',
        value: function _removeAllImageryCache() {

            if (this.options.removeAllEntity) {
                this.options.removeAllEntity();
            } else {
                this.dataSource.entities.removeAll();
                this.primitives.removeAll();
            }

            this._cacheFeature = {};
            this._cacheGrid = {};
        }
        //移除 

    }, {
        key: 'removeEx',
        value: function removeEx() {
            if (this.options.removeAllEntity) {
                this.options.removeAllEntity();
            } else {
                this.dataSource.entities.removeAll();
                this.primitives.removeAll();
            }

            this._cacheFeature = {};
            this._cacheGrid = {};

            this.viewer.dataSources.remove(this.dataSource);
            this.viewer.scene.primitives.remove(this.primitives);
        }
        //重新加载数据

    }, {
        key: 'reload',
        value: function reload() {
            var that = this;
            for (var i in this._cacheGrid) {
                var item = this._cacheGrid[i];
                if (item == null || item.opts == null || item.isLoading) continue;

                var opts = item.opts;
                this.getDataForGrid(opts, function (arrdata) {
                    that._showData(opts, arrdata);
                });
            }
        }

        //设置透明度

    }, {
        key: 'setOpacity',
        value: function setOpacity(value) {
            this._opacity = value;

            for (var i in this._cacheFeature) {
                var entity = this._cacheFeature[i].entity;

                if (entity.polygon && entity.polygon.material && entity.polygon.material.color) {
                    this._updatEntityAlpha(entity.polygon.material.color, this._opacity);
                    if (entity.polygon.outlineColor) {
                        this._updatEntityAlpha(entity.polygon.outlineColor, this._opacity);
                    }
                }

                if (entity.polyline && entity.polyline.material && entity.polyline.material.color) {
                    this._updatEntityAlpha(entity.polyline.material.color, this._opacity);
                }

                if (entity.billboard) {
                    entity.billboard.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
                }

                if (entity.model) {
                    entity.model.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
                }

                if (entity.label) {
                    var _opacity = this._opacity;
                    if (entity.styleOpt && entity.styleOpt.label && entity.styleOpt.label.opacity) _opacity = entity.styleOpt.label.opacity;

                    if (entity.label.fillColor) this._updatEntityAlpha(entity.label.fillColor, _opacity);
                    if (entity.label.outlineColor) this._updatEntityAlpha(entity.label.outlineColor, _opacity);
                    if (entity.label.backgroundColor) this._updatEntityAlpha(entity.label.backgroundColor, _opacity);
                }
            }
        }
    }, {
        key: '_updatEntityAlpha',
        value: function _updatEntityAlpha(color, opacity) {
            if (!color) return;
            var newclr = color.getValue(this.viewer.clock.currentTime);
            if (!newclr || !newclr.withAlpha) return color;

            newclr = newclr.withAlpha(opacity);
            color.setValue(newclr);
        }

        //获取属性

    }, {
        key: 'getEntityAttr',
        value: function getEntityAttr(entity) {
            return (0, _util.getAttrVal)(entity.properties);
        }
        //根据config配置，更新entitys 

    }, {
        key: 'config2Entity',
        value: function config2Entity(entity) {
            return (0, _config2Entity2.config2Entity)([entity], this.options);
        }
    }]);

    return CustomFeatureGridLayer;
}(_FeatureGridLayer2.FeatureGridLayer);

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeoJsonLayer = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var _point = __webpack_require__(2);

var _config2Entity = __webpack_require__(32);

var _BaseLayer2 = __webpack_require__(15);

var _zepto = __webpack_require__(8);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GeoJsonLayer = exports.GeoJsonLayer = function (_BaseLayer) {
    _inherits(GeoJsonLayer, _BaseLayer);

    //========== 构造方法 ========== 
    function GeoJsonLayer(viewer, options) {
        _classCallCheck(this, GeoJsonLayer);

        var _this = _possibleConstructorReturn(this, (GeoJsonLayer.__proto__ || Object.getPrototypeOf(GeoJsonLayer)).call(this, viewer, options));

        _this.hasOpacity = true;
        _this.hasZIndex = true;
        return _this;
    }

    _createClass(GeoJsonLayer, [{
        key: 'create',
        value: function create() {
            var _this2 = this;

            //是建筑物单体化时
            if (this.options.dth) {
                var dthEvent = (0, _config2Entity.createDthEntity)(this.viewer, this.options.dth);

                if (this.options.dth.type == "click") {
                    this.on(_MarsClass.eventType.click, function (e) {
                        dthEvent.mouseover(e.sourceTarget);
                    });
                    this.viewer.mars.on(_MarsClass.eventType.clickMap, function (e) {
                        if (!_this2._visible) return;
                        dthEvent.mouseout();
                    });
                } else {
                    this.on(_MarsClass.eventType.mouseOver, function (e) {
                        dthEvent.mouseover(e.sourceTarget);
                    });
                    this.on(_MarsClass.eventType.mouseOut, function (e) {
                        dthEvent.mouseout();
                    });
                }
                this.dthEvent = dthEvent;
            }
        }
        //添加 

    }, {
        key: 'add',
        value: function add() {
            if (this.labelCollection && !this.viewer.scene.primitives.contains(this.labelCollection)) {
                this.viewer.scene.primitives.add(this.labelCollection);
            }

            if (!this.options.reload && this.dataSource) {
                //this.options.reload可以外部控制每次都重新请求数据
                this.viewer.dataSources.add(this.dataSource);
            } else {
                this.queryData();
            }
            _get(GeoJsonLayer.prototype.__proto__ || Object.getPrototypeOf(GeoJsonLayer.prototype), 'add', this).call(this);
        }
        //移除

    }, {
        key: 'remove',
        value: function remove() {
            //是建筑物单体化时
            if (this.dthEvent) {
                this.dthEvent.mouseout();
            }
            if (this.dataSource) {
                this.viewer.dataSources.remove(this.dataSource);
                delete this.dataSource;
            }
            if (this.labelCollection && this.viewer.scene.primitives.contains(this.labelCollection)) {
                this.viewer.scene.primitives.destroyPrimitives = false;
                this.viewer.scene.primitives.remove(this.labelCollection);
            }
            _get(GeoJsonLayer.prototype.__proto__ || Object.getPrototypeOf(GeoJsonLayer.prototype), 'remove', this).call(this);
        }
        //定位至数据区域

    }, {
        key: 'centerAt',
        value: function centerAt(duration) {
            if (this.options.extent || this.options.center) {
                this.viewer.mars.centerAt(this.options.extent || this.options.center, { duration: duration, isWgs84: true });
            } else {
                if (this.dataSource == null) return;
                this.viewer.mars.flyTo(this.dataSource.entities.values, { duration: duration });
            }
        }
    }, {
        key: 'clearData',
        value: function clearData() {
            if (this.dataSource) this.dataSource.entities.removeAll();

            if (this.labelCollection) this.labelCollection.removeAll();

            this.options.data = null;
        }
    }, {
        key: 'setData',
        value: function setData(geojson) {
            //兼容不同命名
            this.clearData();
            return this.queryData(geojson);
        }
        //是否贴地

    }, {
        key: 'hasClampToGround',
        value: function hasClampToGround() {
            if (this.options.clampToGround) return true;
            if (this.options.symbol && this.options.symbol.styleOptions && this.options.symbol.styleOptions.clampToGround) return true;
            return false;
        }
    }, {
        key: 'getLoadConfig',
        value: function getLoadConfig() {
            var config = (0, _util.getProxyUrl)(this.options);
            if (config.symbol && config.symbol.styleOptions) {
                var style = config.symbol.styleOptions;
                if (Cesium.defined(style.clampToGround)) {
                    config.clampToGround = style.clampToGround;
                }
                if (Cesium.defined(style.color)) {
                    var color = Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 0.5)));
                    config.fill = color;
                }
                if (Cesium.defined(style.outlineColor)) {
                    var outlineColor = Cesium.Color.fromCssColorString(style.outlineColor || style.color || "#FFFFFF").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
                    config.stroke = outlineColor;
                }
                if (Cesium.defined(style.outlineWidth)) {
                    config.strokeWidth = style.outlineWidth;
                }
            }
            return config;
        }
    }, {
        key: 'queryData',
        value: function queryData(geojson) {
            var that = this;

            var config = this.getLoadConfig();
            geojson = geojson || config.url || config.data;
            if (!geojson) return; //没有需要加载的对象

            if (config.url) {
                _zepto.zepto.ajax({
                    type: "get",
                    dataType: "json",
                    url: config.url,
                    timeout: Cesium.defaultValue(config.timeout, 0), //永不超时
                    success: function success(geojson) {
                        var dataSource = Cesium.GeoJsonDataSource.load(geojson, config);
                        dataSource.then(function (dataSource) {
                            that.showResult(dataSource);
                        }).otherwise(function (error) {
                            that.showError("服务出错", error);
                        });
                    },
                    error: function error(XMLHttpRequest, textStatus, errorThrown) {
                        marslog.warn(config.url + "文件加载失败！");
                    }
                });
            } else {
                this.options.data = geojson;
                var dataSource = Cesium.GeoJsonDataSource.load(geojson, config);
                dataSource.then(function (dataSource) {
                    that.showResult(dataSource);
                }).otherwise(function (error) {
                    that.showError("服务出错", error);
                });
            }
        }
    }, {
        key: 'showResult',
        value: function showResult(dataSource) {
            var _this3 = this;

            if (this.dataSource) {
                this.viewer.dataSources.remove(this.dataSource);
                delete this.dataSource;
            }
            if (this.labelCollection) {
                this.labelCollection.removeAll();
            }

            if (!this._visible) return;

            this.dataSource = dataSource;
            this.dataSource.order = this.options.order;
            this.viewer.dataSources.add(dataSource);

            if (this.hasZIndex) this.setZIndex(this.options.order);

            if (this.options.flyTo) this.centerAt(this.options.flyToDuration);

            //根据config配置，更新entitys 
            this.options.getAttrVal = function (entity) {
                return _this3.getEntityAttr(entity);
            };
            this.options.eventTarget = this;

            var entities = dataSource.entities.values;
            (0, _config2Entity.config2Entity)(entities, this.options, function (position, labelattr, attr) {
                return _this3.lblAddFun(position, labelattr, attr);
            });

            if (this._opacity != 1) this.setOpacity(this._opacity);

            this.fire(_MarsClass.eventType.load, {
                dataSource: dataSource,
                entities: entities
            });
        }
    }, {
        key: 'updateStyle',
        value: function updateStyle(symbol) {
            var _this4 = this;

            if (!this.dataSource) return;

            if (symbol) {
                this.options.symbol = _extends({}, this.options.symbol, symbol);
            }

            var entities = this.dataSource.entities.values;
            (0, _config2Entity.config2Entity)(entities, this.options, function (position, labelattr, attr) {
                return _this4.lblAddFun(position, labelattr, attr);
            });
        }
    }, {
        key: 'lblAddFun',
        value: function lblAddFun(position, labelattr, attr) {
            if (labelattr.text == "") return null;

            if (Cesium.defined(labelattr.height)) {
                position = (0, _point.setPositionsHeight)(position, labelattr.height);
            }

            //entity方式
            var lblEx = this.dataSource.entities.add({
                position: position,
                label: labelattr,
                properties: attr
            });

            //LabelCollection方式
            // if (!this.labelCollection) {
            //     this.labelCollection = new Cesium.LabelCollection({ scene: this.viewer.scene });
            //     this.viewer.scene.primitives.add(this.labelCollection);
            // }
            // labelattr.position = position;
            // var lblEx = this.labelCollection.add(labelattr);
            // lblEx.properties = attr;

            return lblEx;
        }
        //刷新事件

    }, {
        key: 'refreshEvent',
        value: function refreshEvent() {
            if (this.dataSource == null) return false;

            var entities = this.dataSource.entities.values;
            for (var i = 0, len = entities.length; i < len; i++) {
                var entity = entities[i];

                entity.eventTarget = this;
                entity.contextmenuItems = this.options.contextmenuItems;
            }
            return true;
        }
        //设置透明度

    }, {
        key: 'setOpacity',
        value: function setOpacity(value) {
            this._opacity = value;
            if (this.dataSource == null) return;

            var entities = this.dataSource.entities.values;

            for (var i = 0, len = entities.length; i < len; i++) {
                var entity = entities[i];

                if (entity.polygon && entity.polygon.material && entity.polygon.material.color) {
                    this._updatEntityAlpha(entity.polygon.material.color, this._opacity);
                    if (entity.polygon.outlineColor) {
                        this._updatEntityAlpha(entity.polygon.outlineColor, this._opacity);
                    }
                }

                if (entity.polyline && entity.polyline.material && entity.polyline.material.color) {
                    this._updatEntityAlpha(entity.polyline.material.color, this._opacity);
                }

                if (entity.billboard) {
                    entity.billboard.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
                }

                if (entity.model) {
                    entity.model.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
                }

                if (entity.label) {
                    var _opacity = this._opacity;
                    if (entity.styleOpt && entity.styleOpt.label && entity.styleOpt.label.opacity) _opacity = entity.styleOpt.label.opacity;

                    if (entity.label.fillColor) this._updatEntityAlpha(entity.label.fillColor, _opacity);
                    if (entity.label.outlineColor) this._updatEntityAlpha(entity.label.outlineColor, _opacity);
                    if (entity.label.backgroundColor) this._updatEntityAlpha(entity.label.backgroundColor, _opacity);
                }
            }
        }
    }, {
        key: '_updatEntityAlpha',
        value: function _updatEntityAlpha(color, opacity) {
            if (!color) return;
            var newclr = color.getValue(this.viewer.clock.currentTime);
            if (!newclr || !newclr.withAlpha) return color;

            newclr = newclr.withAlpha(opacity);
            color.setValue(newclr);
        }

        //设置叠加顺序

    }, {
        key: 'setZIndex',
        value: function setZIndex(order) {
            if (this.dataSource == null || order == null) return;
            if (!this.viewer.dataSources.contains(this.dataSource)) return;

            //先移动到最顶层
            this.viewer.dataSources.raiseToTop(this.dataSource);

            var layers = this.viewer.dataSources;
            for (var i = layers.length - 1; i >= 0; i--) {
                var layer = layers.get(i);
                if (layer == this.dataSource) continue;
                if (Cesium.defined(layer.order) && order < layer.order) {
                    this.viewer.dataSources.lower(this.dataSource); //下移一个位置
                }
            }
        }

        //获取属性

    }, {
        key: 'getEntityAttr',
        value: function getEntityAttr(entity) {
            return (0, _util.getAttrVal)(entity.properties);
        }

        //外部自定义添加entity

    }, {
        key: 'addEntity',
        value: function addEntity(entitys) {
            var _this5 = this;

            if (!this.dataSource) {
                this.dataSource = new Cesium.CustomDataSource();
                this.viewer.dataSources.add(this.dataSource);
            }

            if (!(0, _util.isArray)(entitys)) entitys = [entitys];

            for (var i = 0, len = entitys.length; i < len; i++) {
                var entity = entitys[i];

                if (entity.entityCollection) entity.entityCollection.remove(entity); //从原有的集合中删除  
                this.dataSource.entities.add(entity); //加入到当前图层集合图层中
            }

            (0, _config2Entity.config2Entity)(entitys, this.options, function (position, labelattr, attr) {
                return _this5.lblAddFun(position, labelattr, attr);
            });
        }
    }, {
        key: 'removeEntity',
        value: function removeEntity(entity) {
            this.dataSource.entities.remove(entity); //加入到当前图层集合图层中 
        }
    }, {
        key: 'getEntitys',
        value: function getEntitys() {
            if (this.dataSource) return this.dataSource.entities.values;else return null;
        }
    }, {
        key: 'layer',
        get: function get() {
            return this.dataSource;
        }
    }]);

    return GeoJsonLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _MarsClass2 = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawBase = exports.DrawBase = function (_MarsClass) {
    _inherits(DrawBase, _MarsClass);

    //========== 构造方法 ========== 
    function DrawBase(opts) {
        _classCallCheck(this, DrawBase);

        var _this = _possibleConstructorReturn(this, (DrawBase.__proto__ || Object.getPrototypeOf(DrawBase)).call(this, opts));

        _this.viewer = opts.viewer;
        _this.dataSource = opts.dataSource;

        _this.tooltip = opts.tooltip || new Tooltip(_this.viewer.container);

        _this._positions_draw = null; //坐标位置相关 
        _this.editClass = null; //编辑对象   
        _this.attrClass = null; //对应的属性控制静态类
        return _this;
    }

    _createClass(DrawBase, [{
        key: 'fire',
        value: function fire(type, data, propagate) {
            if (this._fire) this._fire(type, data, propagate);
        }
    }, {
        key: 'formatNum',
        value: function formatNum(num, digits) {
            return (0, _point.formatNum)(num, digits);
        }
    }, {
        key: 'enableControl',
        value: function enableControl(value) {
            if (this.viewer.mars.popup) this.viewer.mars.popup.enable = value;
            if (this.viewer.mars.tooltip) this.viewer.mars.tooltip.enable = value;
            if (this.viewer.mars.contextmenu) this.viewer.mars.contextmenu.enable = value;
        }
        //激活绘制

    }, {
        key: 'activate',
        value: function activate(attribute, drawOkCallback, dataSource) {
            if (this._enabled) {
                return this;
            }
            this._enabled = true;
            this.drawOkCallback = drawOkCallback;

            if (attribute instanceof Cesium.Entity) {
                this.reCreateFeature(attribute);
            } else {
                this.createFeature(attribute, dataSource);
            }

            this.entity.inProgress = true;

            this.setCursor(true);
            this.enableControl(false);
            this.bindEvent();

            this.fire(_MarsClass2.eventType.drawStart, { drawtype: this.type, entity: this.entity });

            return this.entity;
        }
        //释放绘制

    }, {
        key: 'disable',
        value: function disable(hasWB) {
            if (!this._enabled) {
                return this;
            }
            this._enabled = false;

            this.setCursor(false);
            this.enableControl(true);

            if (hasWB && this.entity.inProgress) {
                //外部释放时，尚未结束的标绘移除。
                if (this.entity.entityCollection.contains(this.entity)) this.entity.entityCollection.remove(this.entity);

                this.destroyHandler();
                this.tooltip.setVisible(false);
            } else {
                var entity = this.entity;
                this.entity.inProgress = false;
                this.finish();

                this.destroyHandler();
                this.tooltip.setVisible(false);
                this._positions_draw = null;
                this.entity = null;

                if (this.drawOkCallback) {
                    this.drawOkCallback(entity);
                    delete this.drawOkCallback;
                }
                this.fire(_MarsClass2.eventType.drawCreated, { drawtype: this.type, entity: entity });
            }

            return this;
        }
    }, {
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {}
    }, {
        key: 'reCreateFeature',
        value: function reCreateFeature(entity) {}
        //============= 事件相关 ============= 

    }, {
        key: 'getHandler',
        value: function getHandler() {
            if (!this.handler || this.handler.isDestroyed()) {
                this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
            }
            return this.handler;
        }
    }, {
        key: 'destroyHandler',
        value: function destroyHandler() {
            this.handler && this.handler.destroy();
            this.handler = undefined;
        }
    }, {
        key: 'setCursor',
        value: function setCursor(val) {
            this.viewer._container.style.cursor = val ? 'crosshair' : '';
        }
        //绑定鼠标事件

    }, {
        key: 'bindEvent',
        value: function bindEvent() {}
        //=============  ============= 
        //坐标位置相关 

    }, {
        key: 'getDrawPosition',
        value: function getDrawPosition() {
            return this._positions_draw;
        }
        //获取编辑对象   

    }, {
        key: 'getEditClass',
        value: function getEditClass(entity) {
            if (this.editClass == null) return null;

            var _edit = new this.editClass(entity, this.viewer);
            if (this._minPointNum != null) _edit._minPointNum = this._minPointNum;
            if (this._maxPointNum != null) _edit._maxPointNum = this._maxPointNum;

            _edit._fire = this._fire;
            _edit.tooltip = this.tooltip;

            return _edit;
        }
        //更新坐标后调用下，更新相关属性，子类使用

    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing(isLoad) {}
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {}
        //通用方法

    }, {
        key: 'getCoordinates',
        value: function getCoordinates(entity) {
            return this.attrClass.getCoordinates(entity);
        }
    }, {
        key: 'getPositions',
        value: function getPositions(entity) {
            return this.attrClass.getPositions(entity);
        }
    }, {
        key: 'toGeoJSON',
        value: function toGeoJSON(entity) {
            return this.attrClass.toGeoJSON(entity);
        }
        //属性转entity

    }, {
        key: 'attributeToEntity',
        value: function attributeToEntity(attribute, positions, dataSource) {
            var entity = this.createFeature(attribute, dataSource);
            this._positions_draw = positions;
            this.updateAttrForDrawing(true);
            this.finish();
            return entity;
        }
        //geojson转entity

    }, {
        key: 'jsonToEntity',
        value: function jsonToEntity(geojson, dataSource) {
            var attribute = geojson.properties;
            var positions = (0, _point.getPositionByGeoJSON)(geojson);
            return this.attributeToEntity(attribute, positions, dataSource);
        }
    }, {
        key: 'setDrawPositionByEntity',
        value: function setDrawPositionByEntity(entity) {
            var positions = this.getPositions(entity);
            this._positions_draw = positions;
        }
        //绑定外部entity到标绘

    }, {
        key: 'bindExtraEntity',
        value: function bindExtraEntity(entity, attribute) {
            this.entity = entity;
            entity.attribute = attribute;

            if (attribute.style) this.style2Entity(attribute.style, entity);

            this.setDrawPositionByEntity(entity);

            this.updateAttrForDrawing(true);
            this.finish();
            return entity;
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.disable();
            _get(DrawBase.prototype.__proto__ || Object.getPrototypeOf(DrawBase.prototype), 'destroy', this).call(this);
        }
    }]);

    return DrawBase;
}(_MarsClass2.MarsClass);

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawBillboard = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(24);

var _Attr = __webpack_require__(34);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(12);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawBillboard = exports.DrawBillboard = function (_DrawPoint) {
    _inherits(DrawBillboard, _DrawPoint);

    //========== 构造方法 ========== 
    function DrawBillboard(opts) {
        _classCallCheck(this, DrawBillboard);

        var _this = _possibleConstructorReturn(this, (DrawBillboard.__proto__ || Object.getPrototypeOf(DrawBillboard)).call(this, opts));

        _this.type = 'billboard';
        //对应的属性控制静态类
        _this.attrClass = attr;
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawBillboard, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;

            this._positions_draw = null;

            //绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
            var _drawShow = Cesium.defaultValue(attribute.drawShow, false);

            var that = this;
            var addattr = {
                show: _drawShow,
                _drawShow: _drawShow, //edit编辑时使用
                position: new Cesium.CallbackProperty(function (time) {
                    return that.getDrawPosition();
                }, false),
                billboard: attr.style2Entity(attribute.style),
                attribute: attribute
            };

            if (attribute.style && attribute.style.label) {
                //同时加文字
                addattr.label = (0, _Attr2.style2Entity)(attribute.style.label);
            }

            this.entity = dataSource.entities.add(addattr); //创建要素对象
            this.updateAttrForDrawing();
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            var _this2 = this;

            if (this.updateFeatureEx) {
                //setTimeout是为了优化效率
                if (this.updateTimer) {
                    clearTimeout(this.updateTimer);
                }
                this.updateTimer = setTimeout(function () {
                    delete _this2.updateTimer;
                    _this2.updateFeatureEx(style, entity);
                }, 300);
            }

            if (style && style.label) {
                //同时加文字
                (0, _Attr2.style2Entity)(style.label, entity.label);
            }
            return attr.style2Entity(style, entity.billboard);
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing() {
            var _this3 = this;

            var entity = this.entity;

            if (this.updateFeatureEx) {
                //setTimeout是为了优化效率
                if (this.updateTimer) {
                    clearTimeout(this.updateTimer);
                }
                this.updateTimer = setTimeout(function () {
                    delete _this3.updateTimer;
                    if (!entity) return;
                    _this3.updateFeatureEx(entity.attribute.style, entity);
                }, 300);
            }
        }
        //图形绘制结束,更新属性

    }, {
        key: 'finish',
        value: function finish() {
            if (this.updateFeatureEx && this.updateTimer) {
                clearTimeout(this.updateTimer);
                delete this.updateTimer;
                this.updateFeatureEx(this.entity.attribute.style, this.entity);
            }
            this.entity.show = true;

            this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象     
            this.entity.position = this.getDrawPosition();
        }
    }]);

    return DrawBillboard;
}(_Draw.DrawPoint);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TilesBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PolygonTextureVS = __webpack_require__(153);

var _PolygonTextureVS2 = _interopRequireDefault(_PolygonTextureVS);

var _PolygonTextureFS = __webpack_require__(154);

var _PolygonTextureFS2 = _interopRequireDefault(_PolygonTextureFS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 模型分析（裁剪、压平、淹没） 基础类
//原理：利用绘制的点数组，先计算其外包矩形，然后根据点创建一个polygonGeometry，然后利用此geometry创建指令，绘制出polygon纹理，
//源码里会根据此纹理判断模型顶点是否在polygon纹理中，如果在就进行后续操作


//多处压平思考：创建多个polygon纹理有点不大合理，一张FBO里多个polygon纹理，可能会导致压平闪烁（因为到着色器里，增大了顶点和polygon纹理的比对误差）
//多处压平思路之一张FBO里多个polygon纹理：就是想办法在我创建的FBO帧缓存里绘制多少polygon纹理，创建polygon数组，每次绘制都是往这里添加polygon，
//遍历polygon，依次创建指令绘制到fbo里
var TilesBase = exports.TilesBase = function () {
    //========== 构造方法 ========== 

    function TilesBase(options) {
        _classCallCheck(this, TilesBase);

        this.viewer = options.viewer;
        this.tileset = options.tileset;

        this.tileset.marsEditor = this.tileset.marsEditor || {};
        this.tileset.marsEditor.enable = true;
        this.positions = options.positions;
        this._b3dmOffset = options.b3dmOffset || new Cesium.Cartesian2();
        if (this.tileset && this.tileset._config && this.tileset._config.editOffset) {
            this.b3dmOffset = new Cesium.Cartesian2(this.tileset._config.editOffset.x, this.tileset._config.editOffset.y);
        }
        if (this.positions) {
            this._preparePos(this.positions);
        }
        if (this.localPosArr && !(options.floodAll === true)) {
            this._prepareWorks();
        }
    }

    //========== 对外属性 ==========  
    //编辑对象


    _createClass(TilesBase, [{
        key: "setPositions",


        //========== 方法 ========== 
        value: function setPositions(posArr) {
            if (!posArr || posArr.length == 0) return;

            this.positions = posArr;
            this._preparePos(this.positions);
            if (this.localPosArr) {
                this._prepareWorks();
                this.clear();
                this.activeEdit();
            }
        }

        //输入模型上方向轴向，目前使用实验室的工具，好像会把模型转成Z向上的，所以该功能已遗弃，未被使用

    }, {
        key: "setUpAxis",
        value: function setUpAxis(val) {
            if (val == "X") {
                this.base_height = this.flatRect[0];
                return;
            }
            if (val == "Y") {
                this.base_height = this.flatRect[1];
                return;
            }
            if (val == "Z") {
                this.base_height = this.flatRect[2];
                return;
            }
            this.base_height = this.flatRect[2];
        }
    }, {
        key: "_prepareWorks",
        value: function _prepareWorks() {
            //准备工作
            this._createTexture();
            this._createCommand();
        }
    }, {
        key: "_createTexture",
        value: function _createTexture() {
            //创建FBO以及清除指令
            var context = this.viewer.scene.context;
            var tt = new Cesium.Texture({
                context: context,
                width: 4096,
                height: 4096,
                pixelFormat: Cesium.PixelFormat.RGBA,
                pixelDatatype: Cesium.PixelDatatype.FLOAT,
                sampler: new Cesium.Sampler({
                    wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                    wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
                    minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                    magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
                })
            });

            var depthStencilTexture = new Cesium.Texture({
                context: context,
                width: 4096,
                height: 4096,
                pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
                pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
            });

            this.fbo = new Cesium.Framebuffer({
                context: context,
                colorTextures: [tt],
                depthStencilTexture: depthStencilTexture,
                destroyAttachments: false
            });

            this._fboClearCommand = new Cesium.ClearCommand({
                color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
                framebuffer: this.fbo
            });
        }
    }, {
        key: "_createCamera",
        value: function _createCamera() {
            //创建相机
            return {
                viewMatrix: Cesium.Matrix4.IDENTITY,
                inverseViewMatrix: Cesium.Matrix4.IDENTITY,
                frustum: new Cesium.OrthographicOffCenterFrustum(),
                positionCartographic: new Cesium.Cartographic(),
                positionWC: new Cesium.Cartesian3(),
                directionWC: Cesium.Cartesian3.UNIT_Z,
                upWC: Cesium.Cartesian3.UNIT_Y,
                rightWC: Cesium.Cartesian3.UNIT_X,
                viewProjectionMatrix: Cesium.Matrix4.IDENTITY
            };
        }
    }, {
        key: "_createPolygonGeometry",
        value: function _createPolygonGeometry() {
            //创建geometry
            var flattenPolygon = new Cesium.PolygonGeometry({
                polygonHierarchy: new Cesium.PolygonHierarchy(this.localPosArr),
                perPositionHeight: true
            });
            return Cesium.PolygonGeometry.createGeometry(flattenPolygon);
        }
    }, {
        key: "_createCommand",
        value: function _createCommand() {
            //创建指令
            var context = this.viewer.scene.context;
            var ppp = this._createPolygonGeometry();
            var _camera = this._createCamera();
            var sp = Cesium.ShaderProgram.fromCache({
                context: context,
                vertexShaderSource: _PolygonTextureVS2.default,
                fragmentShaderSource: _PolygonTextureFS2.default,
                attributeLocations: {
                    position: 0
                }
            });
            var vao = Cesium.VertexArray.fromGeometry({
                context: context,
                geometry: ppp,
                attributeLocations: sp._attributeLocations,
                bufferUsage: Cesium.BufferUsage.STATIC_DRAW,
                interleave: true
            });

            var rs = new Cesium.RenderState();
            rs.depthTest.enabled = false;
            rs.depthRange.near = -1000000.0;
            rs.depthRange.far = 1000000.0;

            var bg = Cesium.BoundingRectangle.fromPoints(this.localPosArr, new Cesium.BoundingRectangle());
            _camera.frustum.left = bg.x;
            _camera.frustum.top = bg.y + bg.height;
            _camera.frustum.right = bg.x + bg.width;
            _camera.frustum.bottom = bg.y;

            this._camera = _camera;

            var _myPorjection = Cesium.Matrix4.computeOrthographicOffCenter(_camera.frustum.left, _camera.frustum.right, _camera.frustum.bottom, _camera.frustum.top, _camera.frustum.near, _camera.frustum.far, new Cesium.Matrix4());

            this.polygonBounds = new Cesium.Cartesian4(_camera.frustum.left, _camera.frustum.bottom, _camera.frustum.right, _camera.frustum.top);

            this.drawCommand = new Cesium.DrawCommand({
                boundingVolume: ppp.boundingVolume,
                primitiveType: Cesium.PrimitiveType.TRIANGLES,
                vertexArray: vao,
                shaderProgram: sp,
                renderState: rs,
                pass: Cesium.Pass.CESIUM_3D_TILE,
                uniformMap: {
                    myPorjection: function myPorjection() {
                        return _myPorjection;
                    }
                }
            });
        }

        //重置编辑对象

    }, {
        key: "clear",
        value: function clear() {
            if (this._tileset && this.tileset.marsEditor) {
                this.tileset.marsEditor.IsYaPing = [false, false, false, false]; //[是否开启编辑，是否开启压平，是否开启裁剪，是否开启淹没]
                this.tileset.marsEditor.editVar = [false, false, false, false]; //[是否开启裁剪外部，是否开启淹没全局，]

                this.tileset.marsEditor.b3dmOffset = undefined;
                this.tileset.marsEditor.floodColor = [0.0, 0.0, 0.0, 0.5]; //[淹没颜色的r(0-1之间)，淹没颜色的g，淹没颜色的b，淹没混合系数（建议取值范围0.3-0.7）]
                this.tileset.marsEditor.floodVar = [0, 0, 0, 0]; //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
                this.tileset.marsEditor.heightVar = [0, 0]; //基础压平高度，调整压平高度值
                this.tileset.marsEditor.enable = false;
            }
            this.drawed = false;
        }
    }, {
        key: "activeEdit",
        value: function activeEdit() {}
    }, {
        key: "deActiveEdit",
        value: function deActiveEdit() {
            //激活
            this.tileset.marsEditor.IsYaPing[0] = false;
        }
    }, {
        key: "update",
        value: function update(frameState) {
            //更新
            if (this.drawed) return; //如果已经绘制过纹理，则退出，无需再绘制
            this.drawed = true;
            var context = frameState.context;
            var width = 4096;
            var height = 4096;
            if (!this._passState) {
                this._passState = new Cesium.PassState(context);
            }
            this._passState.framebuffer = this.fbo;
            this._passState.viewport = new Cesium.BoundingRectangle(0, 0, width, height);
            var us = context.uniformState;
            us.updateCamera(this._camera);
            us.updatePass(this.drawCommand.pass);
            this.drawCommand.framebuffer = this.fbo;
            this.drawCommand.execute(context, this._passState);
        }

        //预处理顶点

    }, {
        key: "_preparePos",
        value: function _preparePos(positions) {
            if (!positions || positions.length == 0) return;
            var localPos = [];
            var minHeight = 99999;
            var minLocalPos;
            for (var i = 0; i < positions.length; i++) {
                var cart = Cesium.Cartographic.fromCartesian(positions[i]);
                var height = cart.height;
                var currLocalPos = Cesium.Matrix4.multiplyByPoint(this.tileInverTransform, positions[i], new Cesium.Cartesian3());
                if (this.tileset._config) {
                    if (this.tileset._config.offset && this.tileset._config.offset.z) {
                        currLocalPos.z -= this.tileset._config.offset.z;
                    }
                    if (this.tileset._config.editOffset && this.tileset._config.editOffset.z) {
                        currLocalPos.z += this.tileset._config.editOffset.z;
                    }
                }
                localPos.push(currLocalPos);
                if (height < minHeight) {
                    minHeight = height;
                    minLocalPos = currLocalPos;
                }
            }
            this.minHeight = minHeight;
            this.minLocalPos = minLocalPos;
            this.localPosArr = localPos;
        }
    }, {
        key: "addToScene",
        value: function addToScene() {
            if (!this.viewer.scene.primitives.contains(this)) {
                this.viewer.scene.primitives.add(this);
            }
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            if (this.viewer.scene.primitives.contains(this)) {
                this.viewer.scene.primitives.remove(this);
                if (!this.viewer) return;
            }
            this.clear();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "tileset",
        get: function get() {
            return this._tileset;
        },
        set: function set(val) {
            this._tileset = val;
            var inverseMat = new Cesium.Matrix4();
            Cesium.Matrix4.fromArray(val._root.transform, 0, inverseMat);
            Cesium.Matrix4.inverse(inverseMat, inverseMat);
            this.tileInverTransform = inverseMat;
            if (this.tileset._config && this.tileset._config.editOffset) {
                this._b3dmOffset = new Cesium.Cartesian2(this.tileset._config.editOffset.x, this.tileset._config.editOffset.y);
            }
        }

        //偏移量

    }, {
        key: "b3dmOffset",
        get: function get() {
            return this._b3dmOffset;
        },
        set: function set(val) {
            if (!val) return;
            this._b3dmOffset.x = val.x || 0;
            this._b3dmOffset.y = val.y || 0;

            this.tileset.marsEditor.b3dmOffset = this.b3dmOffset;
        }
    }]);

    return TilesBase;
}();

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//当前版本  2020年10月1日 - 至今
exports.version = "2.2.0";
//发布时间
exports.update = "2020-11-7 17:35:55";

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewerEx = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _zepto = __webpack_require__(8);

var _Draw = __webpack_require__(6);

var _BaseLayer = __webpack_require__(15);

var _KeyboardRoam = __webpack_require__(70);

var _Popup = __webpack_require__(128);

var _Tooltip = __webpack_require__(129);

var _ContextMenu = __webpack_require__(130);

var _defaultContextMenu = __webpack_require__(71);

var _Location = __webpack_require__(131);

var _MouseZoomStyle = __webpack_require__(132);

var _util2 = __webpack_require__(1);

var _util = _interopRequireWildcard(_util2);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _layer2 = __webpack_require__(23);

var _layer = _interopRequireWildcard(_layer2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//一些默认值的修改【by 木遥】 
Cesium.Camera.DEFAULT_VIEW_RECTANGLE = Cesium.Rectangle.fromDegrees(89.5, 20.4, 110.4, 61.2); //更改默认视域


//Viewer扩展

var ViewerEx = exports.ViewerEx = function (_MarsClass) {
    _inherits(ViewerEx, _MarsClass);

    //========== 构造方法 ========== 
    function ViewerEx(viewer, config) {
        _classCallCheck(this, ViewerEx);

        var _this = _possibleConstructorReturn(this, (ViewerEx.__proto__ || Object.getPrototypeOf(ViewerEx)).call(this, config));

        _this.viewer = viewer;
        _this.viewer.mars = _this; //要记录下，内部用
        _this.config = Cesium.defaultValue(config, {});

        _this._isFlyAnimation = false;
        _this.crs = Cesium.defaultValue(_this.config.crs, '3857'); //坐标系 


        //优化viewer默认参数相关的
        _this._optimization();
        //根据参数进行设置相关的
        _this._initForOpts();
        //绑定处理的事件
        _this._initEvent();
        //绑定添加相关控件
        _this._addControls();
        //处理图层
        _this._initLayers();
        return _this;
    }
    //========== 对外属性 ==========   
    //标识只拾取模型上的点


    _createClass(ViewerEx, [{
        key: 'onClick',
        value: function onClick(fun) {
            //兼容历史命名
            this.on(_MarsClass2.eventType.click, fun);
        }

        //键盘漫游

    }, {
        key: '_optimization',


        //========== 方法 ========== 

        //优化viewer默认参数相关的
        value: function _optimization() {
            var that = this;
            var viewer = this.viewer;

            //二三维切换不用动画
            if (this.viewer.sceneModePicker) this.viewer.sceneModePicker.viewModel.duration = 0.0;

            //解决Cesium显示画面模糊的问题 https://zhuanlan.zhihu.com/p/41794242 【1.63已修复，1.66又出现了】
            this.viewer._cesiumWidget._supportsImageRenderingPixelated = Cesium.FeatureDetection.supportsImageRenderingPixelated();
            this.viewer._cesiumWidget._forceResize = true;
            if (Cesium.FeatureDetection.supportsImageRenderingPixelated()) {
                var _dpr = window.devicePixelRatio;
                // 适度降低分辨率
                while (_dpr >= 2.0) {
                    _dpr /= 2.0;
                }
                this.viewer.resolutionScale = _dpr;
            }
        }
        //根据参数进行设置相关的

    }, {
        key: '_initForOpts',
        value: function _initForOpts() {
            var that = this;
            this.viewer.cesiumWidget.creditContainer.style.display = "none"; //去cesium logo

            //默认定位地点相关设置，默认home键和初始化镜头视角  
            if (this.viewer.homeButton) {
                this.viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function (commandInfo) {
                    that.centerAtHome();
                    commandInfo.cancel = true;
                });
            }
            this.centerAtHome({ duration: 0 });

            //地球一些属性设置
            var scene = this.viewer.scene;
            scene.globe.baseColor = Cesium.Color.fromCssColorString(this.config.baseColor || "#546a53"); //地表背景色

            if (this.config.backgroundColor) scene.backgroundColor = Cesium.Color.fromCssColorString(this.config.backgroundColor); //空间背景色


            if (this.config.style) {
                //深度监测
                scene.globe.depthTestAgainstTerrain = this.config.style.testTerrain;

                //光照渲染（阳光照射区域高亮）
                scene.globe.enableLighting = this.config.style.lighting;

                //大气渲染
                scene.skyAtmosphere.show = this.config.style.atmosphere;
                scene.globe.showGroundAtmosphere = this.config.style.atmosphere;

                //雾化效果
                scene.fog.enabled = this.config.style.fog;

                //设置无地球模式 （单模型是可以设置为false）
                scene.globe.show = Cesium.defaultValue(this.config.style.globe, true);
                scene.moon.show = Cesium.defaultValue(this.config.style.moon, scene.globe.show);
                scene.sun.show = Cesium.defaultValue(this.config.style.sun, scene.globe.show);
                scene.skyBox.show = Cesium.defaultValue(this.config.style.skyBox, scene.globe.show);
            }

            //限制缩放级别
            scene.screenSpaceCameraController.maximumZoomDistance = Cesium.defaultValue(this.config.maxzoom, 20000000); //变焦时相机位置的最大值（以米为单位） 
            scene.screenSpaceCameraController.minimumZoomDistance = Cesium.defaultValue(this.config.minzoom, 1); //变焦时相机位置的最小量级（以米为单位）。默认为1.0。


            scene.screenSpaceCameraController._zoomFactor = 3; //鼠标滚轮放大的步长参数 
            scene.screenSpaceCameraController.minimumCollisionTerrainHeight = 15000000; //低于此高度时绕鼠标键绕圈，大于时绕视图中心点绕圈。
        }
        //绑定添加相关控件

    }, {
        key: '_addControls',
        value: function _addControls() {
            var that = this;

            //绑定popup 
            this._popup = new _Popup.Popup(this.viewer, {});

            //绑定tooltip 
            this._tooltip = new _Tooltip.Tooltip(this.viewer, {});

            //绑定键盘漫游 
            this._keyboardRoam = new _KeyboardRoam.KeyboardRoam({ viewer: this.viewer });

            //绑定右键菜单 
            if (this.config.contextmenu) {
                this._contextmenu = new _ContextMenu.ContextMenu(this.viewer);

                this.contextmenuItems = this.defaultContextmenuItems;
                this._contextmenu.resetDefault = function () {
                    //右键菜单还原为默认的
                    that.contextmenuItems = that.defaultContextmenuItems;
                };
            }

            //导航工具栏控件
            if (this.config.navigation) {
                this._addNavigationWidget(this.config.navigation);
            }

            //鼠标提示控件
            if (this.config.location) {
                this._location = new _Location.Location(this.viewer, this.config.location);
            }

            //鼠标滚轮缩放美化样式
            if (this.config.mouseZoom && _util.isPCBroswer()) {
                this._mouseZoomStyle = new _MouseZoomStyle.MouseZoomStyle(this.viewer, this.config.mouseZoom);
            }
        }
        //绑定处理的事件

    }, {
        key: '_initEvent',
        value: function _initEvent() {
            var _this2 = this;

            this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
            this.handler.setInputAction(function (event) {
                //单击事件
                _this2.fire(_MarsClass2.eventType.click, event);
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
            this.handler.setInputAction(function (event) {
                //鼠标移动事件
                _this2.fire(_MarsClass2.eventType.mouseMove, event);
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
        }

        //没有id的图层，进行id赋值处理

    }, {
        key: 'getNextId',
        value: function getNextId() {
            while (this.arrIdx.indexOf(this._tempIdx) != -1) {
                this._tempIdx++;
            }
            this.arrIdx.push(this._tempIdx);
            return this._tempIdx;
        }
        //添加内部封装的BaseLayer图层到OperationalLayer进行图层控制

    }, {
        key: 'addOperationalLayer',
        value: function addOperationalLayer(item) {
            var layer;
            if (item instanceof _BaseLayer.BaseLayer) {
                layer = item;
                item = layer.config;
            } else {
                var _visible = item.visible;
                delete item.visible;

                layer = new _BaseLayer.BaseLayer(this.viewer, item);
                layer._visible = _visible;

                if (!item.type) //外部通过bindToLayerControl添加的
                    item.type = "base";
            }

            if (!item.name) item.name = "未命名";
            if (!item.id) item.id = this.getNextId();else {
                if (this.layers[item.id]) {
                    marslog.warn("id:" + item.id + "冲突，请取一个比较大的数字，或请通过 viewer.mars.getNextId() 获取");
                    item.id = this.getNextId();
                }
            }
            if (!item.pid) item.pid = -1;

            item.hasLayer = true;

            this.config.operationallayers.push(item);
            this.arrOperationallayers.push(layer);
            this.layers[item.id] = layer;

            return layer;
        }
    }, {
        key: 'removeOperationalLayer',
        value: function removeOperationalLayer(id) {
            for (var i = 0; i < this.config.operationallayers.length; i++) {
                var item = this.config.operationallayers[i];
                if (item.id == id) {
                    this.config.operationallayers.splice(i, 1);
                    break;
                }
            }
            for (var i = 0; i < this.arrOperationallayers.length; i++) {
                var item = this.arrOperationallayers[i];
                if (item.config.id == id) {
                    this.arrOperationallayers.splice(i, 1);
                    break;
                }
            }

            delete this.layers[id];
        }
        //处理图层

    }, {
        key: '_initLayers',
        value: function _initLayers() {
            this.config.basemaps = this.config.basemaps || [];
            this.config.operationallayers = this.config.operationallayers || [];

            var basemapsCfg = this.config.basemaps;
            var operationallayersCfg = this.config.operationallayers;

            var layersCfg = []; //计算order

            //记录所有id，方便计算nextid
            this._tempIdx = 1;
            this.arrIdx = [];
            for (var i = 0; i < basemapsCfg.length; i++) {
                var item = basemapsCfg[i];

                if (item.id) this.arrIdx.push(item.id);
            }
            for (var i = 0; i < operationallayersCfg.length; i++) {
                var item = operationallayersCfg[i];
                if (item.id) this.arrIdx.push(item.id);
            }

            var objLayers = {}; //图层对象
            var arrBasemaps = []; //底图数组
            var arrOperationallayers = []; //可叠加图层  

            //底图处理
            if (!this.config.baseLayerPicker) {
                //不能取消，如果取消，使用baseLayerPicker时无法切换了
                if (basemapsCfg && basemapsCfg.length > 0) {
                    for (var i = 0; i < basemapsCfg.length; i++) {
                        var item = basemapsCfg[i];
                        if (!item.name) item.name = "未命名";
                        if (!item.id) item.id = this.getNextId();
                        if (!item.pid) item.pid = -1;

                        if (item.visible && item.crs) this.crs = item.crs;

                        var layer = _layer.createLayer(this.viewer, item, this.config.serverURL);
                        if (layer) {
                            item.hasLayer = true;
                            objLayers[item.id] = layer;
                            arrBasemaps.push(layer);

                            if (this.config.onAddLayer) {
                                //加图层回调方法
                                this.config.onAddLayer(item, layer);
                            }
                        }

                        layersCfg.push(item);
                        if (item.type == "group" && item.layers) {
                            for (var idx = 0; idx < item.layers.length; idx++) {
                                var childitem = item.layers[idx];
                                childitem.pid = item.id;
                                childitem.id = this.getNextId();
                                layersCfg.push(childitem);
                            }
                        }
                    }
                }
            }
            this.arrBasemaps = arrBasemaps;

            //可叠加图层  
            if (operationallayersCfg && operationallayersCfg.length > 0) {
                for (var i = 0; i < operationallayersCfg.length; i++) {
                    var item = operationallayersCfg[i];
                    if (!item.name) item.name = "未命名";
                    if (!item.id) item.id = this.getNextId();
                    if (!item.pid) item.pid = -1;

                    var layer = _layer.createLayer(this.viewer, item, this.config.serverURL);
                    if (layer) {
                        item.hasLayer = true;
                        arrOperationallayers.push(layer);
                        objLayers[item.id] = layer;

                        if (this.config.onAddLayer) {
                            //加图层回调方法
                            this.config.onAddLayer(item, layer);
                        }
                    }

                    layersCfg.push(item);
                    if (item.type == "group" && item.layers) {
                        for (var idx = 0; idx < item.layers.length; idx++) {
                            var childitem = item.layers[idx];
                            childitem.pid = item.id;
                            childitem.id = this.getNextId();
                            layersCfg.push(childitem);
                        }
                    }
                }
            }
            this.arrOperationallayers = arrOperationallayers;
            this.layers = objLayers;

            //计算 顺序字段,
            for (var i = 0; i < layersCfg.length; i++) {
                var item = layersCfg[i];

                //计算层次顺序
                var order = Number(item.order);
                if (isNaN(order)) order = i;
                item.order = order;

                //图层的处理
                if (objLayers[item.id] != null) {
                    objLayers[item.id].setZIndex(order);
                }
            }
        }
    }, {
        key: 'getConfig',
        value: function getConfig() {
            return _util.clone(this.config, ["_layer", "_layers", "_parent"]);
        }

        //point的方法兼容到viewer.mars直接用

    }, {
        key: 'getCenter',
        value: function getCenter(isToWgs) {
            return point.getCenter(this.viewer, isToWgs);
        }
    }, {
        key: 'getExtent',
        value: function getExtent(opts) {
            return point.getExtent(this.viewer, opts);
        }
    }, {
        key: 'getCameraView',
        value: function getCameraView(isToWgs) {
            return point.getCameraView(this.viewer, isToWgs);
        }
    }, {
        key: 'getSurfaceHeight',
        value: function getSurfaceHeight(position, opts) {
            return point.getSurfaceHeight(this.viewer.scene, position, opts);
        }

        //键盘漫游，兼容历史方法

    }, {
        key: 'keyboard',
        value: function keyboard(isbind, opts) {
            if (isbind) this._keyboardRoam.bind(opts);else this._keyboardRoam.unbind();
        }
    }, {
        key: 'keyboardAuto',
        value: function keyboardAuto() {
            return this._keyboardRoam.enable = !this._keyboardRoam.enable;
        }

        //获取指定图层 keyname默认为名称

    }, {
        key: 'getLayer',
        value: function getLayer(key, keyname) {
            if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                //直接传入config的object对象时
                if (Cesium.defined(key.id)) return this.layers[key.id];
            } else {
                if (keyname == null) {
                    if (_util.isNumber(key)) keyname = "id";else keyname = "name";
                }

                var layersCfg = this.arrBasemaps;
                if (layersCfg && layersCfg.length > 0) {
                    for (var i = 0; i < layersCfg.length; i++) {
                        var item = layersCfg[i];
                        if (item == null || item.config[keyname] != key) continue;
                        return item;
                    }
                }

                layersCfg = this.arrOperationallayers;
                if (layersCfg && layersCfg.length > 0) {
                    for (var i = 0; i < layersCfg.length; i++) {
                        var item = layersCfg[i];
                        if (item == null || item.config[keyname] != key) continue;
                        return item;
                    }
                }
            }

            return null;
        }
        //获取当前显示的底图

    }, {
        key: 'getBasemap',
        value: function getBasemap() {
            var layersCfg = this.arrBasemaps;
            if (layersCfg.length == 0) {
                if (this.viewer.baseLayerPicker) {
                    return this.viewer.baseLayerPicker.viewModel.selectedImagery;
                }
                return;
            }

            for (var i = 0; i < layersCfg.length; i++) {
                var item = layersCfg[i];
                if (item.config.type == "group" && item.config.layers == null) continue;

                if (item._visible) {
                    return item;
                }
            }
        }
        //根据config配置的id或name属性，更新显示指定的地图底图

    }, {
        key: 'changeBasemap',
        value: function changeBasemap(idorname) {
            var layersCfg = this.arrBasemaps;
            if (layersCfg.length == 0) {
                if (this.viewer.baseLayerPicker) {
                    var baseLayer = this.viewer.baseLayerPicker.viewModel;

                    var sel;
                    if (idorname) {
                        var index;
                        for (var i = 0; i < this.config.basemaps.length; i++) {
                            var item = this.config.basemaps[i];
                            if (item.type == "group" && item.layers == null) continue;

                            if (idorname == item || idorname == item.name || idorname == item.id) {
                                index = i;
                                break;
                            }
                        }
                        if (Cesium.defined(index)) {
                            sel = baseLayer.imageryProviderViewModels[index];
                        }
                    }
                    baseLayer.selectedImagery = sel;
                }
                return;
            }

            var basemap;
            for (var i = 0; i < layersCfg.length; i++) {
                var item = layersCfg[i];
                if (item.config.type == "group" && item.config.layers == null) continue;

                if (idorname == item || idorname == item.config.name || idorname == item.config.id) {
                    item.setVisible(true);
                    this.crs = item.config.crs; //坐标系 

                    basemap = item;
                } else {
                    item.setVisible(false);
                }
            }
            return basemap;
        }
        //是否有地形数据

    }, {
        key: 'hasTerrain',
        value: function hasTerrain() {
            if (this.terrainProvider == null) return false;
            return _layer.hasTerrain(this.viewer);
        }
        //更新地形，参数传入是否显示地形

    }, {
        key: 'updateTerrainProvider',
        value: function updateTerrainProvider(isStkTerrain) {
            if (isStkTerrain) {
                if (this.terrainProvider == null) {
                    var cfg = this.config.terrain;
                    if (cfg && cfg.url) {
                        if (this.config.serverURL) {
                            cfg.url = cfg.url.replace('$serverURL$', this.config.serverURL);
                        }
                        cfg.url = cfg.url.replace('$hostname$', location.hostname).replace('$host$', location.host);
                    }
                    this.terrainProvider = _layer.getTerrainProvider(cfg);
                }
                this.viewer.terrainProvider = this.terrainProvider;
            } else {
                this.viewer.terrainProvider = _layer.getEllipsoidTerrain();
            }
        }

        //获取当前地图坐标系，值为gcj时表示是国测局偏移坐标

    }, {
        key: 'getCrs',
        value: function getCrs() {
            return this.crs;
        }
        //在不同坐标系情况下，转换“目标坐标值”至“地图坐标系”一致的坐标

    }, {
        key: 'point2map',
        value: function point2map(point) {
            switch (this.crs) {
                case "gcj":
                    var point_clone = _util.clone(point);

                    var newpoint = pointconvert.wgs2gcj([point_clone.x, point_clone.y]);
                    point_clone.x = newpoint[0];
                    point_clone.y = newpoint[1];
                    return point_clone;
                    break;
                case "bd":
                case "baidu":
                    var point_clone = _util.clone(point);

                    var newpoint = pointconvert.wgs2bd([point_clone.x, point_clone.y]);
                    point_clone.x = newpoint[0];
                    point_clone.y = newpoint[1];
                    return point_clone;
                    break;
                default:
                    return point;
                    break;
            }
        }
        //在不同坐标系情况下 ，获取地图上的坐标后，转为wgs标准坐标系坐标值

    }, {
        key: 'point2wgs',
        value: function point2wgs(point) {
            switch (this.crs) {
                case "gcj":
                    var point_clone = _util.clone(point);
                    var newpoint = pointconvert.gcj2wgs([point_clone.x, point_clone.y]);
                    point_clone.x = newpoint[0];
                    point_clone.y = newpoint[1];
                    return point_clone;
                    break;
                case "bd":
                case "baidu":
                    var point_clone = _util.clone(point);
                    var newpoint = pointconvert.bd2wgs([point_clone.x, point_clone.y]);
                    point_clone.x = newpoint[0];
                    point_clone.y = newpoint[1];
                    return point_clone;
                    break;
                default:
                    return point;
                    break;
            }
        }

        //定位到 多个区域  顺序播放

    }, {
        key: 'centerAtArr',
        value: function centerAtArr(arr, enfun) {
            this.cancelCenterAt();

            this.arrCenterTemp = arr;
            this._isCenterAtArr = true;
            this._centerAtArrItem(0, enfun);
        }
    }, {
        key: '_centerAtArrItem',
        value: function _centerAtArrItem(i, enfun) {
            var that = this;
            if (!this._isCenterAtArr || i < 0 || i >= this.arrCenterTemp.length) {
                this._isCenterAtArr = false;
                //marslog.log('centerAtArr视角切换全部结束');
                if (enfun) enfun();
                return;
            }
            var centeropt = this.arrCenterTemp[i];

            //marslog.log('centerAtArr开始视角切换，第' + i + '点');
            if (centeropt.onStart) centeropt.onStart();

            this.centerAt(centeropt, {
                duration: centeropt.duration,
                complete: function complete() {
                    if (centeropt.onEnd) centeropt.onEnd();

                    var stopTime = Cesium.defaultValue(centeropt.stop, 1);
                    //marslog.log('centerAtArr第' + i + '点切换结束，将在此停留' + stopTime + '秒');

                    setTimeout(function () {
                        that._centerAtArrItem(++i, enfun);
                    }, stopTime * 1000);
                },
                cancle: function cancle() {
                    this._isCenterAtArr = false;
                    if (enfun) enfun();
                }
            });
        }
    }, {
        key: 'cancelCenterAt',
        value: function cancelCenterAt() {
            this._isCenterAtArr = false;
            this.viewer.camera.cancelFlight(); //取消飞行 
        }
    }, {
        key: 'centerAtHome',
        value: function centerAtHome(options) {
            this.centerAt(this.config.extent || this.config.center, options);
        }
        //地球定位至指定区域 ，options支持viewer.camera.flyTo所有参数

    }, {
        key: 'centerAt',
        value: function centerAt(centeropt, options) {
            if (options == null) options = {};else if (_util.isNumber(options)) {
                options = { //兼容旧版本
                    duration: options
                };
            }

            if (centeropt == null) {
                //让镜头飞行（动画）到配置默认区域 
                options.isWgs84 = true;
                centeropt = this.config.extent || this.config.center;
            }
            if (centeropt == null) return;

            var optsClone = {};
            for (var key in options) {
                optsClone[key] = options[key];
            }

            if (centeropt.xmin && centeropt.xmax && centeropt.ymin && centeropt.ymax) {
                //使用extent配置，相机可视范围
                var xmin = centeropt.xmin;
                var xmax = centeropt.xmax;
                var ymin = centeropt.ymin;
                var ymax = centeropt.ymax;

                if (optsClone.isWgs84) {
                    //坐标转换为wgs
                    var pt1 = this.point2map({
                        x: xmin,
                        y: ymin
                    });
                    xmin = pt1.x;
                    ymin = pt1.y;

                    var pt2 = this.point2map({
                        x: xmax,
                        y: ymax
                    });
                    xmax = pt2.x;
                    ymax = pt2.y;
                }

                //方法1：绑定范围 （存在区域在地形下的情况，极端示例在珠峰测试）
                // optsClone.destination = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);

                //方法2：(计算矩形边长+高度后定位)
                var centerx = (xmin + xmax) / 2;
                var centery = (ymin + ymax) / 2;
                //求矩形最大边的边长
                var recta = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);
                var granularity = Math.max(recta.height, recta.width);
                var len = Cesium.Math.chordLength(granularity, this.viewer.scene.globe.ellipsoid.maximumRadius);
                //求高度
                var height = Cesium.defaultValue(centeropt.height, 0);
                if (height == 0) {
                    height = point.getSurfaceHeight(this.viewer.scene, Cesium.Cartesian3.fromDegrees(centerx, centery));
                }

                optsClone.destination = Cesium.Cartesian3.fromDegrees(centerx, centery, len + height); //经度、纬度、高度 
                optsClone.orientation = {
                    heading: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.heading, 0)), //绕垂直于地心的轴旋转
                    pitch: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.pitch, -90)), //绕纬度线旋转
                    roll: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.roll, 0)) //绕经度线旋转
                };
                //方法2   end 

                this.viewer.camera.flyTo(optsClone);
            } else {
                //存在hpr，为相机定位的方式 
                if (optsClone.isWgs84) centeropt = this.point2map(centeropt);

                var height = Cesium.defaultValue(optsClone.minz, 2500);
                if (this.viewer.camera.positionCartographic.height < height) height = this.viewer.camera.positionCartographic.height;
                if (centeropt.z != null && centeropt.z != 0) height = centeropt.z;

                optsClone.destination = Cesium.Cartesian3.fromDegrees(centeropt.x, centeropt.y, height); //经度、纬度、高度 
                optsClone.orientation = {
                    heading: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.heading, 0)), //绕垂直于地心的轴旋转
                    pitch: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.pitch, -90)), //绕纬度线旋转
                    roll: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.roll, 0)) //绕经度线旋转
                };
                this.viewer.camera.flyTo(optsClone);
            }
        }
        //定位至目标点， options支持viewer.camera.flyToBoundingSphere所有参数

    }, {
        key: 'centerPoint',
        value: function centerPoint(centeropt, options) {

            if (options == null) options = {};

            var optsClone = {};
            for (var key in options) {
                optsClone[key] = options[key];
            }

            //目标点位置 
            if (optsClone.isWgs84) centeropt = this.point2map(centeropt);

            var position;
            if (centeropt instanceof Cesium.Cartesian3) position = centeropt;else position = Cesium.Cartesian3.fromDegrees(centeropt.x, centeropt.y, Cesium.defaultValue(centeropt.z, 0)); //经度、纬度、高度  
            var radius = Cesium.defaultValue(options.radius, 1000);

            optsClone.offset = {
                heading: Cesium.Math.toRadians(Cesium.defaultValue(options.heading, 0)),
                pitch: Cesium.Math.toRadians(Cesium.defaultValue(options.pitch, -90)),
                range: radius
            };
            //duration
            this.viewer.camera.flyToBoundingSphere(new Cesium.BoundingSphere(position, 0), optsClone);
        }

        //视角飞行定位到entiy处

    }, {
        key: 'flyTo',
        value: function flyTo(entity, opts) {
            if (!entity) return;

            opts = opts || {};
            opts.scale = Cesium.defaultValue(opts.scale, 0.5);

            if (entity.entities && entity.entities instanceof Cesium.EntityCollection) {
                entity = entity.entities.values;
            }

            if (_util.isArray(entity)) {
                if (entity.length == 0) return;

                if (entity.length == 1) {
                    this.flyTo(entity[0], opts);
                } else {
                    //entity是数组
                    var extent = point.getExtent(entity, opts);
                    if (extent.xmin == extent.xmax || extent.ymin == extent.ymax) {
                        //说明是单个的点数据（也有可能重合的多个点）
                        this.flyTo(entity[0], opts);
                    } else if (extent.xmax - extent.xmin > 200) {
                        //跨了180度线时
                        this.viewer.flyTo(entity[0], opts);
                    } else {
                        //是矩形区域时
                        this.centerAt(extent, opts);
                    }
                }
            } else if (entity instanceof Cesium.Entity) {
                //点状数据时
                if (entity.position) {
                    var position = point.getPositionValue(entity.position);
                    this.centerPoint(position, opts);
                }
                //圆数据时
                else if (entity.ellipse) {
                        var radius1 = entity.ellipse.semiMajorAxis.getValue(_util.currentTime());
                        var radius2 = entity.ellipse.semiMinorAxis.getValue(_util.currentTime());

                        opts.radius = Math.max(radius1, radius2) * 3 * (1 + opts.scale);

                        var position = point.getPositionValue(entity.position);
                        this.centerPoint(position, opts);
                    } else {
                        var extent = point.getExtent(entity, opts);
                        if (extent.xmin == extent.xmax || extent.ymin == extent.ymax) {
                            //说明是单个的点数据（也有可能重合的多个点）
                            var position = {
                                x: extent.xmin,
                                y: extent.ymin
                            };
                            this.centerPoint(position, opts);
                        } else if (extent.xmax - extent.xmin > 200) {
                            //跨了180度线时
                            this.viewer.flyTo(entity, opts);
                        } else {
                            //是矩形区域时
                            this.centerAt(extent, opts);
                        }
                    }
            } else {
                this.viewer.flyTo(entity, opts);
            }
        }

        //是否在调用了openFlyAnimation正在进行飞行动画

    }, {
        key: 'isFlyAnimation',
        value: function isFlyAnimation() {
            return this._isFlyAnimation;
        }
        //开场动画，动画播放地球飞行定位指指定区域（默认为config.josn中配置的视域）

    }, {
        key: 'openFlyAnimation',
        value: function openFlyAnimation(endfun, centeropt) {
            var that = this;
            var viewer = this.viewer;
            var view = centeropt || point.getCameraView(viewer); //默认为原始视角

            this._isFlyAnimation = true;
            viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(-85.16, 13.71, 23000000.0)
            });
            viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(view.x, view.y, 23000000.0),
                duration: 2,
                easingFunction: Cesium.EasingFunction.LINEAR_NONE,
                complete: function complete() {
                    var z = Cesium.defaultValue(view.z, 90000);
                    if (z < 200000 && view.pitch != -90) {
                        z = z * 1.2 + 8000;
                        viewer.camera.flyTo({
                            destination: Cesium.Cartesian3.fromDegrees(view.x, view.y, z),
                            complete: function complete() {
                                that.centerAt(view, {
                                    duration: 2,
                                    complete: function complete() {
                                        that._isFlyAnimation = false;
                                        if (endfun) endfun();
                                        if (that.openFlyAnimationEndFun) {
                                            that.openFlyAnimationEndFun();
                                            delete that.openFlyAnimationEndFun;
                                        }
                                    }
                                });
                            }
                        });
                    } else {
                        that.centerAt(view, {
                            complete: function complete() {
                                that._isFlyAnimation = false;
                                if (endfun) endfun();
                                if (that.openFlyAnimationEndFun) {
                                    that.openFlyAnimationEndFun();
                                    delete that.openFlyAnimationEndFun;
                                }
                            }
                        });
                    }
                }
            });
        }
        //旋转地球 

    }, {
        key: 'rotateAnimation',
        value: function rotateAnimation(endfun, duration) {
            var viewer = this.viewer;

            var first = point.getCameraView(viewer); //默认为原始视角
            var duration3 = duration / 3;

            //动画 1/3
            viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(first.x + 120, first.y, first.z),
                orientation: {
                    heading: Cesium.Math.toRadians(first.heading),
                    pitch: Cesium.Math.toRadians(first.pitch),
                    roll: Cesium.Math.toRadians(first.roll)
                },
                duration: duration3,
                easingFunction: Cesium.EasingFunction.LINEAR_NONE,
                complete: function complete() {

                    //动画 2/3
                    viewer.camera.flyTo({
                        destination: Cesium.Cartesian3.fromDegrees(first.x + 240, first.y, first.z),
                        orientation: {
                            heading: Cesium.Math.toRadians(first.heading),
                            pitch: Cesium.Math.toRadians(first.pitch),
                            roll: Cesium.Math.toRadians(first.roll)
                        },
                        duration: duration3,
                        easingFunction: Cesium.EasingFunction.LINEAR_NONE,
                        complete: function complete() {

                            //动画 3/3
                            viewer.camera.flyTo({
                                destination: Cesium.Cartesian3.fromDegrees(first.x, first.y, first.z),
                                orientation: {
                                    heading: Cesium.Math.toRadians(first.heading),
                                    pitch: Cesium.Math.toRadians(first.pitch),
                                    roll: Cesium.Math.toRadians(first.roll)
                                },
                                duration: duration3,
                                easingFunction: Cesium.EasingFunction.LINEAR_NONE,
                                complete: function complete() {
                                    if (endfun) endfun();
                                }
                            });
                            //动画3/3 end 
                        }
                    });
                    //动画2/3 end
                }
            });
            //动画1/3 end
        }

        //添加“导航”控件

    }, {
        key: '_addNavigationWidget',
        value: function _addNavigationWidget(item) {
            if (Cesium.viewerCesiumNavigationMixin) {
                //兼容v1版本
                this.viewer.extend(Cesium.viewerCesiumNavigationMixin, {
                    defaultResetView: Cesium.Rectangle.fromDegrees(110, 20, 120, 30),
                    enableZoomControls: false
                });
            }

            if (Cesium.CesiumNavigation) {
                //当前版本
                var options = {};
                // 用于在使用重置导航重置地图视图时设置默认视图控制。接受的值是Cesium.Cartographic 和 Cesium.Rectangle.
                options.defaultResetView = Cesium.Rectangle.fromDegrees(110, 20, 120, 30);
                // 用于启用或禁用罗盘。true是启用罗盘，false是禁用罗盘。默认值为true。如果将选项设置为false，则罗盘将不会添加到地图中。
                options.enableCompass = true;
                // 用于启用或禁用缩放控件。true是启用，false是禁用。默认值为true。如果将选项设置为false，则缩放控件将不会添加到地图中。
                options.enableZoomControls = false;
                // 用于启用或禁用距离图例。true是启用，false是禁用。默认值为true。如果将选项设置为false，距离图例将不会添加到地图中。
                options.enableDistanceLegend = true;
                // 用于启用或禁用指南针外环。true是启用，false是禁用。默认值为true。如果将选项设置为false，则该环将可见但无效。
                options.enableCompassOuterRing = true;

                Cesium.CesiumNavigation(this.viewer, options);
            }

            //比例尺
            (0, _zepto.zepto)(".distance-legend").css({
                "left": "-10px",
                "bottom": "-1px",
                "border": "none",
                "background": "rgba(0, 0, 0, 0)"
            });

            if (item.legend) {
                var css = item.legend;
                //插件的默认值：right: 25px; bottom: 30px;
                if (Cesium.defined(css.top) && css.top != "auto") {
                    css.bottom = "auto";
                }
                if (Cesium.defined(css.left) && css.left != "auto") {
                    css.right = "auto";
                }

                (0, _zepto.zepto)(".distance-legend").css(css);
            } else {
                (0, _zepto.zepto)(".distance-legend").remove();
            }

            //导航球
            if (item.compass) {
                var css = item.compass;
                //插件的默认值： top: 100px; right: 0; 
                if (Cesium.defined(css.bottom) && css.bottom != "auto") {
                    css.top = "auto";
                }
                if (Cesium.defined(css.left) && css.left != "auto") {
                    css.right = "auto";
                }
                (0, _zepto.zepto)(".compass").css(css);
            } else {
                (0, _zepto.zepto)(".compass").remove();
            }

            //zepto(".navigation-controls").css({
            //    "right": "5px",
            //    "bottom": "30px",
            //    "top": "auto"
            //});
            (0, _zepto.zepto)(".navigation-controls").remove();
        }
        //导出场景图片，截图

    }, {
        key: 'expImage',
        value: function expImage(opts) {
            opts = opts || {};
            opts.download = Cesium.defaultValue(opts.download, true);
            opts.type = Cesium.defaultValue(opts.type, "image/jpeg");

            var width, height;
            var viewer = this.viewer;
            var callback = opts.callback || opts.calback;

            viewer.render();
            var imgdata = viewer.canvas.toDataURL(opts.type, opts.encoderOptions);

            if (Cesium.defined(opts.width) || Cesium.defined(opts.height)) {
                //指定了高或宽度后，图片压缩处理
                var image = new Image();
                image.onload = function () {
                    //图片压缩处理

                    if (Cesium.defined(opts.width)) {
                        width = opts.width;
                        height = opts.height || Math.round(width * viewer.canvas.height / viewer.canvas.width);
                    } else {
                        height = opts.height;
                        width = Math.round(height * viewer.canvas.width / viewer.canvas.height);
                    }

                    var canvas, ctx;
                    canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    ctx = canvas.getContext("2d");
                    ctx.drawImage(image, 0, 0, width, height);
                    var imgdataNew = canvas.toDataURL(opts.type, opts.encoderOptions);

                    if (!opts.filename) {
                        opts.filename = "场景出图_" + width + "x" + height;
                    }
                    if (opts.download) _util.downloadBase64Image(opts.filename, imgdataNew);
                    if (callback) callback(imgdataNew, {
                        width: width,
                        height: height
                    });
                };
                image.src = imgdata;
            } else {
                //高清原图
                height = viewer.canvas.height, width = viewer.canvas.width;

                if (!opts.filename) {
                    opts.filename = "场景出图_" + width + "x" + height;
                }
                if (opts.download) _util.downloadBase64Image(opts.filename, imgdata);
                if (callback) callback(imgdata, {
                    width: width,
                    height: height
                });
            }
        }

        //销毁资源

    }, {
        key: 'destroy',
        value: function destroy() {
            this.handler.destroy();
            this._tooltip.destroy();
            this._popup.destroy();

            if (this._keyboardRoam) {
                this._keyboardRoam.destroy();
                this._keyboardRoam = null;
            }

            if (this._contextmenu) {
                this._contextmenu.destroy();
                this._contextmenu = null;
            }

            if (this._location) {
                this._location.destroy();
                this._location = null;
            }
            if (this._mouseZoomStyle) {
                this._mouseZoomStyle.destroy();
                this._mouseZoomStyle = null;
            }

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: 'onlyPickModelPosition',
        get: function get() {
            return this.viewer.scene.onlyPickModelPosition;
        },
        set: function set(value) {
            this.viewer.scene.onlyPickModelPosition = value;
        }

        //单击事件(单个时，主要为了兼容历史版本或单次简单场景下使用) 

    }, {
        key: 'click',
        set: function set(value) {
            this.on(_MarsClass2.eventType.click, value);
        }
    }, {
        key: 'keyboardRoam',
        get: function get() {
            return this._keyboardRoam;
        }
    }, {
        key: 'contextmenu',
        get: function get() {
            return this._contextmenu;
        }
    }, {
        key: 'location',
        get: function get() {
            return this._location;
        }
    }, {
        key: 'popup',
        get: function get() {
            return this._popup;
        }
    }, {
        key: 'tooltip',
        get: function get() {
            return this._tooltip;
        }

        //右键菜单 

    }, {
        key: 'contextmenuItems',
        get: function get() {
            return this._contextmenuItems;
        },
        set: function set(val) {
            this._contextmenuItems = val;
        }
    }, {
        key: 'defaultContextmenuItems',
        get: function get() {
            return this.config.contextmenuItems || (0, _defaultContextMenu.getDefaultContextMenu)(this.viewer);
        }

        //默认绑定的draw控件

    }, {
        key: 'draw',
        get: function get() {
            if (this._drawControl == null) {
                this._drawControl = new _Draw.Draw(this.viewer, {
                    hasEdit: false
                });
            }
            return this._drawControl;
        }

        //获取地图层级（概略）

    }, {
        key: 'level',
        get: function get() {
            var height = this.viewer.camera.positionCartographic.height;
            if (height == this._prevCameraHeight) {
                return this._level;
            }
            this._level = _util.heightToZoom(height);
            this._prevCameraHeight = height;
            return this._level;
        }
    }]);

    return ViewerEx;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


ViewerEx.event = {
    click: _MarsClass2.eventType.click,
    clickMap: _MarsClass2.eventType.clickMap,
    mouseMove: _MarsClass2.eventType.mouseMove

    //绑定到Viewer上
};Object.defineProperties(Cesium.Viewer.prototype, {
    mars: {
        set: function set(value) {
            this._mars = value;
        },
        get: function get() {
            if (!this._mars) {
                this._mars = new ViewerEx(this);
            }
            return this._mars;
        }
    }
});

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

var _globe = __webpack_require__(18);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值 
        entityattr = {};
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":
            case "dimensionsY":
            case "plane_distance":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                break;
            case "color":
                //填充颜色
                entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                break;
            case "dimensionsX":
                //平面的长宽
                var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
                var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
                entityattr.dimensions = new Cesium.Cartesian2(dimensionsX, dimensionsY);
                break;
            case "plane_normal":
                //平面的方向及距离
                var plane_normal;
                switch (value) {
                    case "x":
                        plane_normal = Cesium.Cartesian3.UNIT_X;
                        break;
                    case "y":
                        plane_normal = Cesium.Cartesian3.UNIT_Y;
                        break;
                    default:
                        plane_normal = Cesium.Cartesian3.UNIT_Z;
                        break;
                }
                var plane_distance = Cesium.defaultValue(style.plane_distance, 0.0);
                entityattr.plane = new Cesium.Plane(plane_normal, plane_distance);
                break;
            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;

            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
        }
    }

    //设置填充材质
    globe.setFillMaterial(entityattr, style);

    return entityattr;
}

//获取entity的坐标
//平面
function getPositions(entity) {
    return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: { type: "Point", coordinates: coordinates[0] }
    };
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CircleWaveMaterial = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _CircleWaveMaterial = __webpack_require__(97);

var _CircleWaveMaterial2 = _interopRequireDefault(_CircleWaveMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultColor = new Cesium.Color(0, 0, 0, 0);
var count = 2;
var gradient = 0.1;

//圆形 单个扩散效果 材质 

var CircleWaveMaterial = exports.CircleWaveMaterial = function () {
    //========== 构造方法 ========== 
    function CircleWaveMaterial(options) {
        _classCallCheck(this, CircleWaveMaterial);

        options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

        this._definitionChanged = new Cesium.Event();
        this._color = undefined;
        this._colorSubscription = undefined;

        this.color = Cesium.defaultValue(options.color, defaultColor); //颜色
        this._duration = Cesium.defaultValue(options.duration, 1000); //时长
        this._count = Cesium.defaultValue(options.count, count); //圆圈个数
        if (this._count <= 0) this._count = 1;

        this._gradient = Cesium.defaultValue(options.gradient, gradient); //透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变
        if (this._gradient < 0) this._gradient = 0;
        if (this._gradient > 1) this._gradient = 1;

        this._time = undefined;
    }

    //========== 对外属性 ==========  


    _createClass(CircleWaveMaterial, [{
        key: "getType",


        //========== 方法 ========== 
        /**
         * Gets the {@link Cesium.Material} type at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the type.
         * @returns {String} The type of material.
         */
        value: function getType(time) {
            return Cesium.Material.CircleWaveMaterialType;
        }

        /**
         * Gets the value of the property at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */

    }, {
        key: "getValue",
        value: function getValue(time, result) {
            if (!Cesium.defined(result)) {
                result = {};
            }
            result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);

            if (this._time === undefined) {
                this._time = new Date().getTime();
            }
            result.time = (new Date().getTime() - this._time) / this._duration;
            result.count = this._count;
            result.gradient = 1 + 10 * (1 - this._gradient);
            return result;
        }

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param { Cesium.Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */

    }, {
        key: "equals",
        value: function equals(other) {
            return this === other || //
            other instanceof CircleWaveMaterial && Cesium.Property.equals(this._color, other._color);
        }
    }, {
        key: "isConstant",
        get: function get() {
            return false;
        }
    }, {
        key: "definitionChanged",
        get: function get() {
            return this._definitionChanged;
        }
    }]);

    return CircleWaveMaterial;
}();

Object.defineProperties(CircleWaveMaterial.prototype, {
    /**
     * Gets or sets the  Cesium.Property specifying the {@link Cesium.Color} of the line.
     * @memberof PolylineGlowMaterialProperty.prototype
     * @type { Cesium.Property}
     */
    color: Cesium.createPropertyDescriptor('color')
});

//静态方法，处理材质
Cesium.Material.CircleWaveMaterialType = 'CircleWaveMaterial'; /**  渐变的气泡 */
Cesium.Material._materialCache.addMaterial(Cesium.Material.CircleWaveMaterialType, {
    fabric: {
        type: Cesium.Material.CircleWaveMaterialType,
        uniforms: {
            color: new Cesium.Color(1, 0, 0, 1.0),
            time: 1,
            count: count,
            gradient: gradient
        },
        source: _CircleWaveMaterial2.default
    },
    translucent: function translucent() {
        return true;
    }
});

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _point = __webpack_require__(2);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _globe = __webpack_require__(18);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值 
        entityattr = {};
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":
            case "dimensionsY":
            case "dimensionsZ":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                break;
            case "color":
                //填充颜色
                entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                break;
            case "dimensionsX":
                //盒子的长宽高
                var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
                var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
                var dimensionsZ = Cesium.defaultValue(style.dimensionsZ, 100.0);
                entityattr.dimensions = new Cesium.Cartesian3(dimensionsX, dimensionsY, dimensionsZ);
                break;
            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;

            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
            case "clampToGround":
                //贴地
                if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
                break;
        }
    }

    //设置填充材质
    globe.setFillMaterial(entityattr, style);

    return entityattr;
}

//获取entity的坐标
//盒子
function getPositions(entity) {
    return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: { type: "Point", coordinates: coordinates[0] }
    };
}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值
        entityattr = {};
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":
            case "radius":
            case "shape":

            case "grid_lineCount":
            case "grid_lineThickness":
            case "grid_cellAlpha":
            case "checkerboard_repeat":
            case "checkerboard_oddcolor":
            case "stripe_oddcolor":
            case "stripe_repeat":
            case "animationDuration":
            case "animationImage":
            case "animationRepeatX":
            case "animationRepeatY":
            case "animationAxisY":
            case "animationGradient":
            case "animationCount":
            case "randomColor":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                break;
            case "color":
                //填充颜色
                entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                break;

            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;

            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
        }
    }

    //材质优先
    if (style.material) entityattr.material = style.material;

    //管道样式 
    style.radius = style.radius || 10;
    switch (style.shape) {
        default:
        case "pipeline":
            entityattr.shape = getCorridorShape1(style.radius); //（厚度固定为半径的1/3）
            break;
        case "circle":
            entityattr.shape = getCorridorShape2(style.radius);
            break;
        case "star":
            entityattr.shape = getCorridorShape3(style.radius);
            break;
    }

    return entityattr;
}

//管道形状1【内空管道】 radius整个管道的外半径 
function getCorridorShape1(radius) {
    var hd = radius / 3;
    var startAngle = 0;
    var endAngle = 360;

    var pss = [];
    for (var i = startAngle; i <= endAngle; i++) {
        var radians = Cesium.Math.toRadians(i);
        pss.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
    }
    for (var i = endAngle; i >= startAngle; i--) {
        var radians = Cesium.Math.toRadians(i);
        pss.push(new Cesium.Cartesian2((radius - hd) * Math.cos(radians), (radius - hd) * Math.sin(radians)));
    }
    return pss;
}

//管道形状2【圆柱体】 radius整个管道的外半径 
function getCorridorShape2(radius) {
    var startAngle = 0;
    var endAngle = 360;

    var pss = [];
    for (var i = startAngle; i <= endAngle; i++) {
        var radians = Cesium.Math.toRadians(i);
        pss.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
    }
    return pss;
}

//管道形状3【星状】 radius整个管道的外半径 ,arms星角的个数（默认6个角）
function getCorridorShape3(radius, arms) {
    var arms = arms || 6;
    var angle = Math.PI / arms;
    var length = 2 * arms;
    var pss = new Array(length);
    for (var i = 0; i < length; i++) {
        var r = i % 2 === 0 ? radius : radius / 3;
        pss[i] = new Cesium.Cartesian2(Math.cos(i * angle) * r, Math.sin(i * angle) * r);
    }
    return pss;
}

//获取entity的坐标
function getPositions(entity) {
    if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw; //取绑定的数据

    return entity.polylineVolume.positions.getValue((0, _util.currentTime)());
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: {
            type: "LineString",
            coordinates: coordinates
        }
    };
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _globe = __webpack_require__(18);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (!entityattr) {
        entityattr = {
            fill: true
        };
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":
            case "color": //填充颜色
            case "materialType":

            case "grid_lineCount":
            case "grid_lineThickness":
            case "grid_cellAlpha":
            case "checkerboard_repeat":
            case "checkerboard_oddcolor":
            case "stripe_oddcolor":
            case "stripe_repeat":
            case "animationDuration":
            case "animationImage":
            case "animationRepeatX":
            case "animationRepeatY":
            case "animationAxisY":
            case "animationGradient":
            case "animationCount":
            case "randomColor":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":

                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                break;

            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;

            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
        }
    }

    //设置填充材质
    globe.setFillMaterial(entityattr, style);

    return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
    return entity.wall.positions.getValue((0, _util.currentTime)());
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: {
            type: "LineString",
            coordinates: coordinates
        }
    };
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _globe = __webpack_require__(18);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值
        entityattr = {
            fill: true
        };
    }

    //贴地时，剔除高度相关属性
    if (style.clampToGround) {
        if (style.hasOwnProperty('height')) delete style.height;
        if (style.hasOwnProperty('extrudedHeight')) delete style.extrudedHeight;
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                break;
            case "color":
                //填充颜色
                entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                break;
            case "cornerType":
                switch (value) {
                    case "BEVELED":
                        entityattr.cornerType = Cesium.CornerType.BEVELED;
                        break;
                    case "MITERED":
                        entityattr.cornerType = Cesium.CornerType.MITERED;
                        break;
                    case "ROUNDED":
                        entityattr.cornerType = Cesium.CornerType.ROUNDED;
                        break;
                    default:
                        entityattr.cornerType = value;
                        break;
                }
                break;
            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;
            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;

        }
    }

    //设置填充材质
    globe.setFillMaterial(entityattr, style);

    return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
    return entity.corridor.positions.getValue((0, _util.currentTime)());
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: {
            type: "LineString",
            coordinates: coordinates
        }
    };
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createWaterPrimitive = createWaterPrimitive;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//创建水面Primitive
function createWaterPrimitive(polygon, opts) {
    var primitiveOpts = {
        geometryInstances: new Cesium.GeometryInstance({
            geometry: polygon,
            id: opts.id || 'water'
        }),
        appearance: new Cesium.EllipsoidSurfaceAppearance({
            aboveGround: false,
            material: new Cesium.Material({
                fabric: {
                    type: 'Water',
                    uniforms: {
                        normalMap: opts.normalMap, //水正常扰动的法线图。
                        frequency: opts.frequency || 8000.0, //控制波数的数字。
                        animationSpeed: opts.animationSpeed || 0.03, //控制水的动画速度的数字。
                        amplitude: opts.amplitude || 5.0, //控制水波振幅的数字。
                        specularIntensity: opts.specularIntensity || 0.8, //控制镜面反射强度的数字。  
                        baseWaterColor: Cesium.Color.fromCssColorString(opts.baseWaterColor || "#123e59"), //rgba颜色对象基础颜色的水。#00ffff,#00baff,#006ab4
                        blendColor: Cesium.Color.fromCssColorString(opts.blendColor || "#123e59") //从水中混合到非水域时使用的rgba颜色对象。  
                    }
                }
            }),
            fragmentShaderSource: getWaterShader(opts.opacity)
        }),
        show: true
    };
    if (opts.clampToGround) {
        primitiveOpts.classificationType = opts.classificationType || Cesium.ClassificationType.TERRAIN;
        return new Cesium.GroundPrimitive(primitiveOpts);
    } else {
        return new Cesium.Primitive(primitiveOpts);
    }
}

// 水面shader
//水域相关场景效果
function getWaterShader(opacity) {
    opacity = Cesium.defaultValue(opacity, 0.5);

    return 'varying vec3 v_positionMC;\n\
            varying vec3 v_positionEC;\n\
            varying vec2 v_st;\n\
            \n\
            void main()\n\
            {\n\
                czm_materialInput materialInput;\n\
                vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n\
            #ifdef FACE_FORWARD\n\
                normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n\
            #endif\n\
                materialInput.s = v_st.s;\n\
                materialInput.st = v_st;\n\
                materialInput.str = vec3(v_st, 0.0);\n\
                materialInput.normalEC = normalEC;\n\
                materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\
                vec3 positionToEyeEC = -v_positionEC;\n\
                materialInput.positionToEyeEC = positionToEyeEC;\n\
                czm_material material = czm_getMaterial(materialInput);\n\
            #ifdef FLAT\n\
                gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n\
            #else\n\
                gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n\
                gl_FragColor.a = ' + opacity + ';\n\
            #endif\n\
            }'; //czm_lightDirectionEC在cesium1.66开始加入的
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

var _globe = __webpack_require__(18);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值 
        entityattr = {
            fill: true,
            topRadius: 0
        };
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];

        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":
            case "color":
            case "animation":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                break;
            case "radius":
                //半径（圆）
                entityattr.topRadius = Number(value);
                entityattr.bottomRadius = Number(value);
                break;

            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;

            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
        }
    }

    //设置填充材质
    globe.setFillMaterial(entityattr, style);

    return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
    var positon = (0, _point.getPositionValue)(entity.position);

    if (entity._positions_draw && entity._positions_draw.length > 0) positon = entity._positions_draw[0];

    return [positon];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: { type: "Point", coordinates: coordinates[0] }
    };
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;
exports.getOutlinePositions = getOutlinePositions;
exports.getOutlineCoordinates = getOutlineCoordinates;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _polygon = __webpack_require__(13);

var _globe = __webpack_require__(18);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值 
        entityattr = {};
    }

    //贴地时，剔除高度相关属性
    if (style.clampToGround) {
        if (style.hasOwnProperty('height')) delete style.height;
        if (style.hasOwnProperty('extrudedHeight')) delete style.extrudedHeight;
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":

            case "grid_lineCount":
            case "grid_lineThickness":
            case "grid_cellAlpha":
            case "checkerboard_repeat":
            case "checkerboard_oddcolor":
            case "stripe_oddcolor":
            case "stripe_repeat":
            case "animationDuration":
            case "animationImage":
            case "animationRepeatX":
            case "animationRepeatY":
            case "animationAxisY":
            case "animationGradient":
            case "animationCount":
            case "randomColor":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outline":
                //边线
                if (entityattr[key] instanceof Cesium.CallbackProperty) {
                    //回调时不覆盖
                } else {
                    entityattr[key] = value;
                }
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                break;
            case "height":
                entityattr.height = value;
                if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) entityattr.extrudedHeight = Number(style.extrudedHeight) + Number(value);
                break;
            case "extrudedHeight":
                if ((0, _util.isNumber)(value)) {
                    entityattr.extrudedHeight = Number(entityattr.height || style.height || 0) + Number(value);
                } else {
                    entityattr.extrudedHeight = value;
                }
                break;
            case "color":
                //填充颜色
                entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                break;
            case "image":
                //填充图片
                entityattr.material = new Cesium.ImageMaterialProperty({
                    image: style.image,
                    color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(Number(style.opacity || 1.0))
                });
                break;
            case "rotation":
                //旋转角度 
                entityattr.rotation = Cesium.Math.toRadians(value);
                if (!style.stRotation) entityattr.stRotation = Cesium.Math.toRadians(value);
                break;
            case "stRotation":
                entityattr.stRotation = Cesium.Math.toRadians(value);
                break;

            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;

            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
        }
    }

    //设置填充材质
    globe.setFillMaterial(entityattr, style);

    return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
    if (!entity.rectangle) return null;

    // if (entity._positions_draw && entity._positions_draw.length > 0)
    //     return entity._positions_draw;

    var time = (0, _util.currentTime)();
    var re = entity.rectangle.coordinates.getValue(time); //Rectangle
    var height = entity.rectangle.height ? entity.rectangle.height.getValue(time) : 0;

    var ptMin = Cesium.Cartesian3.fromRadians(re.west, re.south, height); //西、南
    var ptMax = Cesium.Cartesian3.fromRadians(re.east, re.north, height); //东、北
    return [ptMin, ptMax];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);

    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: {
            type: "MultiPoint",
            coordinates: coordinates
        }
    };
}

//获取entity对应的 边界 的坐标
function getOutlinePositions(entity, noAdd) {
    if (!entity.rectangle) return null;

    var time = (0, _util.currentTime)();
    var re = entity.rectangle.coordinates.getValue(time); //Rectangle
    if (!re) return null;

    var rotation = entity.rectangle.rotation.getValue(time) || 0; //Rectangle
    var height = entity.rectangle.height ? entity.rectangle.height.getValue(time) : 0;

    var arr = (0, _polygon.getRectangleOuterPositions)({
        rectangle: re,
        rotation: rotation,
        height: height
    });

    if (!noAdd) arr.push(arr[0]);
    return arr;
}

//获取entity对应的 边界 的坐标（geojson规范的格式）
function getOutlineCoordinates(entity, noAdd) {
    var positions = getOutlinePositions(entity, noAdd);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

var _globe = __webpack_require__(18);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
    style = style || {};

    if (entityattr == null) {
        //默认值 
        entityattr = {
            fill: true
        };
    }

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "opacity": //跳过扩展其他属性的参数
            case "outlineOpacity":
            case "widthRadii":
            case "heightRadii":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "outlineColor":
                //边框颜色
                entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                break;
            case "color":
                //填充颜色
                entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                break;
            case "extentRadii":
                //球体长宽高半径
                var extentRadii = style.extentRadii || 100;
                var widthRadii = style.widthRadii || 100;
                var heightRadii = style.heightRadii || 100;
                entityattr.radii = new Cesium.Cartesian3(extentRadii, widthRadii, heightRadii);
                break;

            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;

            case "hasShadows":
                //阴影
                if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED; //对象投射并接收阴影。
                else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
                break;
        }
    }

    //设置填充材质
    globe.setFillMaterial(entityattr, style);

    return entityattr;
}

//获取entity的坐标
//椭球体
function getPositions(entity) {
    return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
    var positions = getPositions(entity);
    var coordinates = pointconvert.cartesians2lonlats(positions);
    return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
    var coordinates = getCoordinates(entity);
    return {
        type: "Feature",
        properties: entity.attribute || {},
        geometry: { type: "Point", coordinates: coordinates[0] }
    };
}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditPoint = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(28);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPoint = exports.EditPoint = function (_EditBase) {
    _inherits(EditPoint, _EditBase);

    function EditPoint() {
        _classCallCheck(this, EditPoint);

        return _possibleConstructorReturn(this, (EditPoint.__proto__ || Object.getPrototypeOf(EditPoint)).apply(this, arguments));
    }

    _createClass(EditPoint, [{
        key: 'setPositions',

        //外部更新位置
        value: function setPositions(position) {
            if (util.isArray(position) && position.length == 1) {
                position = position[0];
            }
            this.entity.position.setValue(position);
            if (this.entity.featureEx) {
                this.entity.featureEx.position = position;
            }
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {
            var that = this;

            this.entity.draw_tooltip = _Tooltip.message.dragger.def;
            var dragger = draggerCtl.createDragger(this.entityCollection, {
                dragger: this.entity,
                onDrag: function onDrag(dragger, newPosition) {
                    that.entity.position.setValue(newPosition);

                    if (that.entity.featureEx) {
                        that.entity.featureEx.position = newPosition;
                    }
                }
            });
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            delete this.entity.draw_tooltip;
            delete this.entity._isDragger;
            delete this.entity._noMousePosition;
            delete this.entity._pointType;
            delete this.entity.onDrag;
        }
    }]);

    return EditPoint;
}(_Edit.EditBase);

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Edit = __webpack_require__(25);

var _Attr = __webpack_require__(19);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCurve = exports.EditCurve = function (_EditPolyline) {
    _inherits(EditCurve, _EditPolyline);

    function EditCurve() {
        _classCallCheck(this, EditCurve);

        return _possibleConstructorReturn(this, (EditCurve.__proto__ || Object.getPrototypeOf(EditCurve)).apply(this, arguments));
    }

    _createClass(EditCurve, [{
        key: 'changePositionsToCallback',

        //修改坐标会回调，提高显示的效率
        value: function changePositionsToCallback() {
            this._positions_draw = this.entity._positions_draw;
            this._positions_show = this.entity._positions_show || this.getGraphic().positions.getValue(this.viewer.clock.currentTime);
        }
        //坐标位置相关  

    }, {
        key: 'updateAttrForEditing',
        value: function updateAttrForEditing() {
            if (this._positions_draw == null || this._positions_draw.length < 3) {
                this._positions_show = this._positions_draw;
                return;
            }

            this._positions_show = (0, _Attr.line2curve)(this._positions_draw, this.entity.attribute.style.closure);
            this.entity._positions_show = this._positions_show;
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            this.entity._positions_show = this._positions_show;
            this.entity._positions_draw = this._positions_draw;
        }
    }]);

    return EditCurve;
}(_Edit.EditPolyline);

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditPolylineVolume = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Edit = __webpack_require__(25);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPolylineVolume = exports.EditPolylineVolume = function (_EditPolyline) {
    _inherits(EditPolylineVolume, _EditPolyline);

    function EditPolylineVolume() {
        _classCallCheck(this, EditPolylineVolume);

        return _possibleConstructorReturn(this, (EditPolylineVolume.__proto__ || Object.getPrototypeOf(EditPolylineVolume)).apply(this, arguments));
    }

    _createClass(EditPolylineVolume, [{
        key: "getGraphic",

        //取enity对象的对应矢量数据
        value: function getGraphic() {
            return this.entity.polylineVolume;
        }
        //修改坐标会回调，提高显示的效率

    }, {
        key: "changePositionsToCallback",
        value: function changePositionsToCallback() {
            this._positions_draw = this.entity._positions_draw;
        }
    }]);

    return EditPolylineVolume;
}(_Edit.EditPolyline);

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditCorridor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Edit = __webpack_require__(25);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCorridor = exports.EditCorridor = function (_EditPolyline) {
    _inherits(EditCorridor, _EditPolyline);

    function EditCorridor() {
        _classCallCheck(this, EditCorridor);

        return _possibleConstructorReturn(this, (EditCorridor.__proto__ || Object.getPrototypeOf(EditCorridor)).apply(this, arguments));
    }

    _createClass(EditCorridor, [{
        key: 'getGraphic',

        //取enity对象的对应矢量数据
        value: function getGraphic() {
            return this.entity.corridor;
        }
        //继承父类，根据属性更新坐标

    }, {
        key: 'updatePositionsHeightByAttr',
        value: function updatePositionsHeightByAttr(position) {
            if (this.getGraphic().height != undefined) {
                var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
                position = (0, _point.setPositionsHeight)(position, newHeight);
            }
            return position;
        }
    }]);

    return EditCorridor;
}(_Edit.EditPolyline);

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawPolygon = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(16);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

var _Attr = __webpack_require__(21);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(29);

var _Attr2 = __webpack_require__(19);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPolygon = exports.DrawPolygon = function (_DrawPolyline) {
    _inherits(DrawPolygon, _DrawPolyline);

    //========== 构造方法 ========== 
    function DrawPolygon(opts) {
        _classCallCheck(this, DrawPolygon);

        var _this = _possibleConstructorReturn(this, (DrawPolygon.__proto__ || Object.getPrototypeOf(DrawPolygon)).call(this, opts));

        _this.type = 'polygon';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditPolygon; //获取编辑对象

        _this._minPointNum = 3; //至少需要点的个数 
        _this._maxPointNum = 9999; //最多允许点的个数 
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawPolygon, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = [];

            if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
            if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

            if (attribute.config) {
                //允许外部传入
                this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
            } else {
                this._minPointNum = this._minPointNum_def;
                this._maxPointNum = this._maxPointNum_def;
            }

            var that = this;
            var addattr = {
                polygon: attr.style2Entity(attribute.style),
                attribute: attribute
            };

            addattr.polygon.hierarchy = new Cesium.CallbackProperty(function (time) {
                var positions = that.getDrawPosition();
                return new Cesium.PolygonHierarchy(positions);
            }, false);

            //线：边线宽度大于1时用polyline 
            var lineStyle = _extends({
                "color": attribute.style.outlineColor,
                "width": attribute.style.outlineWidth,
                "opacity": attribute.style.outlineOpacity
            }, attribute.style.outlineStyle || {});
            addattr.polyline = (0, _Attr2.style2Entity)(lineStyle, {
                clampToGround: attribute.style.clampToGround,
                // arcType: Cesium.ArcType.RHUMB,
                outline: false,
                show: false
            });

            this.entity = dataSource.entities.add(addattr); //创建要素对象

            this.bindOutline(this.entity, lineStyle); //边线


            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.polygon);
        }
    }, {
        key: 'bindOutline',
        value: function bindOutline(entity, lineStyle) {
            var attribute = entity.attribute;

            //本身的outline需要隐藏
            entity.polygon.outline = new Cesium.CallbackProperty(function (time) {
                return attribute.style.outline && attribute.style.outlineWidth == 1;
            }, false);

            //是否显示：绘制时前2点时 或 边线宽度大于1时
            entity.polyline.show = new Cesium.CallbackProperty(function (time) {
                var arr = attr.getPositions(entity, true);
                if (arr && arr.length < 3) return true;

                return attribute.style.outline && attribute.style.outlineWidth > 1;
            }, false);

            entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                if (!entity.polyline.show.getValue(time)) return null;

                var arr = attr.getPositions(entity, true);
                if (arr && arr.length < 3) return arr;

                return arr.concat([arr[0]]);
            }, false);
            entity.polyline.width = new Cesium.CallbackProperty(function (time) {
                var arr = attr.getPositions(entity, true);
                if (arr && arr.length < 3) return 2;

                return entity.polygon.outlineWidth;
            }, false);

            //虚线等情况下不支持动态修改颜色,只有实线可以动态改颜色。
            if (!lineStyle.lineType || lineStyle.lineType == "solid") {
                entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                    var arr = attr.getPositions(entity, true);
                    if (arr && arr.length < 3) {
                        if (entity.polygon.material.color) return entity.polygon.material.color.getValue(time);else return Cesium.Color.YELLOW;
                    }
                    return entity.polygon.outlineColor.getValue(time);
                }, false));
            }
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing() {

            var style = this.entity.attribute.style;
            if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) {
                //存在extrudedHeight高度设置时
                var maxHight = (0, _point.getMaxHeight)(this.getDrawPosition());
                this.entity.polygon.extrudedHeight = maxHight + Number(style.extrudedHeight);
            }
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this.getDrawPosition();
            entity.polygon.hierarchy = new Cesium.CallbackProperty(function (time) {
                var positions = entity._positions_draw;
                return new Cesium.PolygonHierarchy(positions);
            }, false);
        }
    }]);

    return DrawPolygon;
}(_Draw.DrawPolyline);

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditRectangle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(29);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditRectangle = exports.EditRectangle = function (_EditPolygon) {
    _inherits(EditRectangle, _EditPolygon);

    function EditRectangle() {
        _classCallCheck(this, EditRectangle);

        return _possibleConstructorReturn(this, (EditRectangle.__proto__ || Object.getPrototypeOf(EditRectangle)).apply(this, arguments));
    }

    _createClass(EditRectangle, [{
        key: 'getGraphic',

        //取enity对象的对应矢量数据
        value: function getGraphic() {
            return this.entity.rectangle;
        }
        //修改坐标会回调，提高显示的效率

    }, {
        key: 'changePositionsToCallback',
        value: function changePositionsToCallback() {
            this._positions_draw = this.entity._positions_draw;
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            this.entity._positions_draw = this._positions_draw;
        }
    }, {
        key: 'isClampToGround',
        value: function isClampToGround() {
            return this.entity.attribute.style.clampToGround;
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {
            var that = this;

            var clampToGround = this.isClampToGround();
            var positions = this.getPosition();

            for (var i = 0, len = positions.length; i < len; i++) {
                var position = positions[i];

                if (this.getGraphic().height != undefined) {
                    var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
                    position = (0, _point.setPositionsHeight)(position, newHeight);
                }

                if (clampToGround) {
                    //贴地时求贴模型和贴地的高度
                    position = (0, _point.setPositionSurfaceHeight)(this.viewer, position);
                }

                //各顶点
                var dragger = draggerCtl.createDragger(this.entityCollection, {
                    position: position,
                    //clampToGround: clampToGround,
                    onDrag: function onDrag(dragger, position) {
                        var time = that.viewer.clock.currentTime;
                        if (that.getGraphic().height != undefined) {
                            var newHeight = that.getGraphic().height.getValue(time);
                            position = (0, _point.setPositionsHeight)(position, newHeight);
                            dragger.position = position;
                        }

                        positions[dragger.index] = position;

                        //============高度调整拖拽点处理=============
                        if (that.heightDraggers && that.heightDraggers.length > 0) {
                            var extrudedHeight = that.getGraphic().extrudedHeight.getValue(time);
                            that.heightDraggers[dragger.index].position = (0, _point.setPositionsHeight)(position, extrudedHeight);
                        }

                        //============整体平移移动点处理============= 
                        positionMove = (0, _point.centerOfMass)(positions);
                        if (that.getGraphic().height != undefined) {
                            var newHeight = that.getGraphic().height.getValue(time);
                            positionMove = (0, _point.setPositionsHeight)(positionMove, newHeight);
                        }
                        if (clampToGround) {
                            //贴地时求贴模型和贴地的高度
                            positionMove = (0, _point.setPositionSurfaceHeight)(that.viewer, positionMove);
                        }
                        draggerMove.position = positionMove;
                    }
                });
                dragger.index = i;
                this.draggers.push(dragger);
            }

            //整体平移移动点 
            var positionMove = (0, _point.centerOfMass)(positions);
            if (this.getGraphic().height != undefined) {
                var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
                positionMove = (0, _point.setPositionsHeight)(positionMove, newHeight);
            }
            if (clampToGround) {
                //贴地时求贴模型和贴地的高度
                positionMove = (0, _point.setPositionSurfaceHeight)(this.viewer, positionMove);
            }
            var draggerMove = draggerCtl.createDragger(this.entityCollection, {
                position: positionMove,
                type: draggerCtl.PointType.MoveAll,
                tooltip: _Tooltip.message.dragger.moveAll,
                onDrag: function onDrag(dragger, position) {
                    // dragger.position = position;

                    //记录差值 
                    var diff = Cesium.Cartesian3.subtract(position, positionMove, new Cesium.Cartesian3());
                    positionMove = position;

                    positions.forEach(function (pos, index, arr) {
                        var newPos = Cesium.Cartesian3.add(pos, diff, new Cesium.Cartesian3());
                        positions[index] = newPos;
                    });

                    //=====全部更新========== 
                    that.updateDraggers();
                }
            });
            this.draggers.push(draggerMove);

            //创建高程拖拽点
            if (this.getGraphic().extrudedHeight) this.bindHeightDraggers();
        }
    }]);

    return EditRectangle;
}(_Edit.EditPolygon);

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditCircle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(29);

var _point = __webpack_require__(2);

var _polygon = __webpack_require__(13);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCircle = exports.EditCircle = function (_EditPolygon) {
    _inherits(EditCircle, _EditPolygon);

    function EditCircle() {
        _classCallCheck(this, EditCircle);

        return _possibleConstructorReturn(this, (EditCircle.__proto__ || Object.getPrototypeOf(EditCircle)).apply(this, arguments));
    }

    _createClass(EditCircle, [{
        key: 'getGraphic',

        //取enity对象的对应矢量数据
        value: function getGraphic() {
            return this.entity.ellipse;
        }
        //修改坐标会回调，提高显示的效率

    }, {
        key: 'changePositionsToCallback',
        value: function changePositionsToCallback() {
            this._positions_draw = this.entity._positions_draw;
            this.finish();
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            this.entity._positions_draw = this._positions_draw;
        }
    }, {
        key: 'isClampToGround',
        value: function isClampToGround() {
            return this.entity.attribute.style.clampToGround;
        }
    }, {
        key: 'getPosition',
        value: function getPosition() {
            //加上高度
            if (this.getGraphic().height != undefined) {
                var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
                for (var i = 0, len = this._positions_draw.length; i < len; i++) {
                    this._positions_draw[i] = (0, _point.setPositionsHeight)(this._positions_draw[i], newHeight);
                }
            }
            return this._positions_draw;
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {
            var that = this;

            var clampToGround = this.isClampToGround();
            var positions = this.getPosition();

            var style = this.entity.attribute.style;

            //中心点
            var position = positions[0];
            if (clampToGround) {
                //贴地时求贴模型和贴地的高度
                position = (0, _point.setPositionSurfaceHeight)(this.viewer, position);
                positions[0] = position;
            }

            var dragger = draggerCtl.createDragger(this.entityCollection, {
                position: position,
                onDrag: function onDrag(dragger, position) {
                    //记录差值
                    var diff = Cesium.Cartesian3.subtract(position, positions[dragger.index], new Cesium.Cartesian3());

                    positions[dragger.index] = position;

                    //============高度处理=============
                    if (!style.clampToGround) {
                        var height = that.formatNum(Cesium.Cartographic.fromCartesian(position).height, 2);
                        that.getGraphic().height = height;
                        style.height = height;
                    }

                    var time = that.viewer.clock.currentTime;

                    //============半径同步处理=============
                    var newPos = Cesium.Cartesian3.add((0, _point.getPositionValue)(dragger.majorDragger.position, time), diff, new Cesium.Cartesian3());
                    dragger.majorDragger.position = newPos;

                    if (dragger.minorDragger) {
                        var newPos = Cesium.Cartesian3.add((0, _point.getPositionValue)(dragger.minorDragger.position, time), diff, new Cesium.Cartesian3());
                        dragger.minorDragger.position = newPos;
                    }

                    //============高度调整拖拽点处理=============
                    if (that.entity.attribute.style.extrudedHeight != undefined) that.updateDraggers();
                }
            });
            dragger.index = 0;
            this.draggers.push(dragger);

            var time = this.viewer.clock.currentTime;

            //获取圆（或椭圆）边线上的坐标点数组
            var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                position: position,
                semiMajorAxis: this.getGraphic().semiMajorAxis.getValue(time), //长半轴
                semiMinorAxis: this.getGraphic().semiMinorAxis.getValue(time), //短半轴
                rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
            });

            //长半轴上的坐标点
            var majorPos = outerPositions[1];
            if (clampToGround) {
                //贴地时求贴模型和贴地的高度
                majorPos = (0, _point.setPositionSurfaceHeight)(this.viewer, majorPos);
            }
            positions[1] = majorPos;
            var majorDragger = draggerCtl.createDragger(this.entityCollection, {
                position: majorPos,
                type: draggerCtl.PointType.EditAttr,
                tooltip: _Tooltip.message.dragger.editRadius,
                //clampToGround: clampToGround,
                onDrag: function onDrag(dragger, position) {
                    if (that.getGraphic().height != undefined) {
                        var newHeight = that.getGraphic().height.getValue(time);
                        position = (0, _point.setPositionsHeight)(position, newHeight);
                        dragger.position = position;
                    }
                    positions[dragger.index] = position;

                    var radius = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
                    that.getGraphic().semiMajorAxis = radius;

                    if (that._maxPointNum == 3 || !Cesium.defined(style.radius)) {
                        //椭圆
                        style.semiMajorAxis = radius;
                    } else {
                        //圆
                        that.getGraphic().semiMinorAxis = radius;
                        style.radius = radius;
                    }

                    // if (that.entity.attribute.style.extrudedHeight != undefined)
                    that.updateDraggers();
                }
            });
            majorDragger.index = 1;
            dragger.majorDragger = majorDragger;
            this.draggers.push(majorDragger);

            //短半轴上的坐标点
            if (this._maxPointNum == 3) {
                //椭圆
                //短半轴上的坐标点 
                var minorPos = outerPositions[0];
                if (clampToGround) {
                    //贴地时求贴模型和贴地的高度
                    minorPos = (0, _point.setPositionSurfaceHeight)(this.viewer, minorPos);
                }
                positions[2] = minorPos;
                var minorDragger = draggerCtl.createDragger(this.entityCollection, {
                    position: minorPos,
                    type: draggerCtl.PointType.EditAttr,
                    tooltip: _Tooltip.message.dragger.editRadius,
                    //clampToGround: clampToGround,
                    onDrag: function onDrag(dragger, position) {
                        if (that.getGraphic().height != undefined) {
                            var newHeight = that.getGraphic().height.getValue(time);
                            position = (0, _point.setPositionsHeight)(position, newHeight);
                            dragger.position = position;
                        }
                        positions[dragger.index] = position;

                        var radius = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
                        that.getGraphic().semiMinorAxis = radius;

                        if (that._maxPointNum == 3 || !Cesium.defined(style.radius)) {
                            //椭圆
                            style.semiMinorAxis = radius;
                        } else {
                            //圆
                            that.getGraphic().semiMajorAxis = radius;
                            style.radius = radius;
                        }

                        // if (that.entity.attribute.style.extrudedHeight != undefined)
                        that.updateDraggers();
                    }
                });
                minorDragger.index = 2;
                dragger.minorDragger = minorDragger;
                this.draggers.push(minorDragger);
            }

            //创建高度拖拽点
            if (this.getGraphic().extrudedHeight) {
                var _pos = this._maxPointNum == 3 ? [positions[1], positions[2]] : [positions[1]];
                this.bindHeightDraggers(_pos);
            }
        }
    }]);

    return EditCircle;
}(_Edit.EditPolygon);

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditEllipsoid = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(28);

var _point = __webpack_require__(2);

var _polygon = __webpack_require__(13);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditEllipsoid = exports.EditEllipsoid = function (_EditBase) {
    _inherits(EditEllipsoid, _EditBase);

    function EditEllipsoid() {
        _classCallCheck(this, EditEllipsoid);

        return _possibleConstructorReturn(this, (EditEllipsoid.__proto__ || Object.getPrototypeOf(EditEllipsoid)).apply(this, arguments));
    }

    _createClass(EditEllipsoid, [{
        key: 'setPositions',


        //外部更新位置
        value: function setPositions(position) {
            this.entity._positions_draw[0] = position[0];
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {}
    }, {
        key: 'updateRadii',
        value: function updateRadii(style) {
            var radii = new Cesium.Cartesian3(Number(style.extentRadii), Number(style.widthRadii), Number(style.heightRadii));
            this.entity.ellipsoid.radii.setValue(radii);
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {
            var that = this;

            var style = this.entity.attribute.style;

            //位置中心点
            var position = this.entity._positions_draw[0];
            var dragger = draggerCtl.createDragger(this.entityCollection, {
                position: position,
                onDrag: function onDrag(dragger, position) {
                    that.entity._positions_draw[0] = position;

                    that.updateDraggers();
                }
            });
            this.draggers.push(dragger);

            //顶部的 高半径 编辑点
            var position = (0, _point.getPositionValue)(this.entity.position, this.viewer.clock.currentTime);
            var dragger = draggerCtl.createDragger(this.entityCollection, {
                position: (0, _point.addPositionsHeight)(position, style.heightRadii),
                type: draggerCtl.PointType.MoveHeight,
                tooltip: _Tooltip.message.dragger.editRadius,
                onDrag: function onDrag(dragger, position) {
                    var positionZXD = that.entity._positions_draw[0];
                    var length = that.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                    style.heightRadii = length; //高半径

                    that.updateRadii(style);
                    that.updateDraggers();
                }
            });
            this.draggers.push(dragger);

            //获取圆（或椭圆）边线上的坐标点数组
            var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                position: position,
                semiMajorAxis: Number(style.extentRadii),
                semiMinorAxis: Number(style.widthRadii),
                rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
            });

            //长半轴上的坐标点
            var majorPos = outerPositions[0];
            var majorDragger = draggerCtl.createDragger(this.entityCollection, {
                position: majorPos,
                type: draggerCtl.PointType.EditAttr,
                tooltip: _Tooltip.message.dragger.editRadius,
                onDrag: function onDrag(dragger, position) {
                    var positionZXD = that.entity._positions_draw[0];
                    var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                    position = (0, _point.setPositionsHeight)(position, newHeight);
                    dragger.position = position;

                    var radius = that.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                    style.widthRadii = radius; //长半轴

                    that.updateRadii(style);
                    that.updateDraggers();
                }
            });
            dragger.majorDragger = majorDragger;
            this.draggers.push(majorDragger);

            //短半轴上的坐标点  
            var minorPos = outerPositions[1];
            var minorDragger = draggerCtl.createDragger(this.entityCollection, {
                position: minorPos,
                type: draggerCtl.PointType.EditAttr,
                tooltip: _Tooltip.message.dragger.editRadius,
                onDrag: function onDrag(dragger, position) {
                    var positionZXD = that.entity._positions_draw[0];
                    var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                    position = (0, _point.setPositionsHeight)(position, newHeight);
                    dragger.position = position;

                    var radius = that.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                    style.extentRadii = radius; //短半轴

                    that.updateRadii(style);
                    that.updateDraggers();
                }
            });
            dragger.minorDragger = minorDragger;
            this.draggers.push(minorDragger);
        }
    }]);

    return EditEllipsoid;
}(_Edit.EditBase);

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditWall = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(25);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditWall = exports.EditWall = function (_EditPolyline) {
    _inherits(EditWall, _EditPolyline);

    function EditWall() {
        _classCallCheck(this, EditWall);

        return _possibleConstructorReturn(this, (EditWall.__proto__ || Object.getPrototypeOf(EditWall)).apply(this, arguments));
    }

    _createClass(EditWall, [{
        key: 'getGraphic',

        //取enity对象的对应矢量数据
        value: function getGraphic() {
            return this.entity.wall;
        }
        //修改坐标会回调，提高显示的效率

    }, {
        key: 'changePositionsToCallback',
        value: function changePositionsToCallback() {
            var that = this;

            var time = this.viewer.clock.currentTime;

            this._positions_draw = this.entity._positions_draw || this.getGraphic().positions.getValue(time);
            this._minimumHeights = this.entity._minimumHeights || this.getGraphic().minimumHeights.getValue(time);
            this._maximumHeights = this.entity._maximumHeights || this.getGraphic().maximumHeights.getValue(time);
        }
        //坐标位置相关  

    }, {
        key: 'updateAttrForEditing',
        value: function updateAttrForEditing() {
            var style = this.entity.attribute.style;
            var position = this.getPosition();
            var len = position.length;

            this._maximumHeights = new Array(len);
            this._minimumHeights = new Array(len);

            for (var i = 0; i < len; i++) {
                var height = Cesium.Cartographic.fromCartesian(position[i]).height;
                this._minimumHeights[i] = height;
                this._maximumHeights[i] = height + Number(style.extrudedHeight);
            }

            //同步更新
            this.entity._maximumHeights = this._maximumHeights;
            this.entity._minimumHeights = this._minimumHeights;
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            this.entity._positions_draw = this._positions_draw;
            this.entity._maximumHeights = this._maximumHeights;
            this.entity._minimumHeights = this._minimumHeights;
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {
            var that = this;

            var clampToGround = this.isClampToGround();

            var positions = this.getPosition();
            var style = this.entity.attribute.style;
            var hasMidPoint = positions.length < this._maxPointNum; //是否有新增点

            for (var i = 0, len = positions.length; i < len; i++) {
                var loc = positions[i];

                //各顶点
                var dragger = draggerCtl.createDragger(this.entityCollection, {
                    position: loc,
                    clampToGround: clampToGround,
                    onDrag: function onDrag(dragger, position) {
                        positions[dragger.index] = position;

                        //============高度调整拖拽点处理=============
                        if (that.heightDraggers && that.heightDraggers.length > 0) {
                            that.heightDraggers[dragger.index].position = (0, _point.addPositionsHeight)(position, style.extrudedHeight);
                        }

                        //============新增点拖拽点处理=============
                        if (hasMidPoint) {
                            if (dragger.index > 0) {
                                //与前一个点之间的中点 
                                that.draggers[dragger.index * 2 - 1].position = Cesium.Cartesian3.midpoint(position, positions[dragger.index - 1], new Cesium.Cartesian3());
                            }
                            if (dragger.index < positions.length - 1) {
                                //与后一个点之间的中点 
                                that.draggers[dragger.index * 2 + 1].position = Cesium.Cartesian3.midpoint(position, positions[dragger.index + 1], new Cesium.Cartesian3());
                            }
                        }

                        //============整体平移移动点处理============= 
                        positionMove = (0, _point.centerOfMass)(positions);
                        draggerMove.position = positionMove;
                    }
                });
                dragger.index = i;
                this.draggers.push(dragger);

                //中间点，拖动后新增点
                if (hasMidPoint) {
                    var nextIndex = i + 1;
                    if (nextIndex < len) {
                        var midpoint = Cesium.Cartesian3.midpoint(loc, positions[nextIndex], new Cesium.Cartesian3());
                        var draggerMid = draggerCtl.createDragger(this.entityCollection, {
                            position: midpoint,
                            type: draggerCtl.PointType.AddMidPoint,
                            tooltip: _Tooltip.message.dragger.addMidPoint,
                            clampToGround: clampToGround,
                            onDragStart: function onDragStart(dragger, position) {
                                positions.splice(dragger.index, 0, position); //插入点 
                                that.updateAttrForEditing();
                            },
                            onDrag: function onDrag(dragger, position) {
                                positions[dragger.index] = position;
                            },
                            onDragEnd: function onDragEnd(dragger, position) {
                                that.updateDraggers();
                            }
                        });
                        draggerMid.index = nextIndex;
                        this.draggers.push(draggerMid);
                    }
                }
            }

            //整体平移移动点 
            var positionMove = (0, _point.centerOfMass)(positions);
            var draggerMove = draggerCtl.createDragger(this.entityCollection, {
                position: positionMove,
                type: draggerCtl.PointType.MoveAll,
                tooltip: _Tooltip.message.dragger.moveAll,
                clampToGround: clampToGround,
                onDrag: function onDrag(dragger, position) {
                    // dragger.position = position;

                    //记录差值 
                    var diff = Cesium.Cartesian3.subtract(position, positionMove, new Cesium.Cartesian3());
                    positionMove = position;

                    positions.forEach(function (pos, index, arr) {
                        var newPos = Cesium.Cartesian3.add(pos, diff, new Cesium.Cartesian3());
                        positions[index] = newPos;
                    });

                    //=====全部更新========== 
                    that.updateDraggers();
                }
            });
            this.draggers.push(draggerMove);

            //创建高程拖拽点
            this.bindHeightDraggers();
        }
        //高度调整拖拽点

    }, {
        key: 'bindHeightDraggers',
        value: function bindHeightDraggers() {
            var that = this;

            this.heightDraggers = [];

            var positions = this.getPosition();
            var style = this.entity.attribute.style;
            var extrudedHeight = Number(style.extrudedHeight);

            for (var i = 0, len = positions.length; i < len; i++) {
                var loc = (0, _point.addPositionsHeight)(positions[i], extrudedHeight);

                var dragger = draggerCtl.createDragger(this.entityCollection, {
                    position: loc,
                    type: draggerCtl.PointType.MoveHeight,
                    tooltip: _Tooltip.message.dragger.moveHeight,
                    onDrag: function onDrag(dragger, position) {
                        var thisHeight = Cesium.Cartographic.fromCartesian(position).height;
                        style.extrudedHeight = that.formatNum(thisHeight - that._minimumHeights[dragger.index], 2);

                        for (var i = 0; i < positions.length; i++) {
                            if (i == dragger.index) continue;
                            that.heightDraggers[i].position = (0, _point.addPositionsHeight)(positions[i], style.extrudedHeight);
                        }
                        that.updateAttrForEditing();
                    }
                });
                dragger.index = i;

                this.draggers.push(dragger);
                this.heightDraggers.push(dragger);
            }
        }
    }]);

    return EditWall;
}(_Edit.EditPolyline);

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditPlane = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(28);

var _point = __webpack_require__(2);

var _matrix = __webpack_require__(17);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPlane = exports.EditPlane = function (_EditBase) {
    _inherits(EditPlane, _EditBase);

    function EditPlane() {
        _classCallCheck(this, EditPlane);

        return _possibleConstructorReturn(this, (EditPlane.__proto__ || Object.getPrototypeOf(EditPlane)).apply(this, arguments));
    }

    _createClass(EditPlane, [{
        key: 'setPositions',

        //外部更新位置
        value: function setPositions(position) {
            if (util.isArray(position) && position.length == 1) {
                position = position[0];
            }
            this.entity._positions_draw = position;
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {}
    }, {
        key: 'updatePlane',
        value: function updatePlane(style) {
            var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
            var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
            var dimensions = new Cesium.Cartesian2(dimensionsX, dimensionsY);
            this.entity.plane.dimensions.setValue(dimensions);
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {
            var _this2 = this;

            var style = this.entity.attribute.style;

            //位置中心点
            var positionZXD = this.entity._positions_draw;
            var dragger = draggerCtl.createDragger(this.entityCollection, {
                position: positionZXD,
                onDrag: function onDrag(dragger, position) {
                    _this2.entity._positions_draw = position;
                    _this2.updateDraggers();
                }
            });
            this.draggers.push(dragger);

            //平面的x长度调整
            var offest = { x: 0, y: 0, z: 0 };
            switch (style.plane_normal) {
                case "x":
                    offest.y = style.dimensionsX / 2;
                    break;
                default:
                    offest.x = style.dimensionsX / 2;
                    break;
            }
            var position1 = (0, _matrix.getPositionTranslation)(positionZXD, offest);
            var dragger = draggerCtl.createDragger(this.entityCollection, {
                position: position1,
                type: draggerCtl.PointType.EditAttr,
                tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '长度(X方向)'),
                onDrag: function onDrag(dragger, position) {
                    var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                    position = (0, _point.setPositionsHeight)(position, newHeight);
                    dragger.position = position;

                    var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                    style.dimensionsX = radius * 2;

                    _this2.updatePlane(style);
                    _this2.updateDraggers();
                }
            });
            this.draggers.push(dragger);

            //平面的y宽度调整
            if (style.plane_normal == "z") {
                var offest = { x: 0, y: style.dimensionsY / 2, z: 0 };
                var position2 = (0, _matrix.getPositionTranslation)(positionZXD, offest);

                var dragger = draggerCtl.createDragger(this.entityCollection, {
                    position: position2,
                    type: draggerCtl.PointType.EditAttr,
                    tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '宽度(Y方向)'),
                    onDrag: function onDrag(dragger, position) {
                        var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                        position = (0, _point.setPositionsHeight)(position, newHeight);
                        dragger.position = position;

                        var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                        style.dimensionsY = radius * 2;

                        _this2.updatePlane(style);
                        _this2.updateDraggers();
                    }
                });
                this.draggers.push(dragger);
            } else {
                var offest = { x: 0, y: 0, z: 0 };
                switch (style.plane_normal) {
                    case "x":
                    case "y":
                        offest.z = style.dimensionsY / 2;
                        break;
                    default:
                        offest.y = style.dimensionsY / 2;
                        break;
                }
                //顶部的 高半径 编辑点
                var position2 = (0, _matrix.getPositionTranslation)(positionZXD, offest);

                var dragger = draggerCtl.createDragger(this.entityCollection, {
                    position: position2,
                    type: draggerCtl.PointType.MoveHeight,
                    tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '宽度(Y方向)'),
                    onDrag: function onDrag(dragger, position) {
                        var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                        style.dimensionsY = radius * 2;

                        _this2.updatePlane(style);
                        _this2.updateDraggers();
                    }
                });
                this.draggers.push(dragger);
            }
        }
    }]);

    return EditPlane;
}(_Edit.EditBase);

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditBox = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(28);

var _point = __webpack_require__(2);

var _matrix = __webpack_require__(17);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditBox = exports.EditBox = function (_EditBase) {
    _inherits(EditBox, _EditBase);

    function EditBox() {
        _classCallCheck(this, EditBox);

        return _possibleConstructorReturn(this, (EditBox.__proto__ || Object.getPrototypeOf(EditBox)).apply(this, arguments));
    }

    _createClass(EditBox, [{
        key: 'setPositions',

        //外部更新位置
        value: function setPositions(position) {
            if (util.isArray(position) && position.length == 1) {
                position = position[0];
            }
            this.entity._positions_draw = position;
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {}
    }, {
        key: 'updateBox',
        value: function updateBox(style) {
            var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
            var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
            var dimensionsZ = Cesium.defaultValue(style.dimensionsZ, 100.0);
            var dimensions = new Cesium.Cartesian3(dimensionsX, dimensionsY, dimensionsZ);

            this.entity.box.dimensions.setValue(dimensions);
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {
            var _this2 = this;

            var that = this;

            var style = this.entity.attribute.style;

            //位置中心点
            var positionZXD = this.entity._positions_draw;
            var dragger = draggerCtl.createDragger(this.entityCollection, {
                position: positionZXD,
                onDrag: function onDrag(dragger, position) {
                    _this2.entity._positions_draw = position;
                    _this2.updateDraggers();
                }
            });
            this.draggers.push(dragger);

            //x长度调整
            var offest = { x: style.dimensionsX / 2, y: 0, z: 0 };
            var position1 = (0, _matrix.getPositionTranslation)(positionZXD, offest);
            var dragger = draggerCtl.createDragger(this.entityCollection, {
                position: position1,
                type: draggerCtl.PointType.EditAttr,
                tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '长度(X方向)'),
                onDrag: function onDrag(dragger, position) {
                    var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                    position = (0, _point.setPositionsHeight)(position, newHeight);
                    dragger.position = position;

                    var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                    style.dimensionsX = radius * 2;

                    _this2.updateBox(style);
                    _this2.updateDraggers();
                }
            });
            this.draggers.push(dragger);

            //y宽度调整
            var offest = { x: 0, y: style.dimensionsY / 2, z: 0 };
            var position2 = (0, _matrix.getPositionTranslation)(positionZXD, offest);
            var dragger = draggerCtl.createDragger(this.entityCollection, {
                position: position2,
                type: draggerCtl.PointType.EditAttr,
                tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '宽度(Y方向)'),
                onDrag: function onDrag(dragger, position) {
                    var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                    position = (0, _point.setPositionsHeight)(position, newHeight);
                    dragger.position = position;

                    var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                    style.dimensionsY = radius * 2;

                    _this2.updateBox(style);
                    _this2.updateDraggers();
                }
            });
            this.draggers.push(dragger);

            //z高度调整
            var offest = { x: 0, y: 0, z: style.dimensionsZ / 2 };
            var position2 = (0, _matrix.getPositionTranslation)(positionZXD, offest);
            var dragger = draggerCtl.createDragger(this.entityCollection, {
                position: position2,
                type: draggerCtl.PointType.MoveHeight,
                tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '高度(Z方向)'),
                onDrag: function onDrag(dragger, position) {
                    var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                    style.dimensionsZ = radius * 2;

                    _this2.updateBox(style);
                    _this2.updateDraggers();
                }
            });
            this.draggers.push(dragger);
        }
    }]);

    return EditBox;
}(_Edit.EditBase);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KeyboardRoam = exports.KeyboardType = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var moveStep = 10; //平移步长 (米)
var dirStep = 25; //相机原地旋转步长，值越大步长越小。
var rotateStep = 1.0; //相机围绕目标点旋转速率，0.3 - 2.0
var minPitch = 0.1; //最小仰角  0 - 1
var maxPitch = 0.95; //最大仰角  0 - 1


var KeyboardType = exports.KeyboardType = {
    ENLARGE: 0,
    NARROW: 1,
    LEFT_ROTATE: 2,
    RIGHT_ROTATE: 3,
    TOP_ROTATE: 4,
    BOTTOM_ROTATE: 5

    //快捷键，键盘漫游
};
var KeyboardRoam = exports.KeyboardRoam = function () {
    //========== 构造方法 ========== 
    function KeyboardRoam(options) {
        _classCallCheck(this, KeyboardRoam);

        this.viewer = options.viewer;
        var canvas = this.viewer.scene.canvas;

        this.flags = {
            moveForward: false,
            moveBackward: false,
            moveUp: false,
            moveDown: false,
            moveLeft: false,
            moveRight: false
        };

        canvas.setAttribute('tabindex', '0'); // needed to put focus on the canvas
        canvas.onclick = function () {
            canvas.focus();
        };

        var that = this;
        document.addEventListener('keydown', function (event) {
            if (!that._enable) return;

            var flagName = that.getFlagForKeyCode(event.keyCode);
            if (typeof flagName !== 'undefined') {
                that.flags[flagName] = true;
            }
        }, false);
        document.addEventListener('keyup', function (event) {
            if (!that._enable) return;

            var flagName = that.getFlagForKeyCode(event.keyCode);
            if (typeof flagName !== 'undefined') {
                that.flags[flagName] = false;
            }
        }, false);

        this._enable = false;
    }

    //========== 对外属性 ==========  

    //是否禁用


    _createClass(KeyboardRoam, [{
        key: 'bind',


        //========== 方法 ==========  

        value: function bind(opts) {
            if (this._enable) return;
            this._enable = true;

            if (Cesium.defined(opts)) {
                //支持绑定方法内重新赋值参数 
                moveStep = opts.moveStep || opts.speedRatio || moveStep;
                dirStep = opts.dirStep || dirStep;
                rotateStep = opts.rotateStep || rotateStep;
                minPitch = opts.minPitch || minPitch;
                maxPitch = opts.maxPitch || maxPitch;
            }

            this.viewer.clock.onTick.addEventListener(this.cameraFunc, this);
        }
    }, {
        key: 'unbind',
        value: function unbind() {
            if (!this._enable) return;
            this._enable = false;

            this.viewer.clock.onTick.removeEventListener(this.cameraFunc, this);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.unbind();
            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }

        //=================相关事件回调方法======================   

    }, {
        key: 'getFlagForKeyCode',
        value: function getFlagForKeyCode(keyCode) {
            switch (keyCode) {
                //平移
                case 'W'.charCodeAt(0):
                    //向前平移镜头，不改变相机朝向
                    return 'moveForward';
                case 'S'.charCodeAt(0):
                    //向后平移镜头，不改变相机朝向
                    return 'moveBackward';
                case 'D'.charCodeAt(0):
                    //向右平移镜头，不改变相机朝向
                    return 'moveRight';
                case 'A'.charCodeAt(0):
                    //向左平移镜头，不改变相机朝向
                    return 'moveLeft';
                case 'Q'.charCodeAt(0):
                    //向上平移镜头，不改变相机朝向
                    return 'moveUp';
                case 'E'.charCodeAt(0):
                    //向下平移镜头，不改变相机朝向
                    return 'moveDown';

                //相对于相机本身
                case 38:
                    //方向键上键
                    this.rotateCamera(KeyboardType.TOP_ROTATE); //相机原地上旋转
                    break;
                case 37:
                    //方向键左键
                    this.rotateCamera(KeyboardType.LEFT_ROTATE); //相机原地左旋转
                    break;
                case 39:
                    //方向键右键
                    this.rotateCamera(KeyboardType.RIGHT_ROTATE); //相机原地右旋转
                    break;
                case 40:
                    //方向键下键
                    this.rotateCamera(KeyboardType.BOTTOM_ROTATE); //相机原地下旋转
                    break;

                //相对于屏幕中心点
                case 'I'.charCodeAt(0):
                case 104:
                    //数字键盘8
                    this.moveCamera(KeyboardType.ENLARGE); //向屏幕中心靠近
                    break;
                case 'K'.charCodeAt(0):
                case 101:
                    //数字键盘5
                    this.moveCamera(KeyboardType.NARROW); //向屏幕中心远离
                    break;
                case 'J'.charCodeAt(0):
                case 100:
                    //数字键盘4
                    this.moveCamera(KeyboardType.LEFT_ROTATE); //围绕屏幕中心左旋转
                    break;
                case 'L'.charCodeAt(0):
                case 102:
                    //数字键盘6
                    this.moveCamera(KeyboardType.RIGHT_ROTATE); //围绕屏幕中心右旋转
                    break;
                case 'U'.charCodeAt(0):
                case 103:
                    //数字键盘7
                    this.moveCamera(KeyboardType.TOP_ROTATE); //围绕屏幕中心上旋转
                    break;
                case 'O'.charCodeAt(0):
                case 105:
                    //数字键盘9
                    this.moveCamera(KeyboardType.BOTTOM_ROTATE); //围绕屏幕中心下旋转
                    break;

                default:
                    break;
            }
            return undefined;
        }

        //=================平移======================

    }, {
        key: 'startMoveForward',
        value: function startMoveForward() {
            this.flags['moveForward'] = true;
        }
    }, {
        key: 'stopMoveForward',
        value: function stopMoveForward() {
            this.flags['moveForward'] = false;
        }
    }, {
        key: 'startMoveBackward',
        value: function startMoveBackward() {
            this.flags['moveBackward'] = true;
        }
    }, {
        key: 'stopMoveBackward',
        value: function stopMoveBackward() {
            this.flags['moveBackward'] = false;
        }
    }, {
        key: 'startMoveRight',
        value: function startMoveRight() {
            this.flags['moveRight'] = true;
        }
    }, {
        key: 'stopMoveRight',
        value: function stopMoveRight() {
            this.flags['moveRight'] = false;
        }
    }, {
        key: 'startMoveLeft',
        value: function startMoveLeft() {
            this.flags['moveLeft'] = true;
        }
    }, {
        key: 'stopMoveLeft',
        value: function stopMoveLeft() {
            this.flags['moveLeft'] = false;
        }
    }, {
        key: 'moveForward',
        value: function moveForward(distance) {
            //和模型的相机移动不太一样  不是沿着相机目标方向，而是默认向上方向 和 向右 方向的插值方向
            var camera = this.viewer.camera;
            var direction = camera.direction;
            //获得此位置默认的向上方向  
            var up = Cesium.Cartesian3.normalize(camera.position, new Cesium.Cartesian3());

            // right = direction * up  
            var right = Cesium.Cartesian3.cross(direction, up, new Cesium.Cartesian3());

            direction = Cesium.Cartesian3.cross(up, right, new Cesium.Cartesian3());

            direction = Cesium.Cartesian3.normalize(direction, direction);
            direction = Cesium.Cartesian3.multiplyByScalar(direction, distance, direction);

            camera.position = Cesium.Cartesian3.add(camera.position, direction, camera.position);
        }
    }, {
        key: 'cameraFunc',
        value: function cameraFunc(clock) {
            var camera = this.viewer.camera;

            // Change movement speed based on the distance of the camera to the surface of the ellipsoid.
            // var cameraHeight = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(camera.position).height;
            // var moveRate = cameraHeight / moveStep;
            var moveRate = moveStep;

            if (this.flags.moveForward) {
                this.moveForward(moveRate);
            }
            if (this.flags.moveBackward) {
                this.moveForward(-moveRate);
            }
            if (this.flags.moveUp) {
                camera.moveUp(moveRate);
            }
            if (this.flags.moveDown) {
                camera.moveDown(moveRate);
            }
            if (this.flags.moveLeft) {
                camera.moveLeft(moveRate);
            }
            if (this.flags.moveRight) {
                camera.moveRight(moveRate);
            }
        }
    }, {
        key: 'resetCameraPos',


        //=================相对于屏幕或相机====================== 
        value: function resetCameraPos(newCamera) {
            if (!newCamera) return;
            this.viewer.scene.camera.position = newCamera.position;
            this.viewer.scene.camera.direction = newCamera.direction;
            this.viewer.scene.camera.right = newCamera.right;
            this.viewer.scene.camera.up = newCamera.up;
        }
    }, {
        key: 'limitAngle',
        value: function limitAngle(up, position, type) {
            var dotNum = Cesium.Cartesian3.dot(up, Cesium.Cartesian3.normalize(position, new Cesium.Cartesian3()));
            if (type == 'up' && dotNum < minPitch) return false;
            if (type == 'down' && dotNum > maxPitch) return false;
            return true;
        }
    }, {
        key: 'computedNewPos',
        value: function computedNewPos(camera, dir, rotate) {
            // var step = rotateStep;
            var oldpos = camera.position;
            var winCenter = (0, _point.getCenter)(this.viewer);
            if (!winCenter) return;
            var center = Cesium.Cartesian3.fromDegrees(winCenter.x, winCenter.y, winCenter.z);
            if (!center) return;
            var oldDis = Cesium.Cartesian3.distance(center, oldpos);
            var step = oldDis / 100;
            step = rotate ? step * rotateStep : step;
            var newCamera = {};
            var ray = new Cesium.Ray(oldpos, dir);
            newCamera.position = Cesium.Ray.getPoint(ray, step);

            // var cheight = Cesium.Cartographic.fromCartesian(newCamera.position).height;
            // if (cheight < 500)   return;

            newCamera.direction = camera.direction;
            newCamera.right = camera.right;
            newCamera.up = camera.up;
            if (rotate) {
                var newDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(newCamera.position, center, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                ray = new Cesium.Ray(center, newDir);
                newCamera.position = Cesium.Ray.getPoint(ray, oldDis);
                newCamera.direction = Cesium.Cartesian3.negate(newDir, new Cesium.Cartesian3());
                // newCamera.up = camera.up;
                newCamera.up = Cesium.Cartesian3.normalize(newCamera.position, new Cesium.Cartesian3());
                newCamera.right = Cesium.Cartesian3.cross(newCamera.direction, newCamera.up, new Cesium.Cartesian3());
            }
            return newCamera;
        }
    }, {
        key: 'moveCamera',
        value: function moveCamera(type) {
            var camera = this.viewer.scene.camera;
            var newCamera;
            switch (type) {
                case KeyboardType.ENLARGE:
                    newCamera = this.computedNewPos(camera, camera.direction);
                    break;
                case KeyboardType.NARROW:
                    newCamera = this.computedNewPos(camera, Cesium.Cartesian3.negate(camera.direction, new Cesium.Cartesian3()));
                    break;
                case KeyboardType.LEFT_ROTATE:
                    newCamera = this.computedNewPos(camera, Cesium.Cartesian3.negate(camera.right, new Cesium.Cartesian3()), true);
                    break;
                case KeyboardType.RIGHT_ROTATE:
                    newCamera = this.computedNewPos(camera, camera.right, true);
                    break;
                case KeyboardType.TOP_ROTATE:
                    var able = this.limitAngle(Cesium.clone(camera.up), Cesium.clone(camera.position), 'up');
                    if (!able) return;
                    newCamera = this.computedNewPos(camera, Cesium.clone(camera.up), true);
                    break;
                case KeyboardType.BOTTOM_ROTATE:
                    var able = this.limitAngle(Cesium.clone(camera.up), Cesium.clone(camera.position), 'down');
                    if (!able) return;
                    newCamera = this.computedNewPos(camera, Cesium.Cartesian3.negate(camera.up, new Cesium.Cartesian3()), true);
                    break;
            }
            if (!newCamera) return;
            this.resetCameraPos(newCamera);
        }
    }, {
        key: 'rotateCamera',
        value: function rotateCamera(type) {
            var winPos = [0, 0];
            var width = this.viewer.scene.canvas.clientWidth;
            var height = this.viewer.scene.canvas.clientHeight;
            var step = (width + height) / dirStep;
            switch (type) {
                case KeyboardType.LEFT_ROTATE:
                    winPos = [-step * width / height, 0];
                    break;
                case KeyboardType.RIGHT_ROTATE:
                    winPos = [step * width / height, 0];
                    break;
                case KeyboardType.TOP_ROTATE:
                    winPos = [0, step];
                    break;
                case KeyboardType.BOTTOM_ROTATE:
                    winPos = [0, -step];
                    break;
                default:
                    return;
            }
            var x = winPos[0] / width;
            var y = winPos[1] / height;
            //这计算了，分别向右 和 向上移动的
            var lookFactor = 0.05;
            var camera = this.viewer.camera;
            camera.lookRight(x * lookFactor);
            camera.lookUp(y * lookFactor);

            //获得direction 方向
            var direction = camera.direction;
            //获得此位置默认的向上方向  
            var up = Cesium.Cartesian3.normalize(camera.position, new Cesium.Cartesian3());

            // right = direction * up  
            var right = Cesium.Cartesian3.cross(direction, up, new Cesium.Cartesian3());
            // up = right * direction
            up = Cesium.Cartesian3.cross(right, direction, new Cesium.Cartesian3());

            camera.up = up;
            camera.right = right;
        }
    }, {
        key: 'enable',
        get: function get() {
            return this._enable;
        },
        set: function set(value) {
            if (value) this.bind();else this.unbind();
        }
    }, {
        key: 'moveStep',
        get: function get() {
            return moveStep;
        },
        set: function set(value) {
            moveStep = value;
        }
    }, {
        key: 'dirStep',
        get: function get() {
            return dirStep;
        },
        set: function set(value) {
            dirStep = value;
        }
    }, {
        key: 'rotateStep',
        get: function get() {
            return rotateStep;
        },
        set: function set(value) {
            rotateStep = value;
        }
    }, {
        key: 'minPitch',
        get: function get() {
            return minPitch;
        },
        set: function set(value) {
            minPitch = value;
        }
    }, {
        key: 'maxPitch',
        get: function get() {
            return maxPitch;
        },
        set: function set(value) {
            maxPitch = value;
        }
    }]);

    return KeyboardRoam;
}();

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getDefaultContextMenu = getDefaultContextMenu;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _tileset = __webpack_require__(27);

var tileset = _interopRequireWildcard(_tileset);

var _util2 = __webpack_require__(1);

var _util = _interopRequireWildcard(_util2);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//默认右键菜单
function getDefaultContextMenu(viewer) {
    var stages = viewer.scene.postProcessStages;
    var that = {};

    return [{
        text: '查看此处坐标',
        iconCls: 'fa fa-info-circle',
        visible: function visible(e) {
            return Cesium.defined(e.position);
        },
        callback: function callback(e) {
            //经纬度
            var mpt = point.formatPosition(e.position);
            var inhtml = '\u7ECF\u5EA6\uFF1A' + mpt.x + ', \u7EAC\u5EA6\uFF1A' + mpt.y + ', \u9AD8\u7A0B\uFF1A' + mpt.z;
            _util.alert(inhtml, '位置信息');

            //打印方便测试  
            var ptX = point.formatNum(e.position.x, 1); //笛卡尔
            var ptY = point.formatNum(e.position.y, 1);
            var ptZ = point.formatNum(e.position.z, 1);
            marslog.log('\u7ECF\u7EAC\u5EA6\uFF1A' + mpt.x + ',' + mpt.y + ',' + mpt.z + ', \u7B1B\u5361\u5C14\uFF1A' + ptX + ',' + ptY + ',' + ptZ);
        }
    }, {
        text: '查看当前视角',
        iconCls: 'fa fa-camera-retro',
        callback: function callback(e) {
            var mpt = JSON.stringify(point.getCameraView(viewer));

            //打印方便测试， 说明：可配置到config.json中center参数使用，或调用viewer.mars.centerAt(参数)方法
            marslog.log(mpt);

            _util.alert(mpt, '当前视角信息');
        }
    }, {
        text: '视角切换',
        iconCls: 'fa fa-street-view',
        children: [{
            text: '绕此处环绕飞行',
            iconCls: 'fa fa-retweet',
            visible: function visible(e) {
                return e.position && !point.windingPoint.isStart;
            },
            callback: function callback(e) {
                point.windingPoint.start(viewer, e.position);
            }
        }, {
            text: '关闭环绕飞行',
            iconCls: 'fa fa-remove',
            visible: function visible(e) {
                return point.windingPoint.isStart;
            },
            callback: function callback(e) {
                point.windingPoint.stop();
            }
        }, {
            text: '移动到此处',
            iconCls: 'fa fa-send-o',
            visible: function visible(e) {
                return Cesium.defined(e.position);
            },
            callback: function callback(e) {
                var range = viewer.scene.camera.positionCartographic.height;
                if (range > 5000) range = 5000;

                viewer.camera.lookAt(e.position, new Cesium.HeadingPitchRange(viewer.camera.heading, viewer.camera.pitch, range));
                viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
            }
        }, {
            text: '第一视角站到此处',
            iconCls: 'fa fa-male',
            visible: function visible(e) {
                return Cesium.defined(e.position);
            },
            callback: function callback(e) {
                viewer.camera.flyTo({
                    destination: point.addPositionsHeight(e.position, 10), //升高10米
                    orientation: {
                        heading: Cesium.Math.toRadians(0), //绕垂直于地心的轴旋转
                        pitch: Cesium.Math.toRadians(10), //绕纬度线旋转
                        roll: Cesium.Math.toRadians(0) //绕经度线旋转
                    }
                });
            }
        }, {
            text: '开启键盘漫游',
            iconCls: 'fa fa-keyboard-o',
            visible: function visible(e) {
                return !viewer.mars.keyboardRoam.enable;
            },
            callback: function callback(e) {
                viewer.mars.keyboardRoam.enable = true;
            }
        }, {
            text: '关闭键盘漫游',
            iconCls: 'fa fa-keyboard-o',
            visible: function visible(e) {
                return viewer.mars.keyboardRoam.enable;
            },
            callback: function callback(e) {
                viewer.mars.keyboardRoam.enable = false;
            }
        }, {
            text: '取消锁定',
            iconCls: 'fa fa-unlock-alt',
            visible: function visible(e) {
                return viewer.trackedEntity != undefined;
            },
            callback: function callback(e) {
                viewer.trackedEntity = undefined;
            }
        }]
    }, {
        text: '三维模型',
        iconCls: 'fa fa-building-o',
        visible: function visible(e) {
            var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
            return Cesium.defined(model);
        },
        children: [{
            text: '显示三角网',
            iconCls: 'fa fa-connectdevelop',
            visible: function visible(e) {
                var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                return !model.debugWireframe;
            },
            callback: function callback(e) {
                var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                model.debugWireframe = true;
            }
        }, {
            text: '关闭三角网',
            iconCls: 'fa fa-connectdevelop',
            visible: function visible(e) {
                var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                return model.debugWireframe;
            },
            callback: function callback(e) {
                var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                model.debugWireframe = false;
            }
        }, {
            text: '显示包围盒',
            iconCls: 'fa fa-codepen',
            visible: function visible(e) {
                var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                return !model.debugShowBoundingVolume;
            },
            callback: function callback(e) {
                var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                model.debugShowBoundingVolume = true;
            }
        }, {
            text: '关闭包围盒',
            iconCls: 'fa fa-codepen',
            visible: function visible(e) {
                var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                return model.debugShowBoundingVolume;
            },
            callback: function callback(e) {
                var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                model.debugShowBoundingVolume = false;
            }
        }]
    }, {
        text: '地形服务',
        iconCls: 'fa fa-globe',
        visible: function visible(e) {
            return !Cesium.defined(e.target);
        },
        children: [{
            text: '开启地形',
            iconCls: 'fa fa-medium',
            visible: function visible(e) {
                return !viewer.mars.hasTerrain();
            },
            callback: function callback(e) {
                viewer.mars.updateTerrainProvider(true);
            }
        }, {
            text: '关闭地形',
            iconCls: 'fa fa-medium',
            visible: function visible(e) {
                return viewer.mars.hasTerrain();
            },
            callback: function callback(e) {
                viewer.mars.updateTerrainProvider(false);
            }
        }, {
            text: '显示三角网',
            iconCls: 'fa fa-connectdevelop',
            visible: function visible(e) {
                return !viewer.scene.globe._surface.tileProvider._debug.wireframe;
            },
            callback: function callback(e) {
                viewer.scene.globe._surface.tileProvider._debug.wireframe = true;
            }
        }, {
            text: '关闭三角网',
            iconCls: 'fa fa-connectdevelop',
            visible: function visible(e) {
                return viewer.scene.globe._surface.tileProvider._debug.wireframe;
            },
            callback: function callback(e) {
                viewer.scene.globe._surface.tileProvider._debug.wireframe = false;
            }
        }]
    }, {
        text: '图上标记',
        iconCls: 'fa fa-eyedropper',
        children: [{
            text: '标记点',
            iconCls: 'fa fa-map-marker',
            callback: function callback(e) {
                viewer.mars.draw.startDraw({
                    "type": "point",
                    "style": {
                        pixelSize: 12,
                        color: '#3388ff'
                    },
                    success: function success(entity) {
                        var positions = viewer.mars.draw.getCoordinates(entity);
                        console.log(JSON.stringify(positions));
                    }
                });
            }
        }, {
            text: '标记线',
            iconCls: 'fa fa-reorder',
            callback: function callback(e) {
                viewer.mars.draw.startDraw({
                    "type": "polyline",
                    "style": {
                        color: "#55ff33",
                        width: 3
                    },
                    success: function success(entity) {
                        var positions = viewer.mars.draw.getCoordinates(entity);
                        console.log(JSON.stringify(positions));
                    }
                });
            }
        }, {
            text: '标记面',
            iconCls: 'fa fa-medium',
            callback: function callback(e) {
                viewer.mars.draw.startDraw({
                    "type": "polygon",
                    "style": {
                        color: "#29cf34",
                        opacity: 0.5,
                        outline: true,
                        outlineWidth: 2.0
                    },
                    success: function success(entity) {
                        var positions = viewer.mars.draw.getCoordinates(entity);
                        console.log(JSON.stringify(positions));
                    }
                });
            }
        }, {
            text: '标记圆',
            iconCls: 'fa fa-genderless',
            callback: function callback(e) {
                viewer.mars.draw.startDraw({
                    "type": "circle",
                    "style": {
                        color: "#ffff00",
                        opacity: 0.6
                    },
                    success: function success(entity) {
                        var positions = viewer.mars.draw.getCoordinates(entity);
                        console.log(JSON.stringify(positions));
                    }
                });
            }
        }, {
            text: '标记矩形',
            iconCls: 'fa fa-retweet',
            callback: function callback(e) {
                viewer.mars.draw.startDraw({
                    type: "rectangle",
                    style: {
                        color: "#ffff00",
                        opacity: 0.6
                    },
                    success: function success(entity) {
                        var positions = viewer.mars.draw.getCoordinates(entity);
                        console.log(JSON.stringify(positions));
                    }
                });
            }
        }, {
            text: '允许编辑',
            iconCls: 'fa fa-pencil',
            visible: function visible(e) {
                return !viewer.mars.draw._hasEdit;
            },
            callback: function callback(e) {
                viewer.mars.draw.hasEdit(true);
            }
        }, {
            text: '禁止编辑',
            iconCls: 'fa fa-pencil-square',
            visible: function visible(e) {
                return viewer.mars.draw._hasEdit;
            },
            callback: function callback(e) {
                viewer.mars.draw.hasEdit(false);
            }
        }, {
            text: '导出GeoJSON',
            iconCls: 'fa fa-file-text-o',
            visible: function visible(e) {
                return viewer.mars.draw.hasDraw();
            },
            callback: function callback(e) {
                _util.downloadFile("图上标记.json", JSON.stringify(viewer.mars.draw.toGeoJSON()));
            }
        }, {
            text: '清除所有标记',
            iconCls: 'fa fa-trash-o',
            visible: function visible(e) {
                return viewer.mars.draw.hasDraw();
            },
            callback: function callback(e) {
                viewer.mars.draw.clearDraw();
            }
        }]
    }, {
        text: '特效效果',
        iconCls: 'fa fa-rss',
        children: [{
            text: '开启泛光',
            iconCls: 'fa fa-ticket',
            visible: function visible(e) {
                return !viewer.scene.postProcessStages.bloom.enabled;
            },
            callback: function callback(e) {
                //加泛光  （参考官方示例: bloom）
                var bloom = viewer.scene.postProcessStages.bloom;
                if (!that.bloom) {
                    bloom.enabled = false;
                    bloom.uniforms.glowOnly = false;
                    bloom.uniforms.contrast = 128;
                    bloom.uniforms.brightness = -0.3;
                    bloom.uniforms.delta = 1.0;
                    bloom.uniforms.sigma = 3.78;
                    bloom.uniforms.stepSize = 5.0;

                    that.bloom = true;
                }
                bloom.enabled = true;
            }
        }, {
            text: '关闭泛光',
            iconCls: 'fa fa-ticket',
            visible: function visible(e) {
                return viewer.scene.postProcessStages.bloom.enabled;
            },
            callback: function callback(e) {
                viewer.scene.postProcessStages.bloom.enabled = false;
            }
        }, {
            text: '开启亮度',
            iconCls: 'fa fa-trello',
            visible: function visible(e) {
                return !that.BrightnessStage;
            },
            callback: function callback(e) {
                if (!that.BrightnessStage) {
                    that.BrightnessStage = Cesium.PostProcessStageLibrary.createBrightnessStage();
                    stages.add(that.BrightnessStage);

                    that.BrightnessStage.uniforms.brightness = 2.0;
                }
                that.BrightnessStage.enabled = true;
            }
        }, {
            text: '关闭亮度',
            iconCls: 'fa fa-trello',
            visible: function visible(e) {
                return that.BrightnessStage;
            },
            callback: function callback(e) {
                if (that.BrightnessStage) {
                    stages.remove(that.BrightnessStage);
                    that.BrightnessStage = undefined;
                }
            }
        }, {
            text: '开启夜视',
            iconCls: 'fa fa-dashboard',
            visible: function visible(e) {
                return !that.NightVisionStage;
            },
            callback: function callback(e) {
                if (!that.NightVisionStage) {
                    that.NightVisionStage = Cesium.PostProcessStageLibrary.createNightVisionStage();
                    stages.add(that.NightVisionStage);
                }
                that.NightVisionStage.enabled = true;
            }
        }, {
            text: '关闭夜视',
            iconCls: 'fa fa-dashboard',
            visible: function visible(e) {
                return that.NightVisionStage;
            },
            callback: function callback(e) {
                if (that.NightVisionStage) {
                    stages.remove(that.NightVisionStage);
                    that.NightVisionStage = undefined;
                }
            }
        }, {
            text: '开启黑白',
            iconCls: 'fa fa-star-half-full',
            visible: function visible(e) {
                return !that.BlackAndWhiteStage;
            },
            callback: function callback(e) {
                if (!that.BlackAndWhiteStage) {
                    that.BlackAndWhiteStage = Cesium.PostProcessStageLibrary.createBlackAndWhiteStage();
                    stages.add(that.BlackAndWhiteStage);
                }
                that.BlackAndWhiteStage.enabled = true;
            }
        }, {
            text: '关闭黑白',
            iconCls: 'fa fa-star-half-full',
            visible: function visible(e) {
                return that.BlackAndWhiteStage;
            },
            callback: function callback(e) {
                if (that.BlackAndWhiteStage) {
                    stages.remove(that.BlackAndWhiteStage);
                    that.BlackAndWhiteStage = undefined;
                }
            }
        }, {
            text: '开启马赛克',
            iconCls: 'fa fa-delicious',
            visible: function visible(e) {
                return !that.MosaicStage;
            },
            callback: function callback(e) {
                if (!that.MosaicStage) {
                    that.MosaicStage = new Cesium.PostProcessStage({
                        fragmentShader: 'uniform sampler2D colorTexture; \n                                varying vec2 v_textureCoordinates; \n                                const int KERNEL_WIDTH=16; \n                                void main(void) \n                                { \n                                    vec2 step = 1.0 / czm_viewport.zw; \n                                    vec2 integralPos = v_textureCoordinates - mod(v_textureCoordinates, 8.0 * step); \n                                    vec3 averageValue = vec3(0.0); \n                                    for (int i = 0; i < KERNEL_WIDTH; i++) \n                                    { \n                                        for (int j = 0; j < KERNEL_WIDTH; j++) \n                                        { \n                                            averageValue += texture2D(colorTexture, integralPos + step * vec2(i, j)).rgb; \n                                        } \n                                    } \n                                    averageValue /= float(KERNEL_WIDTH * KERNEL_WIDTH); \n                                    gl_FragColor = vec4(averageValue, 1.0); \n                                } '
                    });
                    stages.add(that.MosaicStage);
                }
                that.MosaicStage.enabled = true;
            }
        }, {
            text: '关闭马赛克',
            iconCls: 'fa fa-delicious',
            visible: function visible(e) {
                return that.MosaicStage;
            },
            callback: function callback(e) {
                if (that.MosaicStage) {
                    stages.remove(that.MosaicStage);
                    that.MosaicStage = undefined;
                }
            }
        }, {
            text: '开启景深',
            iconCls: 'fa fa-simplybuilt',
            visible: function visible(e) {
                return !that.DepthOfFieldStage;
            },
            callback: function callback(e) {
                if (!that.DepthOfFieldStage) {
                    that.DepthOfFieldStage = Cesium.PostProcessStageLibrary.createDepthOfFieldStage();
                    stages.add(that.DepthOfFieldStage);

                    var uniforms = that.DepthOfFieldStage.uniforms;
                    uniforms.focalDistance = 87; //焦距
                    uniforms.delta = 1;
                    uniforms.sigma = 3.78;
                    uniforms.stepSize = 2.46; //步长
                }
                that.DepthOfFieldStage.enabled = true;
            }
        }, {
            text: '关闭景深',
            iconCls: 'fa fa-simplybuilt',
            visible: function visible(e) {
                return that.DepthOfFieldStage;
            },
            callback: function callback(e) {
                if (that.DepthOfFieldStage) {
                    stages.remove(that.DepthOfFieldStage);
                    that.DepthOfFieldStage = undefined;
                }
            }
        }]
    }, {
        text: '场景设置',
        iconCls: 'fa fa-gear',
        children: [{
            text: '开启深度监测',
            iconCls: 'fa fa-eye-slash',
            visible: function visible(e) {
                return !viewer.scene.globe.depthTestAgainstTerrain;
            },
            callback: function callback(e) {
                viewer.scene.globe.depthTestAgainstTerrain = true;
            }
        }, {
            text: '关闭深度监测',
            iconCls: 'fa fa-eye',
            visible: function visible(e) {
                return viewer.scene.globe.depthTestAgainstTerrain;
            },
            callback: function callback(e) {
                viewer.scene.globe.depthTestAgainstTerrain = false;
            }
        }, {
            text: '显示星空背景',
            iconCls: 'fa fa-moon-o',
            visible: function visible(e) {
                return !viewer.scene.skyBox.show;
            },
            callback: function callback(e) {
                viewer.scene.skyBox.show = true; //天空盒
                viewer.scene.moon.show = true; //太阳
                viewer.scene.sun.show = true; //月亮                
            }
        }, {
            text: '关闭星空背景',
            iconCls: 'fa fa-moon-o',
            visible: function visible(e) {
                return viewer.scene.skyBox.show;
            },
            callback: function callback(e) {
                viewer.scene.skyBox.show = false; //天空盒
                viewer.scene.moon.show = false; //太阳
                viewer.scene.sun.show = false; //月亮        
            }
        }, {
            text: '开启日照阴影',
            iconCls: 'fa fa-sun-o',
            visible: function visible(e) {
                return !viewer.shadows;
            },
            callback: function callback(e) {
                viewer.shadows = true;
                viewer.terrainShadows = Cesium.ShadowMode.ENABLED;
                viewer.scene.globe.enableLighting = true;
            }
        }, {
            text: '关闭日照阴影',
            iconCls: 'fa fa-sun-o',
            visible: function visible(e) {
                return viewer.shadows;
            },
            callback: function callback(e) {
                viewer.shadows = false;
                viewer.terrainShadows = Cesium.ShadowMode.RECEIVE_ONLY;
                viewer.scene.globe.enableLighting = false;
            }
        }, {
            text: '开启大气渲染',
            iconCls: 'fa fa-soundcloud',
            visible: function visible(e) {
                return !viewer.scene.skyAtmosphere.show;
            },
            callback: function callback(e) {

                viewer.scene.skyAtmosphere.show = true;
                viewer.scene.globe.showGroundAtmosphere = true;
            }
        }, {
            text: '关闭大气渲染',
            iconCls: 'fa fa-soundcloud',
            visible: function visible(e) {
                return viewer.scene.skyAtmosphere.show;
            },
            callback: function callback(e) {
                viewer.scene.skyAtmosphere.show = false;
                viewer.scene.globe.showGroundAtmosphere = false;
            }
        }, {
            text: '场景截图',
            iconCls: 'fa fa-download',
            callback: function callback(e) {
                viewer.mars.expImage();
            }
        }]
    }];
}

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;
exports.getDefWindowOptions = getDefWindowOptions;
exports.activate = activate;
exports.getWidget = getWidget;
exports.getClass = getClass;
exports.isActivate = isActivate;
exports.disable = disable;
exports.disableAll = disableAll;
exports.disableGroup = disableGroup;
exports.eachWidget = eachWidget;
exports.bindClass = bindClass;
exports.removeDebugeBar = removeDebugeBar;
exports.getCacheVersion = getCacheVersion;
exports.getBasePath = getBasePath;

var _zepto = __webpack_require__(8);

var _loader = __webpack_require__(73);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//widget模块公共处理类，勿轻易修改


var basePath = ""; //widgets目录统一前缀，如果widgets目录不在当前页面的同级目录，在其他处时可以传入basePath参数，参数值为：widgets目录相对于当前页面的路径
var defoptions;
var cacheVersion;
var isdebuger;

var thismap;
var widgetsdata = [];

var removeKeys = ["_class"];

//初始化插件
function init(map, widgetcfg, _basePath) {
    thismap = map;
    widgetcfg = widgetcfg || {};
    basePath = _basePath || "";

    widgetsdata = [];
    defoptions = widgetcfg.defaultOptions || { "windowOptions": { "position": "rt", "maxmin": false, "resize": true }, "autoDisable": true, "disableOther": true };

    cacheVersion = widgetcfg.version;
    if (cacheVersion == "time") cacheVersion = new Date().getTime();

    //将自启动的加入
    var arrtemp = widgetcfg.widgetsAtStart;
    if (arrtemp && arrtemp.length > 0) {
        for (var i = 0; i < arrtemp.length; i++) {
            var item = arrtemp[i];
            if (!item.hasOwnProperty("uri") || item.uri == "") {
                marslog.log('widget未配置uri：' + JSON.stringify(item));
                continue;
            }
            if (item.hasOwnProperty("visible") && !item.visible) continue;

            item.autoDisable = false;
            item.openAtStart = true;
            item._nodebug = true;

            bindDefOptions(item);

            item._firstConfigBak = (0, _util.clone)(item, removeKeys);
            widgetsdata.push(item);
        }
    }

    //显示测试栏
    //为了方便测试，所有widget会在页面下侧生成一排按钮，每个按钮对应一个widget，单击后激活对应widget
    isdebuger = widgetcfg["debugger"];
    if (isdebuger) {
        var inhtml = '<div id="widget-testbar" class="okay3d-widgetbar animation-slide-bottom no-print-view" > ' + '     <div style="height: 30px; line-height:30px;"><b style="color: #4db3ff;">widget测试栏</b>&nbsp;&nbsp;<button  id="widget-testbar-remove"  type="button" class="btn btn-link btn-xs">关闭</button> </div>' + '     <button id="widget-testbar-disableAll" type="button" class="btn btn-info" ><i class="fa fa-globe"></i>漫游</button>' + '</div>';
        (0, _zepto.zepto)("body").append(inhtml);

        (0, _zepto.zepto)("#widget-testbar-remove").click(function (e) {
            removeDebugeBar();
        });
        (0, _zepto.zepto)("#widget-testbar-disableAll").click(function (e) {
            disableAll();
        });
    }

    //将配置的加入
    arrtemp = widgetcfg.widgets;
    if (arrtemp && arrtemp.length > 0) {
        for (var i = 0; i < arrtemp.length; i++) {
            var item = arrtemp[i];
            if (item.type == "group") {
                var inhtml = ' <div class="btn-group dropup">  <button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false"><i class="fa fa-align-justify"></i>' + item.name + ' <span class="caret"></span></button> <ul class="dropdown-menu">';
                for (var j = 0; j < item.children.length; j++) {
                    var childItem = item.children[j];
                    if (!childItem.hasOwnProperty("uri") || childItem.uri == "") {
                        marslog.log('widget未配置uri：' + JSON.stringify(childItem));
                        continue;
                    }

                    inhtml += ' <li data-widget="' + childItem.uri + '" class="widget-btn" ><a href="#"><i class="fa fa-star"></i>' + childItem.name + '</a></li>';

                    bindDefOptions(childItem);
                    childItem._firstConfigBak = (0, _util.clone)(childItem, removeKeys);
                    widgetsdata.push(childItem); //将配置的加入
                }
                inhtml += "</ul></div>";

                if (isdebuger && !item._nodebug) {
                    (0, _zepto.zepto)("#widget-testbar").append(inhtml);
                }
            } else {
                if (!item.hasOwnProperty("uri") || item.uri == "") {
                    marslog.log('widget未配置uri：' + JSON.stringify(item));
                    continue;
                }

                //显示测试栏 
                if (isdebuger && !item._nodebug) {
                    var inhtml = '<button type="button" class="btn btn-primary widget-btn" data-widget="' + item.uri + '"  > <i class="fa fa-globe"></i>' + item.name + ' </button>';
                    (0, _zepto.zepto)("#widget-testbar").append(inhtml);
                }

                bindDefOptions(item);
                item._firstConfigBak = (0, _util.clone)(item, removeKeys);
                widgetsdata.push(item); //将配置的加入
            }
        }

        if (isdebuger) {
            (0, _zepto.zepto)("#widget-testbar .widget-btn").each(function () {
                (0, _zepto.zepto)(this).click(function (e) {
                    var uri = (0, _zepto.zepto)(this).attr('data-widget');
                    if (uri == null || uri == "") return;

                    if (isActivate(uri)) {
                        disable(uri);
                    } else {
                        activate(uri);
                    }
                });
            });
        }
    }

    for (var i = 0; i < widgetsdata.length; i++) {
        var item = widgetsdata[i];

        if (item.openAtStart || item.createAtStart) {
            _arrLoadWidget.push(item);
        }
    }

    (0, _zepto.zepto)(window).resize(function () {
        for (var i = 0; i < widgetsdata.length; i++) {
            var item = widgetsdata[i];
            if (item._class) {
                item._class.indexResize(); //BaseWidget: indexResize
            }
        }
    });

    if (isdebuger) {
        var hash = getLocationParam();
        if (hash) {
            activate(hash);
        }
    }

    loadWidgetJs();
}

function getDefWindowOptions() {
    return (0, _util.clone)(defoptions.windowOptions, removeKeys);
}

function getLocationParam() {
    var param = window.location.toString();
    if (param.indexOf("#") === -1) {
        return "";
    }
    param = param.split("#");
    if (param && param.length > 0) {
        return param[1];
    }
}

function bindDefOptions(item) {
    //赋默认值至options（跳过已存在设置值） 
    if (defoptions) {
        for (var aa in defoptions) {
            if (aa == "windowOptions") {
                //for (var jj in defoptions['windowOptions']) {
                //    if (!item['windowOptions'].hasOwnProperty(jj)) {
                //        item['windowOptions'][jj] = defoptions['windowOptions'][jj];
                //    }
                //}
            } else if (!item.hasOwnProperty(aa)) {
                item[aa] = defoptions[aa];
            }
        }
    }

    //赋值内部使用属性 
    item.path = getFilePath(basePath + item.uri);
    item.name = item.name || item.label; //兼容name和label命名
}

//激活指定模块
function activate(item, noDisableOther) {

    if (thismap == null && item.viewer) {
        init(item.viewer);
    }

    //参数是字符串id或uri时
    if (typeof item === 'string') {
        item = { uri: item };

        if (noDisableOther != null) item.disableOther = !noDisableOther; //是否释放其他已激活的插件 
    } else {
        if (item.uri == null) {
            marslog.warn('activate激活widget时需要uri参数！');
        }
    }

    var thisItem;
    for (var i = 0; i < widgetsdata.length; i++) {
        var othitem = widgetsdata[i];
        if (item.uri == othitem.uri || othitem.id && item.uri == othitem.id) {
            thisItem = othitem;
            if (thisItem.isloading) return thisItem; //激活了正在loading的widget 防止快速双击了菜单

            //赋值  
            for (var aa in item) {
                if (aa == "uri") continue;
                thisItem[aa] = item[aa];
            }
            break;
        }
    }

    if (thisItem == null) {
        bindDefOptions(item);
        thisItem = item;
        //非config中配置的，外部传入，首次激活 
        if (!item._firstConfigBak) item._firstConfigBak = (0, _util.clone)(item, removeKeys);
        widgetsdata.push(item);
    }

    if (isdebuger) {
        marslog.log('开始激活widget：' + thisItem.uri);
        window.location.hash = "#" + thisItem.uri;
    }

    //兼容之前历史版本的错误命名时的属性名称
    if (thisItem.hasOwnProperty("disableOhter") && !thisItem.hasOwnProperty("disableOther")) thisItem.disableOther = thisItem.disableOhter;

    //释放其他已激活的插件 
    if (thisItem.disableOther) {
        disableAll(thisItem.uri, thisItem.group);
    } else {
        disableGroup(thisItem.group, thisItem.uri);
    }

    //激活本插件
    if (thisItem._class) {
        if (thisItem._class.isActivate) {
            //已激活时
            if (thisItem._class.update) {
                //刷新
                thisItem._class.update();
            } else {
                //重启
                thisItem._class.disableBase();
                var timetemp = setInterval(function () {
                    if (thisItem._class.isActivate) return;
                    thisItem._class.activateBase();
                    clearInterval(timetemp);
                }, 200);
            }
        } else {
            thisItem._class.activateBase(); // BaseWidget: activateBase
        }
    } else {
        for (var i = 0; i < _arrLoadWidget.length; i++) {
            if (_arrLoadWidget[i].uri == thisItem.uri) //如果已在加载列表中的直接跳出
                return _arrLoadWidget[i];
        }
        _arrLoadWidget.push(thisItem);

        if (_arrLoadWidget.length == 1) {
            loadWidgetJs();
        }
    }
    return thisItem;
}

function getWidget(id) {
    for (var i = 0; i < widgetsdata.length; i++) {
        var item = widgetsdata[i];

        if (id == item.uri || id == item.id) {
            return item;
        }
    }
}

function getClass(id) {
    var item = getWidget(id);
    if (item) return item._class;else return null;
}

function isActivate(id) {
    var _class = getClass(id);
    if (_class == null) return false;
    return _class.isActivate;
}

function disable(id) {
    if (id == null) return;
    for (var i = 0; i < widgetsdata.length; i++) {
        var item = widgetsdata[i];

        if (item._class && (id == item.uri || id == item.id)) {
            item._class.disableBase();
            break;
        }
    }
}

//释放所有widget
function disableAll(nodisable, group) {
    for (var i = 0; i < widgetsdata.length; i++) {
        var item = widgetsdata[i];

        if (group && item.group == group) {
            //同组别的全部释放
        } else {
            if (nodisable !== true && !item.autoDisable) continue;
        }

        //指定不释放的跳过
        if (nodisable && (nodisable == item.uri || nodisable == item.id)) continue;

        if (item._class) {
            item._class.disableBase(); ////BaseWidget: disableBase
        }
    }
}

//释放同组widget
function disableGroup(group, nodisable) {
    if (group == null) return;

    for (var i = 0; i < widgetsdata.length; i++) {
        var item = widgetsdata[i];
        if (item.group == group) {
            //指定不释放的跳过
            if (nodisable && (nodisable == item.uri || nodisable == item.id)) continue;
            if (item._class) {
                item._class.disableBase(); ////BaseWidget: disableBase
            }
        }
    }
}

function eachWidget(callback) {
    for (var i = 0; i < widgetsdata.length; i++) {
        var item = widgetsdata[i];
        callback(item);
    }
}

var _arrLoadWidget = [];
var loadItem;
var isloading;
function loadWidgetJs() {
    if (_arrLoadWidget.length == 0) return;

    if (isloading) {
        setTimeout(loadWidgetJs, 500);
        return;
    }
    isloading = true;

    loadItem = _arrLoadWidget[0];
    loadItem.isloading = true;
    var _uri = loadItem.uri;
    if (cacheVersion) {
        if (_uri.indexOf('?') == -1) _uri += "?time=" + cacheVersion;else _uri += "&time=" + cacheVersion;
    }

    if (window.NProgress) {
        NProgress.start();
    }

    if (isdebuger) marslog.log('开始加载js：' + basePath + _uri);

    _loader.Loader.async([basePath + _uri], function () {
        isloading = false;
        loadItem.isloading = false;
        if (isdebuger) marslog.log('完成js加载：' + basePath + _uri);

        if (window.NProgress) {
            NProgress.done(true);
        }

        _arrLoadWidget.shift();
        loadWidgetJs();
    });
}

function bindClass(_class) {
    if (loadItem == null) {
        var _jspath = getThisJSPath();
        for (var i = 0; i < widgetsdata.length; i++) {
            var item = widgetsdata[i];
            if (_jspath.endsWith(item.uri)) {
                item.isloading = false;
                item._class = new _class(item, thismap);
                item._class.activateBase(); // BaseWidget: activateBase
                return item._class;
            }
        }
    } else {
        loadItem.isloading = false;
        loadItem._class = new _class(loadItem, thismap);
        loadItem._class.activateBase(); // BaseWidget: activateBase
        return loadItem._class;
    }
}

function getThisJSPath() {
    var jsPath;
    var js = document.scripts;
    for (var i = js.length - 1; i >= 0; i--) {
        jsPath = js[i].src;
        if (jsPath == null || jsPath == "") continue;
        if (jsPath.indexOf("widgets") == -1) continue;
        //jsPath = jsPath.substring(0, jsPath.lastIndexOf("/") + 1);
        return jsPath;
    }
    return "";
}

//获取路径
function getFilePath(file) {
    var pos = file.lastIndexOf("/");
    return file.substring(0, pos + 1);
}

function removeDebugeBar() {
    (0, _zepto.zepto)("#widget-testbar").remove();
}

function getCacheVersion() {
    return cacheVersion;
}

function getBasePath() {
    return basePath;
}

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Loader = undefined;

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// cssExpr 用于判断资源是否是css
var cssExpr = new RegExp('\\.css');
var nHead = document.head || document.getElementsByTagName('head')[0];
// `onload` 在WebKit < 535.23， Firefox < 9.0 不被支持
var isOldWebKit = +navigator.userAgent.replace(/.*(?:AppleWebKit|AndroidWebKit)\/?(\d+).*/i, '$1') < 536;

// 判断对应的node节点是否已经载入完成
function isReady(node) {
    return node.readyState === 'complete' || node.readyState === 'loaded';
}

// loadCss 用于载入css资源
function loadCss(url, setting, callback) {
    var node = document.createElement('link');

    node.rel = 'stylesheet';
    addOnload(node, callback, 'css');
    node.async = true;
    node.href = url;

    nHead.appendChild(node);
}

// loadJs 用于载入js资源
function loadJs(url, setting, callback) {
    var node = document.createElement('script');

    node.charset = 'utf-8';
    addOnload(node, callback, 'js');
    node.async = !setting.sync;
    node.src = url;

    nHead.appendChild(node);
}

// 在老的webkit中，因不支持load事件，这里用轮询sheet来保证
function pollCss(node, callback) {
    var isLoaded;

    if (node.sheet) {
        isLoaded = true;
    }

    setTimeout(function () {
        if (isLoaded) {
            // 在这里callback 是为了让样式有足够的时间渲染
            callback();
        } else {
            pollCss(node, callback);
        }
    }, 20);
}

// 用于给指定的节点绑定onload回调
// 监听元素载入完成事件
function addOnload(node, callback, type) {
    var supportOnload = 'onload' in node;
    var isCSS = type === 'css';

    // 对老的webkit和老的firefox的兼容
    if (isCSS && (isOldWebKit || !supportOnload)) {
        setTimeout(function () {
            pollCss(node, callback);
        }, 1);
        return;
    }

    if (supportOnload) {
        node.onload = onload;
        node.onerror = function () {
            node.onerror = null;
            //window._cdnFallback(node);
            if (type == "css") marslog.warn("该css文件不存在：" + node.href);else marslog.warn("该js文件不存在：" + node.src);
            onload();
        };
    } else {
        node.onreadystatechange = function () {
            if (isReady(node)) {
                onload();
            }
        };
    }

    function onload() {

        // 执行一次后清除，防止重复执行
        node.onload = node.onreadystatechange = null;

        node = null;

        callback();
    }
}

// 资源下载入口，根绝文件类型的不同，调用loadCss或者loadJs
function loadItem(url, list, setting, callback) {
    // 如果加载的url为空，就直接成功返回
    if (!url) {
        setTimeout(function () {
            onFinishLoading();
        });
        return;
    }

    if (cssExpr.test(url)) {
        loadCss(url, setting, onFinishLoading);
    } else {
        loadJs(url, setting, onFinishLoading);
    }

    // 每次资源下载完成后，检验是否结束整个list下载过程
    // 若已经完成所有下载，执行回调函数
    function onFinishLoading() {
        var urlIndex = list.indexOf(url);
        if (urlIndex > -1) {
            list.splice(urlIndex, 1);
        }

        if (list.length === 0) {
            callback();
        }
    }
}

function doInit(list, setting, callback) {
    var cb = function cb() {
        callback && callback();
    };

    list = Array.prototype.slice.call(list || []);

    if (list.length === 0) {
        cb();
        return;
    }

    for (var i = 0, len = list.length; i < len; i++) {
        loadItem(list[i], list, setting, cb);
    }
}

// 判断当前页面是否加载完
// 加载完，立刻执行下载
// 未加载完，等待页面load事件以后再进行下载
function ready(node, callback) {
    if (isReady(node)) {
        callback();
    } else {
        // 1500ms 以后，直接开始下载资源文件，不再等待load事件
        var timeLeft = 1500;
        var isExecute = false;
        window.addEventListener('load', function () {
            if (!isExecute) {
                callback();
                isExecute = true;
            }
        });

        setTimeout(function () {
            if (!isExecute) {
                callback();
                isExecute = true;
            }
        }, timeLeft);
    }
}

// 暴露出去的Loader
// 提供async, sync两个函数
// async 用作异步下载执行用，不阻塞页面渲染
// sync  用作异步下载，顺序执行，保证下载的js按照数组顺序执行
var Loader = {
    async: function async(list, callback) {

        ready(document, function () {
            doInit(list, {}, callback);
        });
    },

    sync: function sync(list, callback) {

        ready(document, function () {
            doInit(list, {
                sync: true
            }, callback);
        });
    }
};

//window.Loader = Loader;

exports.Loader = Loader;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureAngle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _measure = __webpack_require__(30);

var measureUtil = _interopRequireWildcard(_measure);

var _matrix = __webpack_require__(17);

var _Attr = __webpack_require__(12);

var _Attr2 = __webpack_require__(19);

var _MeasureBase2 = __webpack_require__(26);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureAngle = exports.MeasureAngle = function (_MeasureBase) {
    _inherits(MeasureAngle, _MeasureBase);

    //========== 构造方法 ========== 
    function MeasureAngle(opts, target) {
        _classCallCheck(this, MeasureAngle);

        var _this = _possibleConstructorReturn(this, (MeasureAngle.__proto__ || Object.getPrototypeOf(MeasureAngle)).call(this, opts, target));

        _this.totalLable = null; //角度label  
        _this.exLine = null; //辅助线
        return _this;
    }

    _createClass(MeasureAngle, [{
        key: 'clearLastNoEnd',


        //清除未完成的数据
        value: function clearLastNoEnd() {
            if (this.totalLable != null) this.dataSource.entities.remove(this.totalLable);
            this.totalLable = null;

            if (this.exLine != null) this.dataSource.entities.remove(this.exLine);
            this.exLine = null;
        }
        //开始绘制

    }, {
        key: '_startDraw',
        value: function _startDraw(options) {
            var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
                horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                show: false
            });

            this.totalLable = this.dataSource.entities.add({
                label: entityattr,
                _noMousePosition: true,
                attribute: {
                    unit: options.unit,
                    type: options.type
                }
            });

            return this.drawControl.startDraw({
                type: "polyline",
                config: { maxPointNum: 2 },
                style: _extends({
                    "lineType": "arrow",
                    "color": "#ebe967",
                    "width": 9,
                    "clampToGround": true,
                    "depthFail": true,
                    "depthFailColor": "#ebe967"
                }, options.style)
            });
        }
        //绘制增加一个点后，显示该分段的长度

    }, {
        key: 'showAddPointLength',
        value: function showAddPointLength(entity) {
            this.showMoveDrawing(entity); //兼容手机端
        }
        //绘制中删除了最后一个点

    }, {
        key: 'showRemoveLastPointLength',
        value: function showRemoveLastPointLength(e) {
            if (this.exLine) {
                this.dataSource.entities.remove(this.exLine);
                this.exLine = null;
            }
            if (this.totalLable) this.totalLable.label.show = false;
        }
        //绘制过程移动中，动态显示长度信息

    }, {
        key: 'showMoveDrawing',
        value: function showMoveDrawing(entity) {
            var positions = this.drawControl.getPositions(entity);
            if (positions.length < 2) {
                this.totalLable.label.show = false;
                return;
            }

            //求长度
            var len = Cesium.Cartesian3.distance(positions[0], positions[1]);

            //求方位角
            var bearing = measureUtil.getAngle(positions[0], positions[1]);;

            //求参考点  
            var new_position = (0, _matrix.getRotateCenterPoint)(positions[0], positions[1], -bearing);
            this.updateExLine([positions[0], new_position]); //参考线

            //显示文本
            this.totalLable.attribute.value = bearing;
            this.totalLable.attribute.valueLen = len;
            this.totalLable.showText = function (unit) {
                var lenstr = util.formatLength(this.attribute.valueLen, unit);
                this.label.text = "角度:" + this.attribute.value + "°\n距离:" + lenstr;
                return lenstr;
            };
            var lenstr = this.totalLable.showText(this.options.unit);

            this.totalLable.position = positions[1];
            this.totalLable.label.show = true;

            this.target.fire(_MarsClass.eventType.change, {
                mtype: this.type,
                value: bearing,
                label: lenstr,
                length: len
            });
        }
    }, {
        key: 'updateExLine',
        value: function updateExLine(positions) {
            if (this.exLine) {
                this.exLine._positions = positions;
            } else {
                var entityattr = (0, _Attr2.style2Entity)(this.options.styleEx, {
                    positions: new Cesium.CallbackProperty(function (time) {
                        return exLine._positions;
                    }, false),
                    width: 3,
                    clampToGround: true,
                    material: new Cesium.PolylineDashMaterialProperty({
                        color: Cesium.Color.RED
                    })
                });

                var exLine = this.dataSource.entities.add({
                    polyline: entityattr
                });
                exLine._positions = positions;
                this.exLine = exLine;
            }
        }
        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            entity._totalLable = this.totalLable;
            this.totalLable = null;

            entity._exLine = this.exLine;
            this.exLine = null;

            this.target.fire(_MarsClass.eventType.end, {
                mtype: this.type,
                entity: entity,
                value: entity._totalLable.attribute.value
            });
        }
    }, {
        key: 'type',
        get: function get() {
            return "angle";
        }
    }]);

    return MeasureAngle;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Slope = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _matrix = __webpack_require__(17);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _polygon = __webpack_require__(13);

var _polyline = __webpack_require__(22);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//坡度坡向 类
var Slope = exports.Slope = function (_MarsClass) {
    _inherits(Slope, _MarsClass);

    function Slope(options, oldparam) {
        _classCallCheck(this, Slope);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (Slope.__proto__ || Object.getPrototypeOf(Slope)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.options = options;
        _this.viewer = options.viewer;

        //箭头的显示长度（米）
        _this.options.arrow = _this.options.arrow || {};
        _this.options.arrow.show = Cesium.defaultValue(_this.options.arrow.show, true);
        _this.options.arrow.scale = Cesium.defaultValue(_this.options.arrow.scale, 0.3); //箭头长度的比例
        _this.options.arrow.width = Cesium.defaultValue(_this.options.arrow.width, 15); //箭头宽度
        _this.options.arrow.color = Cesium.defaultValue(_this.options.arrow.color, Cesium.Color.YELLOW);
        _this.arrowLength = Cesium.defaultValue(_this.options.arrow.length, 40);

        //point点
        _this.options.point = _this.options.point || {};
        _this.options.point.show = Cesium.defaultValue(_this.options.point.show, true);
        _this.options.point.pixelSize = Cesium.defaultValue(_this.options.point.pixelSize, 9);
        _this.options.point.color = Cesium.defaultValue(_this.options.point.color, Cesium.Color.RED.withAlpha(0.5));

        _this.arrowPrimitives = [];
        _this.pointInterPrimitives = new Cesium.PointPrimitiveCollection();
        _this.viewer.scene.primitives.add(_this.pointInterPrimitives);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        if (_this.options.calbackStep) {
            _this.on(_MarsClass2.eventType.endItem, function (e) {
                _this.options.calbackStep(e.data, e.index);
            });
        }
        if (_this.options.calback) {
            _this.on(_MarsClass2.eventType.end, function (e) {
                _this.options.calback(e.data);
            });
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码


        if (options.positions && options.positions.length > 0) {
            _this.add(options.positions, options);
        }
        return _this;
    }

    // 计算  传入Cartesian3 数组 ，贴地坐标


    _createClass(Slope, [{
        key: 'add',
        value: function add(arr, options) {
            if (!arr || arr.length < 1) return;

            options = options || this.options;

            var splitNum = Cesium.defaultValue(options.splitNum, 8);
            if (arr.length > 2 && splitNum > 1) {
                //传入面边界时
                var resultInter = (0, _polygon.interPolygon)({
                    scene: this.viewer.scene,
                    positions: arr,
                    has3dtiles: false,
                    onlyPoint: true, //true时只返回点，不返回三角网
                    splitNum: Cesium.defaultValue(options.splitNum, 8) //splitNum插值分割的个数
                });
                this.arrowLength = Cesium.Math.chordLength(resultInter.granularity, this.viewer.scene.globe.ellipsoid.maximumRadius) * this.options.arrow.scale;

                arr = [];
                for (var k = 0; k < resultInter.list.length; k++) {
                    arr.push(resultInter.list[k].pointDM);
                }
            }

            this.stateAll = arr.length;
            this.stateOkIndex = 0;
            this.instances = [];
            this.arrData = [];

            for (var i = 0; i < this.stateAll; i++) {
                this._fxOnePoint(arr[i], options);
            }
        }

        //分析单个点的对应坡度

    }, {
        key: '_fxOnePoint',
        value: function _fxOnePoint(position, options) {
            if (!position) return;

            //返回该点的周边2米圆上的8个点
            var arcPoint = (0, _polygon.getEllipseOuterPositions)({
                position: position,
                radius: Cesium.defaultValue(options.radius, 2), //半径
                count: Cesium.defaultValue(options.count, 4) //共返回8(count*4)个点
            });
            arcPoint.push(position);

            var ellipsoid = this.viewer.scene.globe.ellipsoid;

            // 求出点的详细高度
            var that = this;
            (0, _polyline.computeSurfacePoints)({
                scene: this.viewer.scene,
                positions: arcPoint,
                has3dtiles: options.has3dtiles,
                callback: function callback(raisedPositions, noHeight) {
                    if (noHeight) {
                        marslog.log("未获取到高度值，贴地高度计算存在误差");
                    }

                    var cartographicArray = ellipsoid.cartesianArrayToCartographicArray(raisedPositions);

                    // 中心点
                    var center = cartographicArray.pop();

                    // 其余圆上点  
                    var maxIndex = 0;
                    var maxHeight = cartographicArray[0].height;
                    var minIndex = 0;
                    var minHeight = cartographicArray[0].height;
                    for (var i = 1; i < cartographicArray.length - 1; i++) {
                        var item = cartographicArray[i];
                        if (item.height > maxHeight) {
                            maxHeight = item.height;
                            maxIndex = i;
                        }
                        if (item.height < minHeight) {
                            minHeight = item.height;
                            minIndex = i;
                        }
                    }

                    var maxPoint = cartographicArray[maxIndex]; //周边最高点
                    var minPoint = cartographicArray[minIndex]; //周边最低点

                    var slopeVal1 = that.getSlope(center, maxPoint);
                    var slopeVal2 = that.getSlope(center, minPoint);

                    if (slopeVal1 > slopeVal2) {
                        that._fxOnePointOk(position, center, maxPoint, slopeVal1);
                    } else {
                        that._fxOnePointOk(position, center, minPoint, slopeVal2);
                    }
                }
            });
        }

        //分析单个点的对应坡度完成后添加显示的箭头等

    }, {
        key: '_fxOnePointOk',
        value: function _fxOnePointOk(position, center, maxPoint, slopeVal) {
            var _this2 = this;

            var centerCar = Cesium.Cartographic.toCartesian(center);
            var maxPointCar = Cesium.Cartographic.toCartesian(maxPoint);
            maxPointCar = (0, _matrix.getOnLinePointByLen)(centerCar, maxPointCar, this.arrowLength);

            // 计算圆上的最高点和中心点的高度 判断箭头方向 
            var arrArrowPt;
            if (center.height > maxPoint.height) {
                //中心点高于四周情况下
                arrArrowPt = [centerCar, maxPointCar];
            } else {
                //边缘指向中心 
                arrArrowPt = [maxPointCar, centerCar];
            }

            //求方位角
            var slopeAngle = (0, _util.getAngle)(arrArrowPt[0], arrArrowPt[1]);

            var slopeValDou = Math.atan(slopeVal) * 180 / Math.PI;
            slopeValDou = Number(slopeValDou.toFixed(2));

            // 度数法 【 α(坡度)=arc tan (高程差/水平距离)】 eg: 45°
            var text1 = slopeValDou + "°";
            // 百分比法 【 坡度 = (高程差/水平距离)x100%】 eg:30%  
            var text2 = (slopeVal * 100).toFixed(2) + "%";

            var itemData = {
                position: position, //坐标位置
                slope: slopeValDou, //度数法值【 α(坡度)=arc tan (高程差/水平距离)】
                slopeStr1: text1, //度数法值字符串
                slopeStr2: text2, //百分比法值字符串【 坡度 = (高程差/水平距离)x100%】
                direction: slopeAngle //坡向值（0-360度）
            };
            this.arrData.push(itemData);

            this.fire(_MarsClass2.eventType.endItem, {
                data: itemData,
                index: this.stateOkIndex
            });

            // 构建箭头
            if (this.options.arrow.show) {
                var gs = new Cesium.GeometryInstance({
                    geometry: new Cesium.PolylineGeometry(_extends({
                        positions: arrArrowPt
                    }, this.options.arrow)),
                    vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT,
                    id: "polylinedashinstance"
                });
                this.instances.push(gs);
            }

            // 添加点 显示坡度
            if (this.options.point.show) {
                var primitive = this.pointInterPrimitives.add(_extends({
                    position: centerCar
                }, this.options.point));

                primitive.properties = itemData;
                primitive.click = function (event, position) {
                    _this2.fire(_MarsClass2.eventType.click, {
                        data: event.properties,
                        position: position
                    });
                    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
                    if (_this2.options.click) _this2.options.click(event, position);
                };
                primitive.tooltip = Cesium.defaultValue(this.options.tooltip, '\u5761\u5EA6: ' + text1 + '  (' + text2 + ')<br />\u5761\u5411: ' + slopeAngle + '\xB0'); // 显示结果      
                primitive.popup = this.options.popup;
            }

            // 全部计算完成 
            this.stateOkIndex++;
            if (this.stateOkIndex >= this.stateAll) {
                if (this.options.arrow.show && this.instances.length > 0) {
                    var arrowPrimitive = this.viewer.scene.primitives.add(new Cesium.Primitive({
                        geometryInstances: this.instances,
                        appearance: new Cesium.PolylineMaterialAppearance({
                            material: Cesium.Material.fromType('PolylineArrow', {
                                color: this.options.arrow.color
                            })
                        })
                    }));
                    this.arrowPrimitives.push(arrowPrimitive);
                    this.instances = [];
                }

                this.fire(_MarsClass2.eventType.end, {
                    data: this.arrData
                });
            }
        }

        // 两点之间的坡度

    }, {
        key: 'getSlope',
        value: function getSlope(c1, c2) {
            if (!c1 || !c2) return;
            var differH = Math.abs(c1.height - c2.height); //高度差
            var differV = Cesium.Cartesian3.distance(Cesium.Cartographic.toCartesian(c1), Cesium.Cartesian3.fromRadians(c2.longitude, c2.latitude, c1.height)); // 水平距离
            var value = differH / differV;
            return value;
        }

        // 清除

    }, {
        key: 'clear',
        value: function clear() {
            if (this.pointInterPrimitives) this.pointInterPrimitives.removeAll();

            for (var i = 0, len = this.arrowPrimitives.length; i < len; i++) {
                this.viewer.scene.primitives.remove(this.arrowPrimitives[i]);
            }
            this.arrowPrimitives = [];
            this.instances = [];
            this.arrData = [];
            this.stateAll = 0;
            this.stateOkIndex = 0;
        }

        //销毁

    }, {
        key: 'destroy',
        value: function destroy() {
            this.clear();
            _get(Slope.prototype.__proto__ || Object.getPrototypeOf(Slope.prototype), 'destroy', this).call(this);
        }
    }]);

    return Slope;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


Slope.event = {
    endItem: _MarsClass2.eventType.endItem,
    end: _MarsClass2.eventType.end
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureAreaSurface = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _measure = __webpack_require__(30);

var measureUtil = _interopRequireWildcard(_measure);

var _point = __webpack_require__(2);

var _MeasureArea2 = __webpack_require__(36);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//贴地线
var MeasureAreaSurface = exports.MeasureAreaSurface = function (_MeasureArea) {
    _inherits(MeasureAreaSurface, _MeasureArea);

    function MeasureAreaSurface() {
        _classCallCheck(this, MeasureAreaSurface);

        return _possibleConstructorReturn(this, (MeasureAreaSurface.__proto__ || Object.getPrototypeOf(MeasureAreaSurface)).apply(this, arguments));
    }

    _createClass(MeasureAreaSurface, [{
        key: '_startDraw',

        //开始绘制
        value: function _startDraw(options) {
            options.style.clampToGround = true;

            return _get(MeasureAreaSurface.prototype.__proto__ || Object.getPrototypeOf(MeasureAreaSurface.prototype), '_startDraw', this).call(this, options);
        }
        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            // super.showDrawEnd(entity); 
            if (entity.polygon == null) return;

            entity._totalLable = this.totalLable;
            this.totalLable = null;

            this.updateAreaForTerrain(entity);
        }

        //计算贴地面

    }, {
        key: 'updateAreaForTerrain',
        value: function updateAreaForTerrain(entity) {
            var _this2 = this;

            var that = this;

            //更新lable等
            var totalLable = entity._totalLable;
            var unit = totalLable && totalLable.attribute && totalLable.attribute.unit;
            var thisCenter = (0, _point.getPositionValue)(totalLable.position);

            var positions = this.drawControl.getPositions(entity);

            this.target.fire(_MarsClass.eventType.start, {
                mtype: this.type
            });

            //贴地总面积
            measureUtil.getClampArea(positions, {
                scene: viewer.scene,
                splitNum: this.options.splitNum,
                has3dtiles: this.options.has3dtiles,
                asyn: true, //异步求准确的
                callback: function callback(area, resultInter) {
                    // if (that.options.onInterEnd)
                    //     that.options.onInterEnd(resultInter);

                    totalLable.position = (0, _point.setPositionsHeight)(thisCenter, resultInter.maxHeight); //更新lable高度

                    totalLable.attribute.value = area;
                    var areastr = totalLable.showText(unit);

                    _this2.target.fire(_MarsClass.eventType.change, {
                        mtype: _this2.type,
                        value: area,
                        label: areastr
                    });
                    _this2.target.fire(_MarsClass.eventType.end, _extends({}, resultInter, {
                        mtype: _this2.type,
                        entity: entity,
                        value: area
                    }));
                }
            });
        }
    }, {
        key: 'type',
        get: function get() {
            return "areaSurface";
        }
    }]);

    return MeasureAreaSurface;
}(_MeasureArea2.MeasureArea);

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureHeight = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _Attr = __webpack_require__(12);

var _MeasureBase2 = __webpack_require__(26);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureHeight = exports.MeasureHeight = function (_MeasureBase) {
    _inherits(MeasureHeight, _MeasureBase);

    //========== 构造方法 ========== 
    function MeasureHeight(opts, target) {
        _classCallCheck(this, MeasureHeight);

        var _this = _possibleConstructorReturn(this, (MeasureHeight.__proto__ || Object.getPrototypeOf(MeasureHeight)).call(this, opts, target));

        _this.totalLable = null; //高度label  
        return _this;
    }

    _createClass(MeasureHeight, [{
        key: 'clearLastNoEnd',

        //清除未完成的数据
        value: function clearLastNoEnd() {
            if (this.totalLable != null) this.dataSource.entities.remove(this.totalLable);
            this.totalLable = null;
        }
        //开始绘制

    }, {
        key: '_startDraw',
        value: function _startDraw(options) {
            var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
                horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                show: false
            });

            this.totalLable = this.dataSource.entities.add({
                label: entityattr,
                _noMousePosition: true,
                attribute: {
                    unit: options.unit,
                    type: options.type
                }
            });

            return this.drawControl.startDraw({
                type: "polyline",
                config: { maxPointNum: 2 },
                style: _extends({
                    "lineType": "glow",
                    "color": "#ebe12c",
                    "width": 9,
                    "glowPower": 0.1,
                    "depthFail": true,
                    "depthFailColor": "#ebe12c"
                }, options.style)
            });
        }
        //绘制增加一个点后，显示该分段的长度

    }, {
        key: 'showAddPointLength',
        value: function showAddPointLength(entity) {
            this.showMoveDrawing(entity); //兼容手机端
        }
        //绘制中删除了最后一个点

    }, {
        key: 'showRemoveLastPointLength',
        value: function showRemoveLastPointLength(e) {
            if (this.totalLable) this.totalLable.label.show = false;
        }
        //绘制过程移动中，动态显示长度信息

    }, {
        key: 'showMoveDrawing',
        value: function showMoveDrawing(entity) {
            var positions = this.drawControl.getPositions(entity);
            if (positions.length < 2) {
                this.totalLable.label.show = false;
                return;
            }

            var cartographic = Cesium.Cartographic.fromCartesian(positions[0]);
            var cartographic1 = Cesium.Cartographic.fromCartesian(positions[1]);
            var height = Math.abs(cartographic1.height - cartographic.height);

            //绑定值及text显示
            this.totalLable.attribute.value = height;
            this.totalLable.showText = function (unit) {
                var heightstr = util.formatLength(this.attribute.value, unit);
                this.label.text = "高度差:" + heightstr;
                return heightstr;
            };
            var heightstr = this.totalLable.showText(this.options.unit);

            //位置
            this.totalLable.position = Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
            this.totalLable.label.show = true;

            this.target.fire(_MarsClass.eventType.change, {
                mtype: this.type,
                value: height,
                label: heightstr
            });
        }
        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            entity._totalLable = this.totalLable;
            this.totalLable = null;

            this.target.fire(_MarsClass.eventType.end, {
                mtype: this.type,
                entity: entity,
                value: entity._totalLable.attribute.value
            });
        }
    }, {
        key: 'type',
        get: function get() {
            return "height";
        }
    }]);

    return MeasureHeight;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureHeightTriangle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _Attr = __webpack_require__(12);

var _MeasureBase2 = __webpack_require__(26);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureHeightTriangle = exports.MeasureHeightTriangle = function (_MeasureBase) {
    _inherits(MeasureHeightTriangle, _MeasureBase);

    //========== 构造方法 ========== 
    function MeasureHeightTriangle(opts, target) {
        _classCallCheck(this, MeasureHeightTriangle);

        var _this = _possibleConstructorReturn(this, (MeasureHeightTriangle.__proto__ || Object.getPrototypeOf(MeasureHeightTriangle)).call(this, opts, target));

        _this.totalLable = null; //高度差label
        _this.xLable = null; //水平距离label
        _this.hLable = null; //水平距离label
        return _this;
    }

    _createClass(MeasureHeightTriangle, [{
        key: 'clearLastNoEnd',

        //清除未完成的数据
        value: function clearLastNoEnd() {
            if (this.totalLable != null) this.dataSource.entities.remove(this.totalLable);
            if (this.xLable != null) this.dataSource.entities.remove(this.xLable);
            if (this.hLable != null) this.dataSource.entities.remove(this.hLable);

            this.totalLable = null;
            this.xLable = null;
            this.hLable = null;
        }
        //开始绘制

    }, {
        key: '_startDraw',
        value: function _startDraw(options) {

            var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
                horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
                verticalOrigin: Cesium.VerticalOrigin.CENTER,
                show: false
            });
            this.totalLable = this.dataSource.entities.add({
                label: entityattr,
                _noMousePosition: true,
                attribute: {
                    unit: options.unit,
                    type: options.type
                }
            });

            var entityattr2 = (0, _Attr.style2Entity)(this.labelStyle, {
                horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                show: false
            });
            entityattr2.pixelOffset = new Cesium.Cartesian2(0, 0);
            this.xLable = this.dataSource.entities.add({
                label: entityattr2,
                _noMousePosition: true,
                attribute: {
                    unit: options.unit,
                    type: options.type
                }
            });

            this.hLable = this.dataSource.entities.add({
                label: entityattr2,
                _noMousePosition: true,
                attribute: {
                    unit: options.unit,
                    type: options.type
                }
            });

            return this.drawControl.startDraw({
                type: "polyline",
                config: { maxPointNum: 2 },
                style: _extends({
                    "lineType": "glow",
                    "color": "#ebe12c",
                    "width": 9,
                    "glowPower": 0.1,
                    "depthFail": true,
                    "depthFailColor": "#ebe12c"
                }, options.style)
            });
        }
        //绘制增加一个点后，显示该分段的长度

    }, {
        key: 'showAddPointLength',
        value: function showAddPointLength(entity) {
            var lonlats = this.drawControl.getPositions(entity);
            if (lonlats.length == 4) {
                var mouseEndPosition = lonlats[3].clone();
                lonlats.pop();
                lonlats.pop();
                lonlats.pop();
                lonlats.push(mouseEndPosition);
            }

            if (lonlats.length == 2) {
                var zCartesian = this.getZHeightPosition(lonlats[0], lonlats[1]);
                var hDistance = this.getHDistance(lonlats[0], lonlats[1]);
                if (hDistance > 3.0) {
                    lonlats.push(zCartesian);
                    lonlats.push(lonlats[0]);
                }
            }

            this.showSuperHeight(lonlats);
        }
        //绘制中删除了最后一个点 

    }, {
        key: 'showRemoveLastPointLength',
        value: function showRemoveLastPointLength(e) {
            var lonlats = this.drawControl.getPositions(e.entity);
            if (lonlats.length == 2) {
                lonlats.pop();
                lonlats.pop();

                this.totalLable.label.show = false;
                this.hLable.label.show = false;
                this.xLable.label.show = false;
            }
        }
        //绘制过程移动中，动态显示长度信息

    }, {
        key: 'showMoveDrawing',
        value: function showMoveDrawing(entity) {
            var lonlats = this.drawControl.getPositions(entity);
            if (lonlats.length == 4) {
                var mouseEndPosition = lonlats[3].clone();
                lonlats.pop();
                lonlats.pop();
                lonlats.pop();
                lonlats.push(mouseEndPosition);
            }

            if (lonlats.length == 2) {
                var zCartesian = this.getZHeightPosition(lonlats[0], lonlats[1]);
                var hDistance = this.getHDistance(lonlats[0], lonlats[1]);
                if (hDistance > 3.0) {
                    lonlats.push(zCartesian);
                    lonlats.push(lonlats[0]);
                }
            }
            this.showSuperHeight(lonlats);
        }
        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            var lonlats = this.drawControl.getPositions(entity);
            if (lonlats.length == 3) {
                //有时候，快速双击会少一个点
                lonlats.push(lonlats[0]);
            }

            entity.arrEntityEx = [this.totalLable, this.hLable, this.xLable];

            this.target.fire(_MarsClass.eventType.end, {
                mtype: this.type,
                entity: entity,
                value: this.totalLable.attribute.value
            });

            this.totalLable = null;
            this.hLable = null;
            this.xLable = null;
        }

        /**
         * 超级 高程测量
         * 由4个点形成的三角形（首尾点相同），计算该三角形三条线段的长度
         * @param {Array} positions 4个点形成的点数组
         */

    }, {
        key: 'showSuperHeight',
        value: function showSuperHeight(positions) {
            var vLength; //垂直距离
            var hLength; //水平距离
            var lLength; //长度
            var height;
            if (positions.length == 4) {
                var midLPoint = Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
                var midXPoint, midHPoint;
                var cartographic0 = Cesium.Cartographic.fromCartesian(positions[0]);
                var cartographic1 = Cesium.Cartographic.fromCartesian(positions[1]);
                var cartographic2 = Cesium.Cartographic.fromCartesian(positions[2]);
                var tempHeight = cartographic1.height - cartographic2.height;
                height = cartographic1.height - cartographic0.height;
                lLength = Cesium.Cartesian3.distance(positions[0], positions[1]);
                if (height > -1 && height < 1) {
                    midHPoint = positions[1];
                    this.updateSuperHeightLabel(this.totalLable, midHPoint, "高度差:", height);
                    this.updateSuperHeightLabel(this.hLable, midLPoint, "", lLength);
                } else {
                    if (tempHeight > -0.1 && tempHeight < 0.1) {
                        midXPoint = Cesium.Cartesian3.midpoint(positions[2], positions[1], new Cesium.Cartesian3());
                        midHPoint = Cesium.Cartesian3.midpoint(positions[2], positions[3], new Cesium.Cartesian3());
                        hLength = Cesium.Cartesian3.distance(positions[1], positions[2]);
                        vLength = Cesium.Cartesian3.distance(positions[3], positions[2]);
                    } else {
                        midHPoint = Cesium.Cartesian3.midpoint(positions[2], positions[1], new Cesium.Cartesian3());
                        midXPoint = Cesium.Cartesian3.midpoint(positions[2], positions[3], new Cesium.Cartesian3());
                        hLength = Cesium.Cartesian3.distance(positions[3], positions[2]);
                        vLength = Cesium.Cartesian3.distance(positions[1], positions[2]);
                    }
                    this.updateSuperHeightLabel(this.totalLable, midHPoint, "高度差:", vLength);
                    this.updateSuperHeightLabel(this.xLable, midXPoint, "", hLength);
                    this.updateSuperHeightLabel(this.hLable, midLPoint, "", lLength);
                }
            } else if (positions.length == 2) {
                vLength = Cesium.Cartesian3.distance(positions[1], positions[0]);
                var midHPoint = Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
                if (this.xLable.label.show) {
                    this.xLable.label.show = false;
                    this.hLable.label.show = false;
                }
                this.updateSuperHeightLabel(this.totalLable, midHPoint, "高度差:", vLength);
            }

            var heightstr = util.formatLength(vLength, this.options.unit);

            this.target.fire(_MarsClass.eventType.change, {
                mtype: this.type,
                value: vLength, //垂直距离 高度差
                label: heightstr,
                length: lLength, //空间长度
                hLength: hLength //水平距离
            });
        }
        /**
         * 超级 高程测量 显示标签
         * @param {Cesium.Label} currentLabel 显示标签
         * @param {Cesium.Cartesian3} postion 坐标位置
         * @param {String} type 类型("高度差"，"水平距离"，"长度")
         * @param {Object} value 值
         */

    }, {
        key: 'updateSuperHeightLabel',
        value: function updateSuperHeightLabel(currentLabel, postion, type, value) {
            if (currentLabel == null) return;

            currentLabel.position = postion;
            currentLabel.label.show = true;

            //绑定值及text显示
            currentLabel.attribute.value = value;
            currentLabel.attribute.textEx = type;
            currentLabel.showText = function (unit) {
                var heightstr = util.formatLength(this.attribute.value, unit);
                this.label.text = this.attribute.textEx + heightstr;
                return heightstr;
            };
            currentLabel.showText(this.options.unit);
        }

        /**
           * 带有高度差的两点，判断其直角点 
           */

    }, {
        key: 'getZHeightPosition',
        value: function getZHeightPosition(cartesian1, cartesian2) {
            var carto1 = Cesium.Cartographic.fromCartesian(cartesian1);
            var lng1 = Number(Cesium.Math.toDegrees(carto1.longitude));
            var lat1 = Number(Cesium.Math.toDegrees(carto1.latitude));
            var height1 = Number(carto1.height.toFixed(2));

            var carto2 = Cesium.Cartographic.fromCartesian(cartesian2);
            var lng2 = Number(Cesium.Math.toDegrees(carto2.longitude));
            var lat2 = Number(Cesium.Math.toDegrees(carto2.latitude));
            var height2 = Number(carto2.height.toFixed(2));

            if (height1 > height2) return Cesium.Cartesian3.fromDegrees(lng2, lat2, height1);else return Cesium.Cartesian3.fromDegrees(lng1, lat1, height2);
        }

        /**
         * 带有高度差的两点，计算两点间的水平距离 
         */

    }, {
        key: 'getHDistance',
        value: function getHDistance(cartesian1, cartesian2) {
            var zCartesian = this.getZHeightPosition(cartesian1, cartesian2);

            var carto1 = Cesium.Cartographic.fromCartesian(cartesian2);
            var cartoZ = Cesium.Cartographic.fromCartesian(zCartesian);

            var hDistance = Cesium.Cartesian3.distance(cartesian1, zCartesian);

            if (Math.abs(Number(cartoZ.height) - Number(carto1.height)) < 0.01) {
                hDistance = Cesium.Cartesian3.distance(cartesian2, zCartesian);
            }

            return hDistance;
        }
    }, {
        key: 'type',
        get: function get() {
            return "heightTriangle";
        }
    }]);

    return MeasureHeightTriangle;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureLengthSection = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _point = __webpack_require__(2);

var _polyline = __webpack_require__(22);

var _MeasureLength2 = __webpack_require__(37);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureLengthSection = exports.MeasureLengthSection = function (_MeasureLength) {
    _inherits(MeasureLengthSection, _MeasureLength);

    function MeasureLengthSection() {
        _classCallCheck(this, MeasureLengthSection);

        return _possibleConstructorReturn(this, (MeasureLengthSection.__proto__ || Object.getPrototypeOf(MeasureLengthSection)).apply(this, arguments));
    }

    _createClass(MeasureLengthSection, [{
        key: '_startDraw',

        //开始绘制
        value: function _startDraw(options) {
            options.style.clampToGround = true;
            options.splitNum = Cesium.defaultValue(options.splitNum, 200);

            return _get(MeasureLengthSection.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSection.prototype), '_startDraw', this).call(this, options);
        }

        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            _get(MeasureLengthSection.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSection.prototype), 'showDrawEnd', this).call(this, entity);
            this.updateSectionForTerrain(entity);
        }

        //计算剖面

    }, {
        key: 'updateSectionForTerrain',
        value: function updateSectionForTerrain(entity) {
            var _this2 = this;

            var positions = entity.polyline.positions.getValue(viewer.clock.currentTime);
            if (positions.length < 2) return;

            var arrLables = entity.arrEntityEx;
            var totalLable = entity._totalLable;
            var unit = totalLable && totalLable.attribute && totalLable.attribute.unit;

            this.target.fire(_MarsClass.eventType.start, {
                mtype: this.type
            });

            var all_distance = 0;
            var arrLen = [];
            var arrHB = [];
            var arrLX = [];
            var arrPoint = [];
            // var positionsNew = [];

            var that = this;
            (0, _polyline.computeStepSurfaceLine)({
                viewer: viewer,
                positions: positions,
                splitNum: that.options.splitNum,
                has3dtiles: that.options.has3dtiles,
                //计算每个分段后的回调方法
                endItem: function endItem(raisedPositions, noHeight, index) {
                    var h1 = Cesium.Cartographic.fromCartesian(positions[index]).height;
                    var h2 = Cesium.Cartographic.fromCartesian(positions[index + 1]).height;
                    var hstep = (h2 - h1) / raisedPositions.length;

                    var this_distance = 0;
                    for (var i = 0; i < raisedPositions.length; i++) {
                        //长度
                        if (i != 0) {
                            var templen = Cesium.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
                            all_distance += templen;
                            this_distance += templen;
                        }
                        arrLen.push(Number(all_distance.toFixed(1)));

                        //海拔高度
                        var point = (0, _point.formatPosition)(raisedPositions[i]);
                        arrHB.push(point.z);
                        arrPoint.push(point);

                        //路线高度
                        var fxgd = Number((h1 + hstep * i).toFixed(1));
                        arrLX.push(fxgd);
                    }

                    index++;
                    var thisLabel = arrLables[index];
                    if (thisLabel) {
                        thisLabel.attribute.value = all_distance;
                        thisLabel.attribute.valueFD = this_distance;
                        thisLabel.showText(unit);
                    } else if (index == positions.length - 1 && totalLable) {
                        //最后一个 
                        totalLable.attribute.value = all_distance;
                        totalLable.attribute.valueFD = this_distance;
                        totalLable.showText(unit);
                    }
                },
                //计算全部完成的回调方法
                end: function end() {
                    var distancestr = util.formatLength(all_distance, unit);

                    _this2.target.fire(_MarsClass.eventType.end, {
                        mtype: _this2.type,
                        entity: entity,

                        distancestr: distancestr,
                        distance: all_distance,
                        arrLen: arrLen,
                        arrLX: arrLX,
                        arrHB: arrHB,
                        arrPoint: arrPoint
                    });
                }
            });
        }
    }, {
        key: 'type',
        get: function get() {
            return "section";
        }
    }]);

    return MeasureLengthSection;
}(_MeasureLength2.MeasureLength);

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureLengthSurface = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _measure = __webpack_require__(30);

var measureUtil = _interopRequireWildcard(_measure);

var _MeasureLength2 = __webpack_require__(37);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//贴地线
var MeasureLengthSurface = exports.MeasureLengthSurface = function (_MeasureLength) {
    _inherits(MeasureLengthSurface, _MeasureLength);

    function MeasureLengthSurface() {
        _classCallCheck(this, MeasureLengthSurface);

        return _possibleConstructorReturn(this, (MeasureLengthSurface.__proto__ || Object.getPrototypeOf(MeasureLengthSurface)).apply(this, arguments));
    }

    _createClass(MeasureLengthSurface, [{
        key: '_startDraw',

        //开始绘制
        value: function _startDraw(options) {
            options.style.clampToGround = true;

            return _get(MeasureLengthSurface.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSurface.prototype), '_startDraw', this).call(this, options);
        }

        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            _get(MeasureLengthSurface.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSurface.prototype), 'showDrawEnd', this).call(this, entity);
            this.updateLengthForTerrain(entity);
        }

        //计算贴地线

    }, {
        key: 'updateLengthForTerrain',
        value: function updateLengthForTerrain(entity) {
            var that = this;
            var positions = entity.polyline.positions.getValue(viewer.clock.currentTime);
            var arrLables = entity.arrEntityEx;
            var totalLable = entity._totalLable;
            var unit = totalLable && totalLable.attribute && totalLable.attribute.unit;

            this.target.fire(_MarsClass.eventType.start, {
                mtype: this.type
            });

            //求贴地线长度
            measureUtil.getClampLength(positions, {
                scene: viewer.scene,
                splitNum: that.options.splitNum,
                has3dtiles: that.options.has3dtiles,
                disTerrainScale: that.disTerrainScale, //求高度失败，概略估算值
                //计算每个分段后的回调方法
                endItem: function endItem(result) {
                    var index = result.index;
                    var all_distance = result.all_distance;
                    var distance = result.distance;

                    index++;
                    var thisLabel = arrLables[index];
                    if (thisLabel) {
                        thisLabel.attribute.value = all_distance;
                        thisLabel.attribute.valueFD = distance;
                        thisLabel.showText(unit);
                    } else if (index == positions.length - 1 && totalLable) {
                        //最后一个 
                        totalLable.attribute.value = all_distance;
                        totalLable.attribute.valueFD = distance;
                        totalLable.showText(unit);
                    }
                },
                //计算全部完成的回调方法
                callback: function callback(all_distance) {
                    var distancestr = util.formatLength(all_distance, unit);

                    that.target.fire(_MarsClass.eventType.change, {
                        mtype: that.type,
                        value: all_distance,
                        label: distancestr
                    });
                    that.target.fire(_MarsClass.eventType.end, {
                        mtype: that.type,
                        entity: entity,
                        value: all_distance
                    });
                }
            });
        }
    }, {
        key: 'type',
        get: function get() {
            return "lengthSurface";
        }
    }]);

    return MeasureLengthSurface;
}(_MeasureLength2.MeasureLength);

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasurePoint = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _point = __webpack_require__(2);

var _MeasureBase2 = __webpack_require__(26);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasurePoint = exports.MeasurePoint = function (_MeasureBase) {
    _inherits(MeasurePoint, _MeasureBase);

    //========== 构造方法 ========== 
    function MeasurePoint(opts, target) {
        _classCallCheck(this, MeasurePoint);

        var _this = _possibleConstructorReturn(this, (MeasurePoint.__proto__ || Object.getPrototypeOf(MeasurePoint)).call(this, opts, target));

        _this.totalLable = null; //角度label   
        return _this;
    }

    _createClass(MeasurePoint, [{
        key: 'clearLastNoEnd',

        //清除未完成的数据
        value: function clearLastNoEnd() {
            viewer.mars.popup.close();
        }
        //开始绘制

    }, {
        key: '_startDraw',
        value: function _startDraw(options) {
            return this.drawControl.startDraw({
                type: "point",
                style: _extends({
                    "visibleDepth": false
                }, options.style)
            });
        }
        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            var position = this.drawControl.getPositions(entity)[0];

            var point = (0, _point.formatPosition)(position);
            var x2 = util.formatDegree(point.x);
            var y2 = util.formatDegree(point.y);

            var html = '<div class="mars-popup-titile">\u5750\u6807\u6D4B\u91CF</div>\n                    <div class="mars-popup-content">\n                        <div><label>\u7ECF\u5EA6</label>' + point.x + '&nbsp;&nbsp;' + x2 + '</div>\n                        <div><label>\u7EAC\u5EA6</label>' + point.y + '&nbsp;&nbsp;&nbsp;&nbsp;' + y2 + '</div>\n                        <div><label>\u6D77\u62D4</label>' + point.z + '\u7C73</div>\n                    </div>';

            entity.popup = {
                html: html,
                anchor: [0, -15]
            };
            viewer.mars.popup.show(entity);

            this.target.fire(_MarsClass.eventType.end, {
                mtype: this.type,
                entity: entity,
                position: position,
                point: point
            });
        }
    }, {
        key: 'type',
        get: function get() {
            return "point";
        }
    }]);

    return MeasurePoint;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureVolume = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

var _polygon = __webpack_require__(13);

var _Attr = __webpack_require__(12);

var _Attr2 = __webpack_require__(21);

var _index = __webpack_require__(20);

var _MeasureArea2 = __webpack_require__(36);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//体积测量（方量）
var MeasureVolume = exports.MeasureVolume = function (_MeasureArea) {
    _inherits(MeasureVolume, _MeasureArea);

    function MeasureVolume(opts, target) {
        _classCallCheck(this, MeasureVolume);

        //高度文本样式
        var _this = _possibleConstructorReturn(this, (MeasureVolume.__proto__ || Object.getPrototypeOf(MeasureVolume)).call(this, opts, target));

        _this.labelHeightStyle = _extends({}, _this.labelStyle, {
            "font_size": 15,
            "background": false
        });
        if (Cesium.defined(opts.labelHeight)) {
            _this.labelHeightStyle = _extends({}, _this.labelHeightStyle, opts.labelHeight);
        }

        //面的样式
        _this.polygonStyle = (0, _index.getDefStyle)("polygon", {
            color: "#00fff2",
            opacity: 0.4
        });
        if (Cesium.defined(opts.polygon)) {
            _this.polygonStyle = _extends({}, _this.polygonStyle, opts.polygon);
        }

        //基准面的样式
        _this.polygonJzmStyle = (0, _index.getDefStyle)("polygon", {
            "color": "#00ff00",
            "opacity": 0.3
        });
        if (Cesium.defined(opts.polygonJzm)) {
            _this.polygonJzmStyle = _extends({}, _this.polygonJzmStyle, opts.polygonJzm);
        }

        _this.heightLabel = Cesium.defaultValue(opts.heightLabel, true);
        _this.offsetLabel = Cesium.defaultValue(opts.offsetLabel, false);

        _this._last_depthTestAgainstTerrain = _this.viewer.scene.globe.depthTestAgainstTerrain;
        _this._hasFX = false;
        return _this;
    }
    //========== 对外属性 ==========  


    _createClass(MeasureVolume, [{
        key: '_startDraw',


        //开始绘制
        value: function _startDraw(options) {
            this.clear();
            options.style = this.polygonStyle || options.style;
            return _get(MeasureVolume.prototype.__proto__ || Object.getPrototypeOf(MeasureVolume.prototype), '_startDraw', this).call(this, options);
        }
        //绘制完成后

    }, {
        key: 'showDrawEnd',
        value: function showDrawEnd(entity) {
            var _this2 = this;

            if (entity.polygon == null) return;

            this.totalLable.label.text = "正在计算体积…";

            var positions = this.drawControl.getPositions(entity);
            setTimeout(function () {
                _this2.calcVolume(positions, function () {
                    _this2.drawControl.deleteEntity(entity);
                });
            }, 500);
        }
        //外部使用，直接传positons方式

    }, {
        key: 'start',
        value: function start(positions, options) {
            this.options = options;
            this.calcVolume(positions);
        }
        //计算贴地面

    }, {
        key: 'calcVolume',
        value: function calcVolume(positions, _callback) {
            var _this3 = this;

            this.target.fire(_MarsClass.eventType.start, {
                mtype: this.type,
                positions: positions
            });

            this._hasFX = true;

            //计算体积
            var result = (0, _polygon.interPolygon)(_extends({
                positions: positions,
                scene: this.viewer.scene,
                asyn: true
            }, this.options, {
                callback: function callback(interPolygonObj) {
                    if (_callback) _callback();

                    if (!_this3._hasFX) return;
                    _this3.showVolume(positions, interPolygonObj);
                }
            }));

            if (result._has3dtiles) {
                this.viewer.scene.globe.depthTestAgainstTerrain = false;
            } else {
                this.viewer.scene.globe.depthTestAgainstTerrain = true;
            }
        }
    }, {
        key: 'showVolume',
        value: function showVolume(positions, interPolygonObj) {
            var _this4 = this;

            this.interPolygonObj = (0, _polygon.updateVolumeByMinHeight)(interPolygonObj);
            this._maxHeight = this.interPolygonObj.maxHeight;
            this._minHeight = this.interPolygonObj.minHeight;
            this._jzmHeight = this.interPolygonObj.minHeight;

            var fillV = (0, _polygon.updateVolume)(this.interPolygonObj, this.height);

            // 显示基准面   
            var entityattr = (0, _Attr2.style2Entity)(this.polygonJzmStyle, {
                hierarchy: new Cesium.PolygonHierarchy(positions),
                height: new Cesium.CallbackProperty(function (time, result) {
                    return _this4.height;
                }, false)
            });
            delete entityattr.perPositionHeight;
            this.dataSource.entities.add({
                polygon: entityattr
            });

            // 显示立体边界
            delete this.polygonStyle.clampToGround;
            var entityattr = (0, _Attr2.style2Entity)(this.polygonStyle, {
                hierarchy: new Cesium.PolygonHierarchy(positions),
                height: new Cesium.CallbackProperty(function (time, result) {
                    return _this4.minHeight;
                }, false),
                extrudedHeight: new Cesium.CallbackProperty(function (time, result) {
                    return _this4.maxHeight;
                }, false),
                closeTop: false,
                closeBottom: true
            });
            this.dataSource.entities.add({
                polygon: entityattr
            });

            //显示各点的贴地高度文本
            if (this.heightLabel) this.showPointHeightLabel(positions, this.interPolygonObj.minHeight);

            //显示计算结果文本  
            if (!this.totalLable) {
                var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
                    horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    show: false
                });
                this.totalLable = this.dataSource.entities.add({
                    label: entityattr,
                    _noMousePosition: true,
                    attribute: {}
                });
            }
            this.totalLable.attribute.value = fillV;
            this.totalLable.showText = function (unit) {
                var fillV = this.attribute.value;
                var fillText = '';
                if (fillV.fillVolume > 0) {
                    fillText += '填方体积：' + formatNum(fillV.fillVolume) + "立方米\n";
                }
                if (fillV.digVolume > 0) {
                    fillText += "挖方体积：" + formatNum(fillV.digVolume) + "立方米\n";
                }
                fillText += '横切面积：' + (0, _util.formatArea)(fillV.totalArea);

                this.label.text = fillText;
                return fillText;
            };
            this.totalLable.showText();
            this.totalLable.position = (0, _point.centerOfMass)(positions, this.interPolygonObj.maxHeight); //求中心点 

            fillV.mtype = this.type;
            this.target.fire(_MarsClass.eventType.change, fillV);
            this.target.fire(_MarsClass.eventType.end, fillV);
        }

        //显示各点的贴地高度文本

    }, {
        key: 'showPointHeightLabel',
        value: function showPointHeightLabel(positions, minHeight) {
            var that = this;

            var arrLable = [];
            for (var i = 0; i < positions.length; i++) {
                var height = Math.max((0, _point.getSurfaceHeight)(this.viewer.scene, positions[i]), minHeight);

                var cartographic = Cesium.Cartographic.fromCartesian(positions[i]);
                var position = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height);

                //各点的文本
                var entityattr = (0, _Attr.style2Entity)(this.labelHeightStyle, {
                    horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                });
                var label = this.dataSource.entities.add({
                    position: position,
                    label: entityattr,
                    attribute: { value: height }
                });
                // label.attribute.value = height;
                label.showText = function (unit) {
                    var height = this.attribute.value;
                    var text = "海拔：" + height.toFixed(2) + "米";

                    if (that.offsetLabel) {
                        var offset = height - that.height;
                        if (offset > 0) text += "\n高度：" + offset.toFixed(2) + "米(面上)";else text += "\n高度：" + Math.abs(offset).toFixed(2) + "米(面下)";
                    }

                    this.label.text = text;
                    return text;
                };
                label.showText();
                arrLable.push(label);
            }
            this.arrLables = arrLable;
        }
    }, {
        key: 'selecteHeight',
        value: function selecteHeight(callback) {
            //拾取高度
            var that = this;
            this.drawControl.startDraw({
                type: "point",
                style: {
                    color: "#00fff2"
                },
                success: function success(entity) {
                    if (!entity.point) return;

                    var pos = entity._position._value;
                    var height = Cesium.Cartographic.fromCartesian(pos).height;
                    that.height = height;

                    that.drawControl.deleteEntity(entity);

                    if (callback) callback(height);
                }
            });
        }
    }, {
        key: 'clear',
        value: function clear() {
            delete this.interPolygonObj;
            delete this._maxHeight;
            delete this._minHeight;
            delete this._jzmHeight;

            delete this.totalLable;
            delete this.arrLables;

            _get(MeasureVolume.prototype.__proto__ || Object.getPrototypeOf(MeasureVolume.prototype), 'clear', this).call(this);
            this._hasFX = false;
        }
    }, {
        key: 'type',
        get: function get() {
            return "volume";
        }

        //面内的最高地表高度

    }, {
        key: 'polygonMaxHeight',
        get: function get() {
            if (this.interPolygonObj) return this.interPolygonObj.maxHeight;else return this.maxHeight;
        }

        //高度

    }, {
        key: 'height',
        get: function get() {
            return this._jzmHeight;
        },
        set: function set(val) {
            this._jzmHeight = val;
            if (val > this.maxHeight) this.maxHeight = val;
            if (val < this.minHeight) this.minHeight = val;

            if (!this._hasFX) return;

            var newFillV = (0, _polygon.updateVolume)(this.interPolygonObj, this.height);
            this.totalLable.attribute.value = newFillV;
            this.totalLable.showText();

            if (this.arrLables) {
                for (var i = 0; i < this.arrLables.length; i++) {
                    this.arrLables[i].showText();
                }
            }
            this.target.fire(_MarsClass.eventType.change, _extends({
                mtype: this.type
            }, newFillV));
        }
    }, {
        key: 'minHeight',
        get: function get() {
            return this._minHeight;
        },
        set: function set(val) {
            this._minHeight = val;

            if (!this._hasFX) return;

            if (this.interPolygonObj) {
                this.interPolygonObj.minHeight = val;
                this.interPolygonObj = (0, _polygon.updateVolumeByMinHeight)(this.interPolygonObj);
            }
            var newFillV = (0, _polygon.updateVolume)(this.interPolygonObj, this.height);
            this.totalLable.attribute.value = newFillV;
            this.totalLable.showText();

            this.target.fire(_MarsClass.eventType.change, _extends({
                mtype: this.type
            }, newFillV));
        }
    }, {
        key: 'maxHeight',
        get: function get() {
            return this._maxHeight;
        },
        set: function set(val) {
            this._maxHeight = val;
        }
    }]);

    return MeasureVolume;
}(_MeasureArea2.MeasureArea);

//格式化数值


function formatNum(num) {
    if (num > 10000) {
        return (num / 10000).toFixed(2) + "万";
    }
    return num.toFixed(2);
}

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomPlaneGeometry = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CustomPlaneGeometry = exports.CustomPlaneGeometry = function () {
    function CustomPlaneGeometry(options) {
        _classCallCheck(this, CustomPlaneGeometry);

        options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

        var vertexFormat = new Cesium.VertexFormat({
            'st': true,
            'position': true,
            'bitangent': false,
            'normal': false,
            'color': false,
            'tangent': false
        });
        this._pos_arr = Cesium.clone(options.pos_arr);
        this._vertexFormat = vertexFormat;
        var Rect = new Cesium.BoundingRectangle();
        this._SERectangle = Cesium.BoundingRectangle.fromPoints(this._pos_arr, Rect);
        this._workerName = 'createCustomPlaneGeometry';
    }

    /**
     * Computes the geometric representation of a plane, including its vertices, and a bounding sphere.
     *
     * @param {CustomPlaneGeometry} CustomPlaneGeometry A description of the plane.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */


    _createClass(CustomPlaneGeometry, [{
        key: 'createGeometry',
        value: function createGeometry(geometry) {
            var vertexFormat = geometry._vertexFormat;
            var SERectangle = geometry._SERectangle;
            var pos_arr = geometry._pos_arr;
            var attributes = new Cesium.GeometryAttributes();
            var indices;
            var positions;
            var poslen = pos_arr.length;
            if (Cesium.defined(vertexFormat.position)) {
                // 4 corner points.  Duplicated 3 times each for each incident edge/face.
                positions = new Float64Array(poslen * 3);

                for (var i = 0; i < poslen; i++) {
                    positions[i % poslen * 3 + 0] = pos_arr[i].x;
                    positions[i % poslen * 3 + 1] = pos_arr[i].y;
                    positions[i % poslen * 3 + 2] = pos_arr[i].z;
                }

                attributes.position = new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                    componentsPerAttribute: 3,
                    values: positions
                });

                if (Cesium.defined(vertexFormat.st)) {
                    var texCoords = new Float32Array(poslen * 2);
                    var oX = SERectangle.x - SERectangle.width;
                    var oY = SERectangle.y - SERectangle.height;
                    var oX = SERectangle.x;
                    var oY = SERectangle.y;
                    for (var i = 0; i < poslen; i++) {
                        texCoords[i * 2 + 0] = Math.abs((positions[i * 3 + 0] - oX) / SERectangle.width);
                        texCoords[i * 2 + 1] = Math.abs((positions[i * 3 + 1] - oY) / SERectangle.height);
                    }
                    attributes.st = new Cesium.GeometryAttribute({
                        componentDatatype: Cesium.ComponentDatatype.FLOAT,
                        componentsPerAttribute: 2,
                        values: texCoords
                    });
                }

                indices = new Uint16Array((poslen - 2) * 3);

                for (var i = 1; i < poslen - 1; i++) {
                    indices[(i - 1) * 3 + 0] = 0;
                    indices[(i - 1) * 3 + 1] = i;
                    indices[(i - 1) * 3 + 2] = i + 1;
                }
            }

            return new Cesium.Geometry({
                attributes: attributes,
                indices: indices,
                primitiveType: Cesium.PrimitiveType.TRIANGLE_FAN,
                boundingSphere: new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, Math.sqrt(2.0))
            });
        }
    }]);

    return CustomPlaneGeometry;
}();

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WellNoBottom = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var diffScratch = new Cesium.Cartesian3();

var WellNoBottom = exports.WellNoBottom = function () {
    function WellNoBottom(options) {
        _classCallCheck(this, WellNoBottom);

        options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

        var min = options.minimumArr;
        var max = options.maximumArr;
        Cesium.Check.defined('dingmian', max);
        Cesium.Check.defined('dimianmian', min);

        Cesium.Check.typeOf.number.greaterThanOrEquals('dingmian.length', max.length, 3);
        Cesium.Check.typeOf.number.greaterThanOrEquals('dimian.length', min.length, 3);

        var vertexFormat = new Cesium.VertexFormat({
            'st': true,
            'position': true,
            'bitangent': false,
            'normal': false,
            'color': false,
            'tangent': false
        });

        this._minimumArr = Cesium.clone(min);
        this._maximumArr = Cesium.clone(max);
        this._vertexFormat = vertexFormat;
        this._workerName = 'createWellNoBottom';
    }

    _createClass(WellNoBottom, [{
        key: 'createGeometry',
        value: function createGeometry(WellNoBottom, that) {
            var min = WellNoBottom._minimumArr;
            var max = WellNoBottom._maximumArr;
            var vertexFormat = WellNoBottom._vertexFormat;

            var attributes = new Cesium.GeometryAttributes();
            var indices;
            var positions;
            if (Cesium.defined(vertexFormat.position) && Cesium.defined(vertexFormat.st)) {
                if (Cesium.defined(vertexFormat.position)) {
                    // 8 corner points.  Duplicated 3 times each for each incident edge/face.
                    positions = new Float64Array(max.length * 4 * 3);

                    for (var i = 0; i < max.length; i++) {
                        if (i == max.length - 1) {
                            positions[i * 12 + 0] = max[i].x;
                            positions[i * 12 + 1] = max[i].y;
                            positions[i * 12 + 2] = max[i].z;

                            positions[i * 12 + 3] = min[i].x;
                            positions[i * 12 + 4] = min[i].y;
                            positions[i * 12 + 5] = min[i].z;

                            positions[i * 12 + 9] = min[0].x;
                            positions[i * 12 + 10] = min[0].y;
                            positions[i * 12 + 11] = min[0].z;

                            positions[i * 12 + 6] = max[0].x;
                            positions[i * 12 + 7] = max[0].y;
                            positions[i * 12 + 8] = max[0].z;

                            // positions.push(max[i].x,max[i].y,max[i].z);
                            // positions.push(min[i].x,min[i].y,min[i].z);
                            // positions.push(min[0].x,min[0].y,min[0].z);
                            // positions.push(max[0].x,max[0].y,max[0].z);
                        } else {
                            positions[i * 12 + 0] = max[i].x;
                            positions[i * 12 + 1] = max[i].y;
                            positions[i * 12 + 2] = max[i].z;

                            positions[i * 12 + 3] = min[i].x;
                            positions[i * 12 + 4] = min[i].y;
                            positions[i * 12 + 5] = min[i].z;

                            positions[i * 12 + 9] = min[i + 1].x;
                            positions[i * 12 + 10] = min[i + 1].y;
                            positions[i * 12 + 11] = min[i + 1].z;

                            positions[i * 12 + 6] = max[i + 1].x;
                            positions[i * 12 + 7] = max[i + 1].y;
                            positions[i * 12 + 8] = max[i + 1].z;

                            // positions.push(max[i].x,max[i].y,max[i].z);
                            // positions.push(min[i].x,min[i].y,min[i].z);
                            // positions.push(min[i+1].x,min[i+1].y,min[i+1].z);
                            // positions.push(max[i+1].x,max[i+1].y,max[i+1].z);
                        }
                    }

                    attributes.position = new Cesium.GeometryAttribute({
                        componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                        componentsPerAttribute: 3,
                        values: positions
                    });
                }

                var top_heights = that.top_heights;
                var maxHeight = that.maxHeight || 0;
                var splitNum = that.splitNum;

                if (Cesium.defined(vertexFormat.st)) {
                    var texCoords = new Float32Array(max.length * 4 * 2);
                    var maxLen = max.length;
                    for (var i = 0; i < max.length; i++) {
                        var currX = i / maxLen;
                        var currMaxHeight = top_heights && top_heights[i] || 0;
                        var currY = (currMaxHeight - that.targetHeight) / (maxHeight - that.targetHeight);
                        var nextIndex = i + 1;
                        // if (i == max.length - 1) {
                        //     nextIndex = 0;
                        // }
                        var nextMaxHeight = top_heights && top_heights[nextIndex] || 0;
                        var nextX = nextIndex / maxLen;
                        var nextY = (nextMaxHeight - that.targetHeight) / (maxHeight - that.targetHeight);

                        texCoords[i * 8 + 0] = currX;
                        texCoords[i * 8 + 1] = currY - 0.0;
                        texCoords[i * 8 + 2] = currX;
                        texCoords[i * 8 + 3] = currY - currY;
                        texCoords[i * 8 + 4] = nextX;
                        texCoords[i * 8 + 5] = nextY - 0.0;
                        texCoords[i * 8 + 6] = nextX;
                        texCoords[i * 8 + 7] = nextY - nextY;

                        // texCoords[i*8 + 0]  = 0.0;
                        // texCoords[i*8 + 1]  = 0.0;
                        // texCoords[i*8 + 2]  = 0.0;
                        // texCoords[i*8 + 3]  = 1.0;
                        // texCoords[i*8 + 4]  = 1.0;
                        // texCoords[i*8 + 5]  = 0.0;
                        // texCoords[i*8 + 6]  = 1.0;
                        // texCoords[i*8 + 7]  = 1.0;
                    }

                    attributes.st = new Cesium.GeometryAttribute({
                        componentDatatype: Cesium.ComponentDatatype.FLOAT,
                        componentsPerAttribute: 2,
                        values: texCoords
                    });
                }

                // 12 triangles:  6 faces, 2 triangles each.
                indices = new Uint16Array(max.length * 2 * 3);
                var min_pos = new Cesium.Cartesian3(9999999999999, 9999999999999, 9999999999999);
                var max_pos = new Cesium.Cartesian3(-9999999999999, -9999999999999, -9999999999999);
                for (var i = 0; i < max.length; i++) {
                    indices[i * 6 + 0] = 4 * i + 0;
                    indices[i * 6 + 1] = 4 * i + 1;
                    indices[i * 6 + 2] = 4 * i + 2;
                    indices[i * 6 + 3] = 4 * i + 1;
                    indices[i * 6 + 4] = 4 * i + 2;
                    indices[i * 6 + 5] = 4 * i + 3;

                    if (max[i].x >= max_pos.x && max[i].y >= max_pos.y && max[i].z >= max_pos.z) {
                        max_pos = max[i];
                    }
                    if (min[i].x <= min_pos.x && min[i].y <= min_pos.y && min[i].z <= min_pos.z) {
                        min_pos = min[i];
                    }
                }
            }
            var diff = Cesium.Cartesian3.subtract(max_pos, min_pos, diffScratch);
            var radius = Cesium.Cartesian3.magnitude(diff) * 0.5;

            return new Cesium.Geometry({
                attributes: attributes,
                indices: indices,
                primitiveType: Cesium.PrimitiveType.TRIANGLES,
                boundingSphere: new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, radius)
            });
        }
    }]);

    return WellNoBottom;
}();

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RectangularSensorGraphics = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function RectangularSensorGraphics(options) {
    this._show = undefined;
    this._radius = undefined;
    this._xHalfAngle = undefined;
    this._yHalfAngle = undefined;
    this._lineColor = undefined;
    this._showSectorLines = undefined;
    this._showSectorSegmentLines = undefined;
    this._showLateralSurfaces = undefined;
    this._material = undefined;
    this._showDomeSurfaces = undefined;
    this._showDomeLines = undefined;
    this._showIntersection = undefined;
    this._intersectionColor = undefined;
    this._intersectionWidth = undefined;
    this._showThroughEllipsoid = undefined;
    this._gaze = undefined;
    this._showScanPlane = undefined;
    this._scanPlaneColor = undefined;
    this._scanPlaneMode = undefined;
    this._scanPlaneRate = undefined;
    this._definitionChanged = new Cesium.Event();
    this.merge(Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT));
}

Object.defineProperties(RectangularSensorGraphics.prototype, {
    definitionChanged: {
        get: function get() {
            return this._definitionChanged;
        }
    },

    show: Cesium.createPropertyDescriptor('show'),
    radius: Cesium.createPropertyDescriptor('radius'),
    xHalfAngle: Cesium.createPropertyDescriptor('xHalfAngle'),
    yHalfAngle: Cesium.createPropertyDescriptor('yHalfAngle'),
    lineColor: Cesium.createPropertyDescriptor('lineColor'),
    showSectorLines: Cesium.createPropertyDescriptor('showSectorLines'),
    showSectorSegmentLines: Cesium.createPropertyDescriptor('showSectorSegmentLines'),
    showLateralSurfaces: Cesium.createPropertyDescriptor('showLateralSurfaces'),
    material: Cesium.createMaterialPropertyDescriptor('material'),
    showDomeSurfaces: Cesium.createPropertyDescriptor('showDomeSurfaces'),
    showDomeLines: Cesium.createPropertyDescriptor('showDomeLines '),
    showIntersection: Cesium.createPropertyDescriptor('showIntersection'),
    intersectionColor: Cesium.createPropertyDescriptor('intersectionColor'),
    intersectionWidth: Cesium.createPropertyDescriptor('intersectionWidth'),
    showThroughEllipsoid: Cesium.createPropertyDescriptor('showThroughEllipsoid'),
    gaze: Cesium.createPropertyDescriptor('gaze'),
    showScanPlane: Cesium.createPropertyDescriptor('showScanPlane'),
    scanPlaneColor: Cesium.createPropertyDescriptor('scanPlaneColor'),
    scanPlaneMode: Cesium.createPropertyDescriptor('scanPlaneMode'),
    scanPlaneRate: Cesium.createPropertyDescriptor('scanPlaneRate')
});

RectangularSensorGraphics.prototype.clone = function (result) {
    if (!Cesium.defined(result)) {
        result = new RectangularSensorGraphics();
    }

    result.show = this.show;
    result.radius = this.radius;
    result.xHalfAngle = this.xHalfAngle;
    result.yHalfAngle = this.yHalfAngle;
    result.lineColor = this.lineColor;
    result.showSectorLines = this.showSectorLines;
    result.showSectorSegmentLines = this.showSectorSegmentLines;
    result.showLateralSurfaces = this.showLateralSurfaces;
    result.material = this.material;
    result.showDomeSurfaces = this.showDomeSurfaces;
    result.showDomeLines = this.showDomeLines;
    result.showIntersection = this.showIntersection;
    result.intersectionColor = this.intersectionColor;
    result.intersectionWidth = this.intersectionWidth;
    result.showThroughEllipsoid = this.showThroughEllipsoid;
    result.gaze = this.gaze;
    result.showScanPlane = this.showScanPlane;
    result.scanPlaneColor = this.scanPlaneColor;
    result.scanPlaneMode = this.scanPlaneMode;
    result.scanPlaneRate = this.scanPlaneRate;

    return result;
};

RectangularSensorGraphics.prototype.merge = function (source) {
    if (!Cesium.defined(source)) {
        throw new Cesium.DeveloperError('source is required.');
    }
    this.slice = Cesium.defaultValue(this.slice, source.slice);
    this.show = Cesium.defaultValue(this.show, source.show);
    this.radius = Cesium.defaultValue(this.radius, source.radius);
    this.xHalfAngle = Cesium.defaultValue(this.xHalfAngle, source.xHalfAngle);
    this.yHalfAngle = Cesium.defaultValue(this.yHalfAngle, source.yHalfAngle);
    this.lineColor = Cesium.defaultValue(this.lineColor, source.lineColor);
    this.showSectorLines = Cesium.defaultValue(this.showSectorLines, source.showSectorLines);
    this.showSectorSegmentLines = Cesium.defaultValue(this.showSectorSegmentLines, source.showSectorSegmentLines);
    this.showLateralSurfaces = Cesium.defaultValue(this.showLateralSurfaces, source.showLateralSurfaces);
    this.material = Cesium.defaultValue(this.material, source.material);
    this.showDomeSurfaces = Cesium.defaultValue(this.showDomeSurfaces, source.showDomeSurfaces);
    this.showDomeLines = Cesium.defaultValue(this.showDomeLines, source.showDomeLines);
    this.showIntersection = Cesium.defaultValue(this.showIntersection, source.showIntersection);
    this.intersectionColor = Cesium.defaultValue(this.intersectionColor, source.intersectionColor);
    this.intersectionWidth = Cesium.defaultValue(this.intersectionWidth, source.intersectionWidth);
    this.showThroughEllipsoid = Cesium.defaultValue(this.showThroughEllipsoid, source.showThroughEllipsoid);
    this.gaze = Cesium.defaultValue(this.gaze, source.gaze);
    this.showScanPlane = Cesium.defaultValue(this.showScanPlane, source.showScanPlane);
    this.scanPlaneColor = Cesium.defaultValue(this.scanPlaneColor, source.scanPlaneColor);
    this.scanPlaneMode = Cesium.defaultValue(this.scanPlaneMode, source.scanPlaneMode);
    this.scanPlaneRate = Cesium.defaultValue(this.scanPlaneRate, source.scanPlaneRate);
};

exports.RectangularSensorGraphics = RectangularSensorGraphics;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TilesClipPlan = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//模型剖切(平面)类
var TilesClipPlan = exports.TilesClipPlan = function () {
    //========== 构造方法 ========== 
    function TilesClipPlan(options, oldparam) {
        _classCallCheck(this, TilesClipPlan);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        if (oldparam) {
            oldparam.tileset = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        this.options = options;

        if (options.tileset) this._tileset = options.tileset;else if (options.entity) this._tileset = options.entity;

        if (options.type) {
            this.type = options.type;
        }
        if (options.positions) {
            this._clipOutSide = Cesium.defaultValue(options.clipOutSide, false);
            this.positions = options.positions;
        }
        if (Cesium.defined(options.distance)) {
            this.distance = options.distance;
        }
        if (Cesium.defined(options.height)) {
            this.distance = options.height;
        }
    }

    //========== 对外属性 ========== 


    _createClass(TilesClipPlan, [{
        key: "clipByType",


        //========== 方法 ========== 


        //根据类型 创建裁剪面
        value: function clipByType(type, opts) {
            //裁剪面
            var planes;
            switch (type) {
                case TilesClipPlan.Type.Z:
                    //水平切底部 
                    planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 0, 1), 1)];
                    break;
                case TilesClipPlan.Type.ZR:
                    //水平切顶部 
                    planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 0, -1), 1)];
                    break;

                case TilesClipPlan.Type.X:
                    //东西方向切1 
                    planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(1, 0, 0), 1)];
                    break;
                case TilesClipPlan.Type.XR:
                    //东西方向切2 
                    planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(-1, 0, 0), 1)];
                    break;

                case TilesClipPlan.Type.Y:
                    //南北方向切1 
                    planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 1, 0), 1)];
                    break;
                case TilesClipPlan.Type.YR:
                    //南北方向切2 
                    planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, -1, 0), 1)];
                    break;
            }

            this.setPlanes(planes, opts);
        }

        //更新裁剪距离(全部)

    }, {
        key: "updateAllDistance",
        value: function updateAllDistance(val) {
            if (this.clippingPlanes == null) return;

            for (var i = 0; i < this.clippingPlanes.length; i++) {
                var plane = this.clippingPlanes.get(i);
                plane.distance = val;
            }
        }

        //更新裁剪距离

    }, {
        key: "updateDistance",
        value: function updateDistance(val) {
            if (this.clippingPlanes == null) return;

            var len = this.clippingPlanes.length;
            if (len == 0) return;

            var plane = this.clippingPlanes.get(len - 1);
            plane.distance = val;
        }

        //根据坐标 创建裁剪面

    }, {
        key: "clipByPoints",
        value: function clipByPoints(points, opts) {
            opts = opts || {};
            opts.unionClippingRegions = Cesium.defaultValue(opts.unionClippingRegions, false); //true时外切


            if (points.length < 2) return;

            var planes = [];
            if (points.length == 2) {
                //线
                planes = [this._createPlaneByLine(points[0], points[1])];
            } else {
                //面

                //是否顺时针 
                var startAngle = (0, _util.getAngle)(points[0], points[1]);
                var endAngle = (0, _util.getAngle)(points[0], points[2]);
                var direction = startAngle < endAngle;
                if (opts.unionClippingRegions) direction = !direction;

                var plan;
                for (var i = 0, len = points.length; i < len; ++i) {
                    var nextIndex = (i + 1) % len;

                    if (direction) plan = this._createPlaneByLine(points[nextIndex], points[i]);else plan = this._createPlaneByLine(points[i], points[nextIndex]);

                    planes.push(plan);
                }

                var clipHeight = Cesium.defaultValue(opts.height, this.distance);
                if (Cesium.defined(clipHeight)) {
                    plan = new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 0, -1), clipHeight); //底面
                    planes.push(plan);
                }
            }

            this.setPlanes(planes, opts);
        }
    }, {
        key: "_createPlaneByLine",
        value: function _createPlaneByLine(p1, p2) {
            // 将仅包含经纬度信息的p1,p2，转换为相应坐标系的cartesian3对象
            var p1C3 = Cesium.Matrix4.multiplyByPoint(this.inverseTransform, p1, new Cesium.Cartesian3(0, 0, 0));
            var p2C3 = Cesium.Matrix4.multiplyByPoint(this.inverseTransform, p2, new Cesium.Cartesian3(0, 0, 0));

            // 定义一个垂直向上的向量up
            var up = new Cesium.Cartesian3(0, 0, 10);
            //  right 实际上就是由p1指向p2的向量
            var right = Cesium.Cartesian3.subtract(p2C3, p1C3, new Cesium.Cartesian3());

            // 计算normal， right叉乘up，得到平面法向量，这个法向量指向right的右侧
            var normal = Cesium.Cartesian3.cross(right, up, new Cesium.Cartesian3());
            normal = Cesium.Cartesian3.normalize(normal, normal);

            //由于已经获得了法向量和过平面的一点，因此可以直接构造Plane,并进一步构造ClippingPlane
            var planeTmp = Cesium.Plane.fromPointNormal(p1C3, normal);
            return Cesium.ClippingPlane.fromPlane(planeTmp);
        }
    }, {
        key: "getInverseTransform",
        value: function getInverseTransform() {
            if (!this._inverseTransform) {
                var transform = void 0;
                var tmp = this._tileset.root.transform;
                if (tmp && tmp.equals(Cesium.Matrix4.IDENTITY) || !tmp) {
                    // 如果root.transform不存在，则3DTiles的原点变成了boundingSphere.center
                    transform = Cesium.Transforms.eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
                } else {
                    transform = Cesium.Matrix4.fromArray(this._tileset.root.transform);
                }
                this._inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
            }
            return this._inverseTransform;
        }
    }, {
        key: "setPlanes",
        value: function setPlanes(planes, opts) {
            opts = opts || {};

            this.clear();
            if (!planes) return;

            var clippingPlanes = new Cesium.ClippingPlaneCollection({
                // modelMatrix : Cesium.Transforms.eastNorthUpToFixedFrame(position),
                planes: planes,
                edgeWidth: Cesium.defaultValue(opts.edgeWidth, 0.0),
                edgeColor: Cesium.defaultValue(opts.edgeColor, Cesium.Color.WHITE),
                unionClippingRegions: Cesium.defaultValue(opts.unionClippingRegions, false)
            });
            this.clippingPlanes = clippingPlanes;
            this._tileset.clippingPlanes = clippingPlanes;
        }

        //清除裁剪面

    }, {
        key: "clear",
        value: function clear() {
            if (this._tileset.clippingPlanes) {
                this._tileset.clippingPlanes.enabled = false;
                this._tileset.clippingPlanes.removeAll();
                // if (!this._tileset.clippingPlanes.isDestroyed())
                //     this._tileset.clippingPlanes.destroy();
                this._tileset.clippingPlanes = undefined;
            }

            if (this.clippingPlanes) {
                delete this.clippingPlanes;
            }
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            this.clear();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "tileset",
        get: function get() {
            return this._tileset;
        },
        set: function set(val) {
            this._tileset = val;
            this._inverseTransform = null;
        }

        //裁剪面

    }, {
        key: "planes",
        get: function get() {
            return this.clippingPlanes;
        }
    }, {
        key: "inverseTransform",
        get: function get() {
            return this.getInverseTransform();
        }

        //裁剪距离 

    }, {
        key: "distance",
        get: function get() {
            return this._distance;
        },
        set: function set(val) {
            this._distance = val;
            this.updateDistance(val);
        }

        //裁剪类型

    }, {
        key: "type",
        get: function get() {
            return this._type;
        },
        set: function set(val) {
            this._type = val;

            this.clipByType(val);
        }

        //裁剪类型

    }, {
        key: "positions",
        get: function get() {
            return this._positions;
        },
        set: function set(val) {
            this._positions = val;

            this.clipByPoints(val, { unionClippingRegions: this._clipOutSide });
        }
    }]);

    return TilesClipPlan;
}();

/**
* 裁剪模型 类型 枚举
*@enum {Number}
*/


TilesClipPlan.Type = {
    /** z水平面,水平切底部 */
    Z: 1,
    /** z水平面，水平切顶部 */
    ZR: 2,
    /** x垂直面,水平切底部 */
    X: 3,
    /** x垂直面,东西方向切 */
    XR: 4,
    /** y垂直面, 南北方向切 */
    Y: 5,
    /** y垂直面，南北方向切*/
    YR: 6
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DivPoint = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.style2Entity = style2Entity;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _zepto = __webpack_require__(8);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//div点 类
var DivPoint = exports.DivPoint = function () {
    //========== 构造方法 ========== 
    function DivPoint(viewer, options) {
        _classCallCheck(this, DivPoint);

        this.viewer = viewer;
        this.options = options;

        this.position = options.position;

        //兼容历史写法
        if (options.visibleDistanceMin || options.visibleDistanceMax) {
            options.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(options.visibleDistanceMin || 0, options.visibleDistanceMax || 100000);
        }

        this.heightReference = Cesium.defaultValue(options.heightReference, Cesium.HeightReference.NONE);
        if (options.clampToGround) {
            this.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
        }

        this.distanceDisplayCondition = options.distanceDisplayCondition; //按视距距离显示
        this.scaleByDistance = this.options.scaleByDistance;
        this.horizontalOrigin = this.options.horizontalOrigin;
        this.verticalOrigin = this.options.verticalOrigin;

        this._depthTest = Cesium.defaultValue(options.depthTest, true);
        this.css_transform_origin = Cesium.defaultValue(this.options.css_transform_origin, 'left bottom 0');

        //添加html 
        if (options.html) {
            this._dom = (0, _zepto.zepto)('<div>' + options.html + '</div>');

            if (Cesium.defaultValue(options.oldver, false)) {
                //兼容老版本,但不支持html动态修改
                this._dom = (0, _zepto.zepto)(options.html);
            }

            this._dom.css({
                position: 'absolute',
                left: '0',
                top: '0'
            });
            this._dom.appendTo("#" + viewer._container.id);
        } else if (options.dom) {
            this._dom = (0, _zepto.zepto)(options.dom);
        }

        this.visible = Cesium.defaultValue(options.visible, true);

        var stopPropagation = Cesium.defaultValue(options.stopPropagation, true);

        var that = this;
        var hasEvent = false;
        if (options.click || options.popup) {
            hasEvent = true;
            this._dom.click(function (e) {
                if (stopPropagation) {
                    if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
                }

                if (options.popup) viewer.mars.popup.show(options, that.position);else viewer.mars.popup.close();

                if (options.click) options.click(options, that, e);
            });
        }
        if (options.tooltip) {
            hasEvent = true;
            this._dom.mousemove(function (e) {
                //移入
                if (stopPropagation) {
                    if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
                }

                viewer.mars.tooltip.show(options, that.position);
            });
            this._dom.mouseout(function (e) {
                //移出
                if (stopPropagation) {
                    if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
                }
                viewer.mars.tooltip.close();
            });
        }

        if (!hasEvent) {
            /*加上这个css后鼠标可以穿透，但是无法触发单击等鼠标事件*/
            this._dom.css({
                'pointer-events': 'none'
            });
        }

        //移动事件
        viewer.scene.postRender.addEventListener(this.updateViewPoint, this);
    }

    //========== 对外属性 ==========  


    _createClass(DivPoint, [{
        key: 'updateViewPoint',


        //========== 方法 ========== 
        value: function updateViewPoint() {
            if (!this._visible) return false;

            var scene = this.viewer.scene;
            var camera = this.viewer.camera;

            var _position;
            if (this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
                _position = (0, _point.setPositionSurfaceHeight)(this.viewer, (0, _point.getPositionValue)(this.position));
            } else if (this.heightReference == Cesium.HeightReference.RELATIVE_TO_GROUND) {
                _position = (0, _point.setPositionSurfaceHeight)(this.viewer, (0, _point.getPositionValue)(this.position), { relativeHeight: true });
            } else {
                _position = (0, _point.getPositionValue)(this.position);
            }

            if (!Cesium.defined(_position)) {
                this.close();
                return false;
            }

            //如果视角和位置都没有变化，直接返回
            var _thiscache = _position.x + '=' + _position.y + '-' + _position.z + '-' + camera.positionWC.x + '=' + camera.positionWC.y + '-' + camera.positionWC.z + '-' + camera.heading + '-' + camera.pitch + '-' + camera.roll;
            if (_thiscache == this._camera_cache) {
                return true;
            }
            this._camera_cache = _thiscache;
            //如果视角和位置都没有变化，直接返回


            var point = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, _position);

            var camera_distance;
            if (scene.mode === Cesium.SceneMode.SCENE3D) camera_distance = Cesium.Cartesian3.distance(_position, camera.positionWC);else camera_distance = camera.positionCartographic.height;

            if (point == null || this.distanceDisplayCondition && (this.distanceDisplayCondition.near > camera_distance || this.distanceDisplayCondition.far < camera_distance)) {
                if (this._dom.css("display") == "block") {
                    //如果node是显示则隐藏 
                    this.close();
                }
                return false;
            }

            //判断是否在球的背面
            if (this._depthTest && scene.mode === Cesium.SceneMode.SCENE3D) {
                //三维模式下
                var occluder = new Cesium.EllipsoidalOccluder(scene.globe.ellipsoid, scene.camera.positionWC);
                var visible = occluder.isPointVisible(_position); //地球椭球体背面判断处理
                //visible为true说明点在球的正面，否则点在球的背面。 
                //需要注意的是不能用这种方法判断点的可见性，如果球放的比较大，点跑到屏幕外面，它返回的依然为true
                if (!visible) {
                    if (this._dom.css("display") == "block") {
                        //如果node是显示则隐藏 
                        this.close();
                    }
                    return false;
                }

                //地形和模型遮挡时的检测处理
                // if (scene.globe.depthTestAgainstTerrain) {
                //     var testPosition = scene.pickPosition(point) 
                //     if (testPosition && Math.abs(_position.x - testPosition.x) > 10
                //         && Math.abs(_position.y - testPosition.y) > 10
                //         && Math.abs(_position.z - testPosition.z) > 10) {
                //         if (this._dom.css("display") == "block") {//如果node是显示则隐藏 
                //             this.close();
                //         }
                //         return false;
                //     }
                // }
            }
            //判断是否在球的背面

            if (this._dom.css("display") != "block") {
                //如果node是隐藏的则显示node元素 
                this._camera_cache = null;
                this._dom.show();
            }

            //求xy位置
            var height = this._dom.height(); //需要是显示状态，才有值
            var width = this._dom.width();

            var x;
            var y;
            if (this.options.anchor) {
                x = point.x + this.options.anchor[0];
                y = point.y - height + this.options.anchor[1];
            } else {
                switch (this.horizontalOrigin) {
                    default:
                    case "LEFT":
                    case Cesium.HorizontalOrigin.LEFT:
                        x = point.x;
                        break;
                    case "CENTER":
                    case Cesium.HorizontalOrigin.CENTER:
                        x = point.x - width / 2;
                        break;
                    case "RIGHT":
                    case Cesium.HorizontalOrigin.RIGHT:
                        x = point.x - width;
                        break;
                }
                switch (this.verticalOrigin) {
                    case "TOP":
                    case Cesium.VerticalOrigin.TOP:
                        y = point.y;
                        break;
                    case "CENTER":
                    case Cesium.VerticalOrigin.CENTER:
                        y = point.y - height / 2;
                        break;
                    default:
                    case "BOTTOM":
                    case Cesium.VerticalOrigin.BOTTOM:
                        y = point.y - height;
                        break;
                }
            }

            //求缩放比例
            var scale = 1;
            if (this.scaleByDistance) {
                var sc = this.scaleByDistance; //Cesium.NearFarScalar
                if (camera_distance <= sc.near) {
                    scale = sc.nearValue;
                } else if (camera_distance > sc.near && camera_distance < sc.far) {
                    // near 10000, nearValue  1.0,, far 100000, farValue  0.1 
                    scale = sc.nearValue + (sc.farValue - sc.nearValue) * (camera_distance - sc.near) / (sc.far - sc.near);
                } else {
                    scale = sc.farValue;
                }
            }

            var css_transform = 'matrix(' + scale + ',0,0,' + scale + ',' + x + ',' + y + ')';

            this._dom.css({
                'transform': css_transform,
                'transform-origin': this.css_transform_origin,
                '-ms-transform': css_transform, /* IE 9 */
                '-ms-transform-origin': this.css_transform_origin,
                '-webkit-transform': css_transform, /* Safari 和 Chrome */
                '-webkit-transform-origin': this.css_transform_origin,
                '-moz-transform': css_transform, /* Firefox */
                '-moz-transform-origin': this.css_transform_origin,
                '-o-transform': css_transform, /* Opera */
                '-o-transform-origin': this.css_transform_origin
            });

            if (this.options.postRender) {
                //回调方法
                this.options.postRender({
                    x: x,
                    y: y,
                    height: height,
                    width: width,
                    distance: camera_distance
                });
            }
        }
    }, {
        key: 'setVisible',
        value: function setVisible(val) {
            this._visible = val;
            if (!this._dom) return;
            if (val) this._dom.show();else this.close();
        }
    }, {
        key: 'showPopup',
        value: function showPopup() {
            if (this.options.popup) this.viewer.mars.popup.show(this.options, this.position);
        }
    }, {
        key: 'closePopup',
        value: function closePopup() {
            this.viewer.mars.popup.close();
        }
    }, {
        key: 'close',
        value: function close() {
            this._dom.hide();
            this._camera_cache = null;
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.viewer.scene.postRender.removeEventListener(this.updateViewPoint, this);
            this._dom.remove();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: 'dom',
        get: function get() {
            return this._dom;
        }

        //是否显示

    }, {
        key: 'visible',
        get: function get() {
            return this._visible;
        },
        set: function set(val) {
            this._camera_cache = null;
            this._visible = val;
            this.setVisible(val);
        }
    }, {
        key: 'enable',
        set: function set(value) {
            if (value) {
                this._dom.css({
                    'pointer-events': 'all'
                });
            } else {
                this._dom.css({
                    'pointer-events': 'none'
                });
            }
        }

        //是否打开深度判断（true时判断是否在球背面）

    }, {
        key: 'depthTest',
        get: function get() {
            return this._depthTest;
        },
        set: function set(value) {
            this._camera_cache = null;
            this._depthTest = value;
        }
    }, {
        key: 'clampToGround',
        get: function get() {
            return this.options.clampToGround;
        },
        set: function set(value) {
            this.options.clampToGround = value;
            if (value) this.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else this.heightReference = Cesium.HeightReference.NONE;
        }
    }, {
        key: 'html',
        get: function get() {
            return this._dom.html();
        },
        set: function set(value) {
            this._camera_cache = null;
            this._dom.html(value);
        }
    }, {
        key: 'popup',
        get: function get() {
            return this.options.popup;
        },
        set: function set(value) {
            this._dom.css({
                'pointer-events': 'all'
            });

            var that = this;
            var options = this.options;

            options.popup = value;

            this._dom.click(function (e) {
                if (options.popup) that.viewer.mars.popup.show(options, that.position);
                if (options.click) options.click(options, that, e);
            });
        }
    }, {
        key: 'tooltip',
        get: function get() {
            return this.options.tooltip;
        },
        set: function set(value) {
            this._dom.css({
                'pointer-events': 'all'
            });

            var that = this;
            var options = this.options;

            options.tooltip = value;

            this._dom.mousemove(function (e) {
                //移入
                that.viewer.mars.tooltip.show(options, that.position);
            });
            this._dom.mouseout(function (e) {
                //移出
                that.viewer.mars.tooltip.close();
            });
        }
    }]);

    return DivPoint;
}();

//属性赋值到entity


function style2Entity(style) {
    style = style || {};

    var entityattr = {};

    //Style赋值值Entity
    for (var key in style) {
        var value = style[key];
        switch (key) {
            default:
                //直接赋值
                entityattr[key] = value;
                break;
            case "scaleByDistance_near": //跳过扩展其他属性的参数
            case "scaleByDistance_nearValue":
            case "scaleByDistance_far":
            case "scaleByDistance_farValue":
            case "distanceDisplayCondition_far":
            case "distanceDisplayCondition_near":
                break;
            case "scaleByDistance":
                //是否按视距缩放
                if (value) {
                    entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(Cesium.defaultValue(style.scaleByDistance_near, 1000)), Number(Cesium.defaultValue(style.scaleByDistance_nearValue, 1.0)), Number(Cesium.defaultValue(style.scaleByDistance_far, 1000000)), Number(Cesium.defaultValue(style.scaleByDistance_farValue, 0.1)));
                } else {
                    entityattr.scaleByDistance = undefined;
                }
                break;
            case "distanceDisplayCondition":
                //是否按视距显示
                if (value) {
                    if (value instanceof Cesium.DistanceDisplayCondition) {
                        entityattr.distanceDisplayCondition = value;
                    } else {
                        entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
                    }
                } else {
                    entityattr.distanceDisplayCondition = undefined;
                }
                break;
            case "clampToGround":
                //贴地
                if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
                break;
            case "heightReference":
                switch (value) {
                    case "NONE":
                        entityattr.heightReference = Cesium.HeightReference.NONE;
                        break;
                    case "CLAMP_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                        break;
                    case "RELATIVE_TO_GROUND":
                        entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                        break;
                    default:
                        entityattr.heightReference = value;
                        break;
                }
                break;
            case "horizontalOrigin":
                switch (value) {
                    case "CENTER":
                        entityattr.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
                        break;
                    case "LEFT":
                        entityattr.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
                        break;
                    case "RIGHT":
                        entityattr.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
                        break;
                    default:
                        entityattr.horizontalOrigin = value;
                        break;
                }
                break;
            case "verticalOrigin":
                switch (value) {
                    case "CENTER":
                        entityattr.verticalOrigin = Cesium.VerticalOrigin.CENTER;
                        break;
                    case "TOP":
                        entityattr.verticalOrigin = Cesium.VerticalOrigin.TOP;
                        break;
                    case "BOTTOM":
                        entityattr.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
                        break;
                    default:
                        entityattr.verticalOrigin = value;
                        break;
                }
                break;
        }
    }

    return entityattr;
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawPBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _MarsClass2 = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPBase = exports.DrawPBase = function (_MarsClass) {
    _inherits(DrawPBase, _MarsClass);

    //========== 构造方法 ========== 
    function DrawPBase(opts) {
        _classCallCheck(this, DrawPBase);

        var _this = _possibleConstructorReturn(this, (DrawPBase.__proto__ || Object.getPrototypeOf(DrawPBase)).call(this, opts));

        _this.viewer = opts.viewer;
        _this.primitives = opts.primitives;
        _this.dataSource = opts.dataSource; //编辑类中使用的dataSource

        _this.tooltip = opts.tooltip || new Tooltip(_this.viewer.container);

        _this._positions_draw = null; //坐标位置相关 
        _this.editClass = null; //编辑对象   
        _this.attrClass = null; //对应的属性控制静态类
        return _this;
    }

    _createClass(DrawPBase, [{
        key: 'fire',
        value: function fire(type, data, propagate) {
            if (this._fire) this._fire(type, data, propagate);
        }
    }, {
        key: 'formatNum',
        value: function formatNum(num, digits) {
            return (0, _point.formatNum)(num, digits);
        }
    }, {
        key: 'enableControl',
        value: function enableControl(value) {
            if (this.viewer.mars.popup) this.viewer.mars.popup.enable = value;
            if (this.viewer.mars.tooltip) this.viewer.mars.tooltip.enable = value;
        }
        //激活绘制

    }, {
        key: 'activate',
        value: function activate(attribute, drawOkCallback) {
            if (this._enabled) {
                return this;
            }
            this._enabled = true;
            this.drawOkCallback = drawOkCallback;

            if (attribute instanceof Cesium.Entity) {
                this.reCreateFeature(attribute);
            } else {
                this.createFeature(attribute);
            }

            this.entity.inProgress = true;

            this.setCursor(true);
            this.enableControl(false);
            this.bindEvent();

            this.fire(_MarsClass2.eventType.drawStart, { drawtype: this.type, entity: this.entity });

            return this.entity;
        }
        //释放绘制

    }, {
        key: 'disable',
        value: function disable(hasWB) {
            if (!this._enabled) {
                return this;
            }
            this._enabled = false;

            this.setCursor(false);
            this.enableControl(true);

            if (hasWB && this.entity.inProgress) {
                //外部释放时，尚未结束的标绘移除。       
                if (this.primitives.contains(this.entity)) this.primitives.remove(this.entity);

                this.destroyHandler();
                this.tooltip.setVisible(false);
            } else {
                var entity = this.entity;
                this.entity.inProgress = false;
                this.finish();

                this.destroyHandler();
                this.tooltip.setVisible(false);
                this._positions_draw = null;
                this.entity = null;

                if (this.drawOkCallback) {
                    this.drawOkCallback(entity);
                    delete this.drawOkCallback;
                }
                this.fire(_MarsClass2.eventType.drawCreated, { drawtype: this.type, entity: entity });
            }

            return this;
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.disable();
            _get(DrawPBase.prototype.__proto__ || Object.getPrototypeOf(DrawPBase.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'createFeature',
        value: function createFeature(attribute) {}
    }, {
        key: 'reCreateFeature',
        value: function reCreateFeature(entity) {}
        //============= 事件相关 ============= 

    }, {
        key: 'getHandler',
        value: function getHandler() {
            if (!this.handler || this.handler.isDestroyed()) {
                this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
            }
            return this.handler;
        }
    }, {
        key: 'destroyHandler',
        value: function destroyHandler() {
            this.handler && this.handler.destroy();
            this.handler = undefined;
        }
    }, {
        key: 'setCursor',
        value: function setCursor(val) {
            this.viewer._container.style.cursor = val ? 'crosshair' : '';
        }
        //绑定鼠标事件

    }, {
        key: 'bindEvent',
        value: function bindEvent() {}
        //=============  ============= 
        //坐标位置相关 

    }, {
        key: 'getDrawPosition',
        value: function getDrawPosition() {
            return this._positions_draw;
        }
        //获取编辑对象   

    }, {
        key: 'getEditClass',
        value: function getEditClass(entity) {
            if (this.editClass == null) return null;

            var _edit = new this.editClass(entity, this.viewer, this.dataSource);
            if (this._minPointNum != null) _edit._minPointNum = this._minPointNum;
            if (this._maxPointNum != null) _edit._maxPointNum = this._maxPointNum;

            _edit._fire = this._fire;
            _edit.tooltip = this.tooltip;

            return _edit;
        }
        //更新坐标后调用下，更新相关属性，子类使用

    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing(isLoad) {}
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {}
        //通用方法

    }, {
        key: 'getCoordinates',
        value: function getCoordinates(entity) {
            return this.attrClass.getCoordinates(entity);
        }
    }, {
        key: 'getPositions',
        value: function getPositions(entity) {
            return this.attrClass.getPositions(entity);
        }
    }, {
        key: 'toGeoJSON',
        value: function toGeoJSON(entity) {
            return this.attrClass.toGeoJSON(entity);
        }
        //属性转entity

    }, {
        key: 'attributeToEntity',
        value: function attributeToEntity(attribute, positions) {
            var entity = this.createFeature(attribute);
            this._positions_draw = positions;
            this.updateAttrForDrawing(true);
            this.finish();
            return entity;
        }
        //geojson转entity

    }, {
        key: 'jsonToEntity',
        value: function jsonToEntity(geojson) {
            var attribute = geojson.properties;
            var positions = (0, _point.getPositionByGeoJSON)(geojson);
            return this.attributeToEntity(attribute, positions);
        }
    }, {
        key: 'setDrawPositionByEntity',
        value: function setDrawPositionByEntity(entity) {
            var positions = this.getPositions(entity);
            this._positions_draw = positions;
        }
        //绑定外部entity到标绘

    }, {
        key: 'bindExtraEntity',
        value: function bindExtraEntity(entity, attribute) {
            this.entity = entity;
            entity.attribute = attribute;

            if (attribute.style) this.style2Entity(attribute.style, entity);

            this.setDrawPositionByEntity(entity);

            this.updateAttrForDrawing(true);
            this.finish();
            return entity;
        }
    }]);

    return DrawPBase;
}(_MarsClass2.MarsClass);

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditPModel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Attr = __webpack_require__(40);

var circleAttr = _interopRequireWildcard(_Attr);

var _EditP = __webpack_require__(188);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPModel = exports.EditPModel = function (_EditPBase) {
    _inherits(EditPModel, _EditPBase);

    function EditPModel() {
        _classCallCheck(this, EditPModel);

        return _possibleConstructorReturn(this, (EditPModel.__proto__ || Object.getPrototypeOf(EditPModel)).apply(this, arguments));
    }

    _createClass(EditPModel, [{
        key: 'setPositions',

        //外部更新位置
        value: function setPositions(position) {
            if (util.isArray(position) && position.length == 1) {
                position = position[0];
            }
            this.entity.position = position;
            this.entity.modelMatrix = this.getModelMatrix();
        }
    }, {
        key: 'getModelMatrix',
        value: function getModelMatrix(position) {
            var cfg = this.entity.attribute.style;

            var hpRoll = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(cfg.heading || 0), Cesium.Math.toRadians(cfg.pitch || 0), Cesium.Math.toRadians(cfg.roll || 0));
            var fixedFrameTransform = Cesium.Transforms.eastNorthUpToFixedFrame;

            var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(position || this.entity.position, hpRoll, this.viewer.scene.globe.ellipsoid, fixedFrameTransform);

            // Cesium.Matrix4.multiplyByUniformScale(modelMatrix, Cesium.defaultValue(cfg.scale, 1), modelMatrix);
            return modelMatrix;
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {
            if (!this.entity.ready) {
                var that = this;
                this.entity.readyPromise.then(function (model) {
                    that.bindDraggers();
                });
                return;
            }

            var that = this;

            this.entity.draw_tooltip = _Tooltip.message.dragger.def;

            var dragger = draggerCtl.createDragger(this.dataSource.entities, {
                dragger: this.entity,
                onDrag: function onDrag(dragger, newPosition) {
                    that.entity.position = newPosition;
                    that.entity.modelMatrix = that.getModelMatrix(newPosition);

                    that.updateDraggers();
                }
            });

            var style = this.entity.attribute.style;

            var position = this.entity.position;
            var height = Cesium.Cartographic.fromCartesian(position).height;
            var radius = this.entity.boundingSphere.radius;

            if (!this.entity.attribute.noExDragger) {
                //辅助显示：创建角度调整底部圆
                this.entityAngle = this.dataSource.entities.add({
                    name: '角度调整底部圆',
                    position: new Cesium.CallbackProperty(function (time) {
                        return that.entity.position;
                    }, false),
                    ellipse: circleAttr.style2Entity({
                        "fill": false,
                        "outline": true,
                        "outlineColor": "#ffff00",
                        "outlineOpacity": 0.8,
                        "radius": radius,
                        "height": height
                    })
                });

                //创建角度调整 拖拽点
                var majorPos = this.getHeadingPosition();
                var majorDragger = draggerCtl.createDragger(this.dataSource.entities, {
                    position: majorPos,
                    type: draggerCtl.PointType.EditAttr,
                    tooltip: _Tooltip.message.dragger.editHeading,
                    onDrag: function onDrag(dragger, position) {
                        var heading = that.getHeading(that.entity.position, position);
                        style.heading = that.formatNum(heading, 1);

                        that.entity.modelMatrix = that.getModelMatrix();
                        dragger.position = that.getHeadingPosition();
                    }
                });
                this.draggers.push(majorDragger);

                //缩放控制点 
                var position_scale = (0, _point.addPositionsHeight)(position, radius);
                var dragger = draggerCtl.createDragger(this.dataSource.entities, {
                    position: position_scale,
                    type: draggerCtl.PointType.MoveHeight,
                    tooltip: _Tooltip.message.dragger.editScale,
                    onDrag: function onDrag(dragger, positionNew) {
                        var radiusNew = Cesium.Cartesian3.distance(positionNew, position);

                        var radiusOld = dragger.radius / style.scale;
                        var scaleNew = radiusNew / radiusOld;

                        dragger.radius = radiusNew;
                        style.scale = that.formatNum(scaleNew, 2);

                        that.entity.scale = style.scale;
                        // that.entity.modelMatrix = that.getModelMatrix();
                        that.updateDraggers();
                    }
                });
                dragger.radius = radius;
                this.draggers.push(dragger);
            }
        }
    }, {
        key: 'destroyDraggers',
        value: function destroyDraggers() {
            _EditP.EditPBase.prototype.destroyDraggers.call(this);

            if (this.entityAngle) {
                this.dataSource.entities.remove(this.entityAngle);
                delete this.entityAngle;
            }
        }
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            delete this.entity.draw_tooltip;
            delete this.entity._isDragger;
            delete this.entity._noMousePosition;
            delete this.entity._pointType;
            delete this.entity.onDrag;
        }
    }, {
        key: 'getHeadingPosition',
        value: function getHeadingPosition() {
            //创建角度调整底部圆  
            var position = this.entity.position;
            var radius = this.entity.boundingSphere.radius;
            var angle = -Number(this.entity.attribute.style.heading || 0);

            var rotpos = new Cesium.Cartesian3(radius, 0.0, 0.0);

            var mat = Cesium.Transforms.eastNorthUpToFixedFrame(position);
            var rotationX = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(angle)));
            Cesium.Matrix4.multiply(mat, rotationX, mat);

            mat = Cesium.Matrix4.getMatrix3(mat, new Cesium.Matrix3());
            rotpos = Cesium.Matrix3.multiplyByVector(mat, rotpos, rotpos);
            rotpos = Cesium.Cartesian3.add(position, rotpos, rotpos);
            return rotpos;
        }
        //获取点相对于中心点的地面角度

    }, {
        key: 'getHeading',
        value: function getHeading(positionCenter, positionNew) {

            //获取该位置的默认矩阵 
            var mat = Cesium.Transforms.eastNorthUpToFixedFrame(positionCenter);
            mat = Cesium.Matrix4.getMatrix3(mat, new Cesium.Matrix3());

            var xaxis = Cesium.Matrix3.getColumn(mat, 0, new Cesium.Cartesian3());
            var yaxis = Cesium.Matrix3.getColumn(mat, 1, new Cesium.Cartesian3());
            var zaxis = Cesium.Matrix3.getColumn(mat, 2, new Cesium.Cartesian3());

            //计算该位置 和  positionCenter 的 角度值
            var dir = Cesium.Cartesian3.subtract(positionNew, positionCenter, new Cesium.Cartesian3());
            //z crosss (dirx cross z) 得到在 xy平面的向量
            dir = Cesium.Cartesian3.cross(dir, zaxis, dir);
            dir = Cesium.Cartesian3.cross(zaxis, dir, dir);
            dir = Cesium.Cartesian3.normalize(dir, dir);

            var heading = Cesium.Cartesian3.angleBetween(xaxis, dir);

            var ay = Cesium.Cartesian3.angleBetween(yaxis, dir);
            if (ay > Math.PI * 0.5) {
                heading = 2 * Math.PI - heading;
            }

            return -Cesium.Math.toDegrees(heading);
        }
    }]);

    return EditPModel;
}(_EditP.EditPBase);

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RectangularSensorPrimitive = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _RectangularSensorVS = __webpack_require__(197);

var _RectangularSensorVS2 = _interopRequireDefault(_RectangularSensorVS);

var _RectangularSensorFS = __webpack_require__(198);

var _RectangularSensorFS2 = _interopRequireDefault(_RectangularSensorFS);

var _RectangularSensor = __webpack_require__(199);

var _RectangularSensor2 = _interopRequireDefault(_RectangularSensor);

var _RectangularSensorScanPlaneFS = __webpack_require__(200);

var _RectangularSensorScanPlaneFS2 = _interopRequireDefault(_RectangularSensorScanPlaneFS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var BoundingSphere = Cesium.BoundingSphere;
var Cartesian3 = Cesium.Cartesian3;
var Color = Cesium.Color;
var combine = Cesium.combine;
var ComponentDatatype = Cesium.ComponentDatatype;
var defaultValue = Cesium.defaultValue;
var defined = Cesium.defined;
var DeveloperError = Cesium.DeveloperError;
var Matrix4 = Cesium.Matrix4;
var PrimitiveType = Cesium.PrimitiveType;
var Buffer = Cesium.Buffer;
var BufferUsage = Cesium.BufferUsage;
var DrawCommand = Cesium.DrawCommand;
var Pass = Cesium.Pass;
var RenderState = Cesium.RenderState;
var ShaderProgram = Cesium.ShaderProgram;
var ShaderSource = Cesium.ShaderSource;
var VertexArray = Cesium.VertexArray;
var BlendingState = Cesium.BlendingState;
var CullFace = Cesium.CullFace;
var Material = Cesium.Material;
var SceneMode = Cesium.SceneMode;
var VertexFormat = Cesium.VertexFormat;
var CesiumMath = Cesium.Math;
var Matrix3 = Cesium.Matrix3;
var Matrix4 = Cesium.Matrix4;
var JulianDate = Cesium.JulianDate;

// var BoxGeometry = Cesium.BoxGeometry;
// var EllipsoidGeometry = Cesium.EllipsoidGeometry;

var sin = Math.sin;
var cos = Math.cos;
var tan = Math.tan;
var atan = Math.atan;
var asin = Math.asin;

var attributeLocations = {
    position: 0,
    normal: 1
};

function RectangularSensorPrimitive(options) {
    var self = this;

    options = defaultValue(options, defaultValue.EMPTY_OBJECT);

    /**
     * 是否显示
     */
    this.show = defaultValue(options.show, true);

    /**
     * 切分程度
     */
    this.slice = defaultValue(options.slice, 32);

    /**
     * 传感器的模型矩阵
     */
    this.modelMatrix = Matrix4.clone(options.modelMatrix, new Matrix4());
    this._modelMatrix = new Matrix4();
    this._computedModelMatrix = new Matrix4();
    this._computedScanPlaneModelMatrix = new Matrix4();

    /**
     * 传感器的半径
     */
    this.radius = defaultValue(options.radius, Number.POSITIVE_INFINITY);
    this._radius = undefined;

    /**
     * 传感器水平半角
     */
    this.xHalfAngle = defaultValue(options.xHalfAngle, 0);
    this._xHalfAngle = undefined;

    /**
     * 传感器垂直半角
     */
    this.yHalfAngle = defaultValue(options.yHalfAngle, 0);
    this._yHalfAngle = undefined;

    /**
     * 线的颜色
     */
    this.lineColor = defaultValue(options.lineColor, Color.WHITE);

    /**
     * 是否显示扇面的线
     */
    this.showSectorLines = defaultValue(options.showSectorLines, true);

    /**
     * 是否显示扇面和圆顶面连接的线
     */
    this.showSectorSegmentLines = defaultValue(options.showSectorSegmentLines, true);

    /**
     * 是否显示侧面
     */
    this.showLateralSurfaces = defaultValue(options.showLateralSurfaces, true);

    /**
     * 目前用的统一材质
     * @type {Material}
     */
    this.material = defined(options.material) ? options.material : Material.fromType(Material.ColorType);
    this._material = undefined;
    this._translucent = undefined;

    /**
     * 侧面材质
     * @type {Material}
     */
    this.lateralSurfaceMaterial = defined(options.lateralSurfaceMaterial) ? options.lateralSurfaceMaterial : Material.fromType(Material.ColorType);
    this._lateralSurfaceMaterial = undefined;
    this._lateralSurfaceTranslucent = undefined;

    /**
     * 是否显示圆顶表面
     */
    this.showDomeSurfaces = defaultValue(options.showDomeSurfaces, true);

    /**
     * 圆顶表面材质
     * @type {Material}
     */
    this.domeSurfaceMaterial = defined(options.domeSurfaceMaterial) ? options.domeSurfaceMaterial : Material.fromType(Material.ColorType);
    this._domeSurfaceMaterial = undefined;

    /**
     * 是否显示圆顶面线
     */
    this.showDomeLines = defaultValue(options.showDomeLines, true);

    /**
     * 是否显示与地球相交的线
     */
    this.showIntersection = defaultValue(options.showIntersection, true);

    /**
     * 与地球相交的线的颜色
     */
    this.intersectionColor = defaultValue(options.intersectionColor, Color.WHITE);

    /**
     * 与地球相交的线的宽度（像素）
     */
    this.intersectionWidth = defaultValue(options.intersectionWidth, 5.0);

    /**
     * 是否穿过地球
     */
    this.showThroughEllipsoid = defaultValue(options.showThroughEllipsoid, false);
    this._showThroughEllipsoid = undefined;

    /**
     * 是否显示扫描面
     */
    this.showScanPlane = defaultValue(options.showScanPlane, true);

    /**
     * 扫描面颜色
     */
    this.scanPlaneColor = defaultValue(options.scanPlaneColor, Color.WHITE);

    /**
     * 扫描面模式 垂直vertical/水平horizontal
     */
    this.scanPlaneMode = defaultValue(options.scanPlaneMode, 'horizontal');

    /**
     * 扫描速率
     */
    this.scanPlaneRate = defaultValue(options.scanPlaneRate, 10);

    this._scanePlaneXHalfAngle = 0;
    this._scanePlaneYHalfAngle = 0;

    //时间计算的起点
    this._time = JulianDate.now();

    this._boundingSphere = new BoundingSphere();
    this._boundingSphereWC = new BoundingSphere();

    //扇面 sector
    this._sectorFrontCommand = new DrawCommand({
        owner: this,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingVolume: this._boundingSphereWC
    });
    this._sectorBackCommand = new DrawCommand({
        owner: this,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingVolume: this._boundingSphereWC
    });
    this._sectorVA = undefined;

    //扇面边线 sectorLine
    this._sectorLineCommand = new DrawCommand({
        owner: this,
        primitiveType: PrimitiveType.LINES,
        boundingVolume: this._boundingSphereWC
    });
    this._sectorLineVA = undefined;

    //扇面分割线 sectorSegmentLine
    this._sectorSegmentLineCommand = new DrawCommand({
        owner: this,
        primitiveType: PrimitiveType.LINES,
        boundingVolume: this._boundingSphereWC
    });
    this._sectorSegmentLineVA = undefined;

    //弧面 dome
    this._domeFrontCommand = new DrawCommand({
        owner: this,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingVolume: this._boundingSphereWC
    });
    this._domeBackCommand = new DrawCommand({
        owner: this,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingVolume: this._boundingSphereWC
    });
    this._domeVA = undefined;

    //弧面线 domeLine
    this._domeLineCommand = new DrawCommand({
        owner: this,
        primitiveType: PrimitiveType.LINES,
        boundingVolume: this._boundingSphereWC
    });
    this._domeLineVA = undefined;

    //扫描面 scanPlane/scanRadial
    this._scanPlaneFrontCommand = new DrawCommand({
        owner: this,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingVolume: this._boundingSphereWC
    });
    this._scanPlaneBackCommand = new DrawCommand({
        owner: this,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingVolume: this._boundingSphereWC
    });

    this._scanRadialCommand = undefined;

    this._colorCommands = [];

    this._frontFaceRS = undefined;
    this._backFaceRS = undefined;
    this._sp = undefined;

    this._uniforms = {
        u_type: function u_type() {
            return 0; //面
        },
        u_xHalfAngle: function u_xHalfAngle() {
            return self.xHalfAngle;
        },
        u_yHalfAngle: function u_yHalfAngle() {
            return self.yHalfAngle;
        },
        u_radius: function u_radius() {
            return self.radius;
        },
        u_showThroughEllipsoid: function u_showThroughEllipsoid() {
            return self.showThroughEllipsoid;
        },
        u_showIntersection: function u_showIntersection() {
            return self.showIntersection;
        },
        u_intersectionColor: function u_intersectionColor() {
            return self.intersectionColor;
        },
        u_intersectionWidth: function u_intersectionWidth() {
            return self.intersectionWidth;
        },
        u_normalDirection: function u_normalDirection() {
            return 1.0;
        },
        u_lineColor: function u_lineColor() {
            return self.lineColor;
        }
    };

    this._scanUniforms = {
        u_xHalfAngle: function u_xHalfAngle() {
            return self._scanePlaneXHalfAngle;
        },
        u_yHalfAngle: function u_yHalfAngle() {
            return self._scanePlaneYHalfAngle;
        },
        u_radius: function u_radius() {
            return self.radius;
        },
        u_color: function u_color() {
            return self.scanPlaneColor;
        },
        u_showThroughEllipsoid: function u_showThroughEllipsoid() {
            return self.showThroughEllipsoid;
        },
        u_showIntersection: function u_showIntersection() {
            return self.showIntersection;
        },
        u_intersectionColor: function u_intersectionColor() {
            return self.intersectionColor;
        },
        u_intersectionWidth: function u_intersectionWidth() {
            return self.intersectionWidth;
        },
        u_normalDirection: function u_normalDirection() {
            return 1.0;
        },
        u_lineColor: function u_lineColor() {
            return self.lineColor;
        }
    };
}

RectangularSensorPrimitive.prototype.update = function (frameState) {
    var mode = frameState.mode;
    if (!this.show || mode !== SceneMode.SCENE3D) {
        return;
    }
    var createVS = false;
    var createRS = false;
    var createSP = false;

    var xHalfAngle = this.xHalfAngle;
    var yHalfAngle = this.yHalfAngle;

    if (xHalfAngle < 0.0 || yHalfAngle < 0.0) {
        throw new DeveloperError('halfAngle must be greater than or equal to zero.');
    }
    if (xHalfAngle == 0.0 || yHalfAngle == 0.0) {
        return;
    }
    if (this._xHalfAngle !== xHalfAngle || this._yHalfAngle !== yHalfAngle) {
        this._xHalfAngle = xHalfAngle;
        this._yHalfAngle = yHalfAngle;
        createVS = true;
    }

    var radius = this.radius;
    if (radius < 0.0) {
        throw new DeveloperError('this.radius must be greater than or equal to zero.');
    }
    var radiusChanged = false;
    if (this._radius !== radius) {
        radiusChanged = true;
        this._radius = radius;
        this._boundingSphere = new BoundingSphere(Cartesian3.ZERO, this.radius);
    }

    var modelMatrixChanged = !Matrix4.equals(this.modelMatrix, this._modelMatrix);
    if (modelMatrixChanged || radiusChanged) {
        Matrix4.clone(this.modelMatrix, this._modelMatrix);
        Matrix4.multiplyByUniformScale(this.modelMatrix, this.radius, this._computedModelMatrix);
        BoundingSphere.transform(this._boundingSphere, this.modelMatrix, this._boundingSphereWC);
    }

    var showThroughEllipsoid = this.showThroughEllipsoid;
    if (this._showThroughEllipsoid !== this.showThroughEllipsoid) {
        this._showThroughEllipsoid = showThroughEllipsoid;
        createRS = true;
    }

    var material = this.material;
    if (this._material !== material) {
        this._material = material;
        createRS = true;
        createSP = true;
    }
    var translucent = material.isTranslucent();
    if (this._translucent !== translucent) {
        this._translucent = translucent;
        createRS = true;
    }

    if (this.showScanPlane) {
        var time = frameState.time;
        var timeDiff = JulianDate.secondsDifference(time, this._time);
        if (timeDiff < 0) {
            this._time = JulianDate.clone(time, this._time);
        }
        var percentage = Math.max(timeDiff % this.scanPlaneRate / this.scanPlaneRate, 0);
        var angle;

        if (this.scanPlaneMode == 'horizontal') {
            angle = 2 * yHalfAngle * percentage - yHalfAngle;
            var cosYHalfAngle = cos(angle);
            var tanXHalfAngle = tan(xHalfAngle);

            var maxX = atan(cosYHalfAngle * tanXHalfAngle);
            this._scanePlaneXHalfAngle = maxX;
            this._scanePlaneYHalfAngle = angle;
            Cesium.Matrix3.fromRotationX(this._scanePlaneYHalfAngle, matrix3Scratch);
        } else {
            angle = 2 * xHalfAngle * percentage - xHalfAngle;
            var tanYHalfAngle = tan(yHalfAngle);
            var cosXHalfAngle = cos(angle);

            var maxY = atan(cosXHalfAngle * tanYHalfAngle);
            this._scanePlaneXHalfAngle = angle;
            this._scanePlaneYHalfAngle = maxY;
            Cesium.Matrix3.fromRotationY(this._scanePlaneXHalfAngle, matrix3Scratch);
        }

        Cesium.Matrix4.multiplyByMatrix3(this.modelMatrix, matrix3Scratch, this._computedScanPlaneModelMatrix);
        Matrix4.multiplyByUniformScale(this._computedScanPlaneModelMatrix, this.radius, this._computedScanPlaneModelMatrix);
    }

    if (createVS) {
        createVertexArray(this, frameState);
    }
    if (createRS) {
        createRenderState(this, showThroughEllipsoid, translucent);
    }
    if (createSP) {
        createShaderProgram(this, frameState, material);
    }
    if (createRS || createSP) {
        createCommands(this, translucent);
    }

    var commandList = frameState.commandList;
    var passes = frameState.passes;
    var colorCommands = this._colorCommands;
    if (passes.render) {
        for (var i = 0, len = colorCommands.length; i < len; i++) {
            var colorCommand = colorCommands[i];
            commandList.push(colorCommand);
        }
    }
};

var matrix3Scratch = new Matrix3();
var nScratch = new Cartesian3();

//region -- VertexArray --

/**
 * 计算zoy面和zoy面单位扇形位置
 * @param primitive
 * @returns {{zoy: Array, zox: Array}}
 */
function computeUnitPosiiton(primitive, xHalfAngle, yHalfAngle) {
    var slice = primitive.slice;

    //以中心为角度
    var cosYHalfAngle = cos(yHalfAngle);
    var tanYHalfAngle = tan(yHalfAngle);
    var cosXHalfAngle = cos(xHalfAngle);
    var tanXHalfAngle = tan(xHalfAngle);

    var maxY = atan(cosXHalfAngle * tanYHalfAngle);
    var maxX = atan(cosYHalfAngle * tanXHalfAngle);

    //ZOY面单位圆
    var zoy = [];
    for (var i = 0; i < slice; i++) {
        var phi = 2 * maxY * i / (slice - 1) - maxY;
        zoy.push(new Cartesian3(0, sin(phi), cos(phi)));
    }
    //zox面单位圆
    var zox = [];
    for (var i = 0; i < slice; i++) {
        var phi = 2 * maxX * i / (slice - 1) - maxX;
        zox.push(new Cartesian3(sin(phi), 0, cos(phi)));
    }

    return {
        zoy: zoy,
        zox: zox
    };
}

/**
 * 计算扇面的位置
 * @param unitPosition
 * @returns {Array}
 */
function computeSectorPositions(primitive, unitPosition) {
    var xHalfAngle = primitive.xHalfAngle,
        yHalfAngle = primitive.yHalfAngle,
        zoy = unitPosition.zoy,
        zox = unitPosition.zox;
    var positions = [];

    //zoy面沿y轴逆时针转xHalfAngle
    var matrix3 = Matrix3.fromRotationY(xHalfAngle, matrix3Scratch);
    positions.push(zoy.map(function (p) {
        return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
    }));
    //zox面沿x轴顺时针转yHalfAngle
    var matrix3 = Matrix3.fromRotationX(-yHalfAngle, matrix3Scratch);
    positions.push(zox.map(function (p) {
        return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
    }).reverse());
    //zoy面沿y轴顺时针转xHalfAngle
    var matrix3 = Matrix3.fromRotationY(-xHalfAngle, matrix3Scratch);
    positions.push(zoy.map(function (p) {
        return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
    }).reverse());
    //zox面沿x轴逆时针转yHalfAngle
    var matrix3 = Matrix3.fromRotationX(yHalfAngle, matrix3Scratch);
    positions.push(zox.map(function (p) {
        return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
    }));
    return positions;
}

/**
 * 创建扇面顶点
 * @param context
 * @param positions
 * @returns {*}
 */
function createSectorVertexArray(context, positions) {
    var planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
    var vertices = new Float32Array(2 * 3 * 3 * planeLength);

    var k = 0;
    for (var i = 0, len = positions.length; i < len; i++) {
        var planePositions = positions[i];
        var n = Cartesian3.normalize(Cartesian3.cross(planePositions[0], planePositions[planePositions.length - 1], nScratch), nScratch);
        for (var j = 0, planeLength = planePositions.length - 1; j < planeLength; j++) {
            vertices[k++] = 0.0;
            vertices[k++] = 0.0;
            vertices[k++] = 0.0;
            vertices[k++] = -n.x;
            vertices[k++] = -n.y;
            vertices[k++] = -n.z;

            vertices[k++] = planePositions[j].x;
            vertices[k++] = planePositions[j].y;
            vertices[k++] = planePositions[j].z;
            vertices[k++] = -n.x;
            vertices[k++] = -n.y;
            vertices[k++] = -n.z;

            vertices[k++] = planePositions[j + 1].x;
            vertices[k++] = planePositions[j + 1].y;
            vertices[k++] = planePositions[j + 1].z;
            vertices[k++] = -n.x;
            vertices[k++] = -n.y;
            vertices[k++] = -n.z;
        }
    }

    var vertexBuffer = Buffer.createVertexBuffer({
        context: context,
        typedArray: vertices,
        usage: BufferUsage.STATIC_DRAW
    });

    var stride = 2 * 3 * Float32Array.BYTES_PER_ELEMENT;

    var attributes = [{
        index: attributeLocations.position,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
    }, {
        index: attributeLocations.normal,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 3 * Float32Array.BYTES_PER_ELEMENT,
        strideInBytes: stride
    }];

    return new VertexArray({
        context: context,
        attributes: attributes
    });
}

/**
 * 创建扇面边线顶点
 * @param context
 * @param positions
 * @returns {*}
 */
function createSectorLineVertexArray(context, positions) {
    var planeLength = positions.length;
    var vertices = new Float32Array(3 * 3 * planeLength);

    var k = 0;
    for (var i = 0, len = positions.length; i < len; i++) {
        var planePositions = positions[i];
        vertices[k++] = 0.0;
        vertices[k++] = 0.0;
        vertices[k++] = 0.0;

        vertices[k++] = planePositions[0].x;
        vertices[k++] = planePositions[0].y;
        vertices[k++] = planePositions[0].z;
    }

    var vertexBuffer = Buffer.createVertexBuffer({
        context: context,
        typedArray: vertices,
        usage: BufferUsage.STATIC_DRAW
    });

    var stride = 3 * Float32Array.BYTES_PER_ELEMENT;

    var attributes = [{
        index: attributeLocations.position,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
    }];

    return new VertexArray({
        context: context,
        attributes: attributes
    });
}

/**
 * 创建扇面圆顶面连接线顶点
 * @param context
 * @param positions
 * @returns {*}
 */
function createSectorSegmentLineVertexArray(context, positions) {
    var planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
    var vertices = new Float32Array(3 * 3 * planeLength);

    var k = 0;
    for (var i = 0, len = positions.length; i < len; i++) {
        var planePositions = positions[i];

        for (var j = 0, planeLength = planePositions.length - 1; j < planeLength; j++) {
            vertices[k++] = planePositions[j].x;
            vertices[k++] = planePositions[j].y;
            vertices[k++] = planePositions[j].z;

            vertices[k++] = planePositions[j + 1].x;
            vertices[k++] = planePositions[j + 1].y;
            vertices[k++] = planePositions[j + 1].z;
        }
    }

    var vertexBuffer = Buffer.createVertexBuffer({
        context: context,
        typedArray: vertices,
        usage: BufferUsage.STATIC_DRAW
    });

    var stride = 3 * Float32Array.BYTES_PER_ELEMENT;

    var attributes = [{
        index: attributeLocations.position,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
    }];

    return new VertexArray({
        context: context,
        attributes: attributes
    });
}

/**
 * 创建圆顶面顶点
 * @param context
 */
function createDomeVertexArray(context) {
    var geometry = Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({
        vertexFormat: VertexFormat.POSITION_ONLY,
        stackPartitions: 32,
        slicePartitions: 32
    }));

    var vertexArray = VertexArray.fromGeometry({
        context: context,
        geometry: geometry,
        attributeLocations: attributeLocations,
        bufferUsage: BufferUsage.STATIC_DRAW,
        interleave: false
    });
    return vertexArray;
}

/**
 * 创建圆顶面连线顶点
 * @param context
 */
function createDomeLineVertexArray(context) {
    var geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(new Cesium.EllipsoidOutlineGeometry({
        vertexFormat: VertexFormat.POSITION_ONLY,
        stackPartitions: 32,
        slicePartitions: 32
    }));

    var vertexArray = VertexArray.fromGeometry({
        context: context,
        geometry: geometry,
        attributeLocations: attributeLocations,
        bufferUsage: BufferUsage.STATIC_DRAW,
        interleave: false
    });
    return vertexArray;
}

/**
 * 创建扫描面顶点
 * @param context
 * @param positions
 * @returns {*}
 */
function createScanPlaneVertexArray(context, positions) {
    var planeLength = positions.length - 1;
    var vertices = new Float32Array(3 * 3 * planeLength);

    var k = 0;
    for (var i = 0; i < planeLength; i++) {
        vertices[k++] = 0.0;
        vertices[k++] = 0.0;
        vertices[k++] = 0.0;

        vertices[k++] = positions[i].x;
        vertices[k++] = positions[i].y;
        vertices[k++] = positions[i].z;

        vertices[k++] = positions[i + 1].x;
        vertices[k++] = positions[i + 1].y;
        vertices[k++] = positions[i + 1].z;
    }

    var vertexBuffer = Buffer.createVertexBuffer({
        context: context,
        typedArray: vertices,
        usage: BufferUsage.STATIC_DRAW
    });

    var stride = 3 * Float32Array.BYTES_PER_ELEMENT;

    var attributes = [{
        index: attributeLocations.position,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
    }];

    return new VertexArray({
        context: context,
        attributes: attributes
    });
}

function createVertexArray(primitive, frameState) {
    var context = frameState.context;

    var unitSectorPositions = computeUnitPosiiton(primitive, primitive.xHalfAngle, primitive.yHalfAngle);
    var positions = computeSectorPositions(primitive, unitSectorPositions);

    //显示扇面
    if (primitive.showLateralSurfaces) {
        primitive._sectorVA = createSectorVertexArray(context, positions);
    }

    //显示扇面线
    if (primitive.showSectorLines) {
        primitive._sectorLineVA = createSectorLineVertexArray(context, positions);
    }

    //显示扇面圆顶面的交线
    if (primitive.showSectorSegmentLines) {
        primitive._sectorSegmentLineVA = createSectorSegmentLineVertexArray(context, positions);
    }

    //显示弧面
    if (primitive.showDomeSurfaces) {
        primitive._domeVA = createDomeVertexArray(context);
    }

    //显示弧面线
    if (primitive.showDomeLines) {
        primitive._domeLineVA = createDomeLineVertexArray(context);
    }

    //显示扫描面
    if (primitive.showScanPlane) {

        if (primitive.scanPlaneMode == 'horizontal') {
            var unitScanPlanePositions = computeUnitPosiiton(primitive, CesiumMath.PI_OVER_TWO, 0);
            primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zox);
        } else {
            var unitScanPlanePositions = computeUnitPosiiton(primitive, 0, CesiumMath.PI_OVER_TWO);
            primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zoy);
        }
    }
}

//endregion

//region -- ShaderProgram --

function createCommonShaderProgram(primitive, frameState, material) {
    var context = frameState.context;

    var vs = _RectangularSensorVS2.default;
    var fs = new ShaderSource({
        sources: [_RectangularSensor2.default, material.shaderSource, _RectangularSensorFS2.default]
    });

    primitive._sp = ShaderProgram.replaceCache({
        context: context,
        shaderProgram: primitive._sp,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations
    });

    var pickFS = new ShaderSource({
        sources: [_RectangularSensor2.default, material.shaderSource, _RectangularSensorFS2.default],
        pickColorQualifier: 'uniform'
    });

    primitive._pickSP = ShaderProgram.replaceCache({
        context: context,
        shaderProgram: primitive._pickSP,
        vertexShaderSource: vs,
        fragmentShaderSource: pickFS,
        attributeLocations: attributeLocations
    });
}

function createScanPlaneShaderProgram(primitive, frameState, material) {
    var context = frameState.context;

    var vs = _RectangularSensorVS2.default;
    var fs = new ShaderSource({
        sources: [_RectangularSensor2.default, material.shaderSource, _RectangularSensorScanPlaneFS2.default]
    });

    primitive._scanePlaneSP = ShaderProgram.replaceCache({
        context: context,
        shaderProgram: primitive._scanePlaneSP,
        vertexShaderSource: vs,
        fragmentShaderSource: fs,
        attributeLocations: attributeLocations
    });
}

function createShaderProgram(primitive, frameState, material) {
    createCommonShaderProgram(primitive, frameState, material);

    if (primitive.showScanPlane) {
        createScanPlaneShaderProgram(primitive, frameState, material);
    }
}

//endregion

//region -- RenderState --

function createRenderState(primitive, showThroughEllipsoid, translucent) {
    if (translucent) {
        primitive._frontFaceRS = RenderState.fromCache({
            depthTest: {
                enabled: !showThroughEllipsoid
            },
            depthMask: false,
            blending: BlendingState.ALPHA_BLEND,
            cull: {
                enabled: true,
                face: CullFace.BACK
            }
        });

        primitive._backFaceRS = RenderState.fromCache({
            depthTest: {
                enabled: !showThroughEllipsoid
            },
            depthMask: false,
            blending: BlendingState.ALPHA_BLEND,
            cull: {
                enabled: true,
                face: CullFace.FRONT
            }
        });

        primitive._pickRS = RenderState.fromCache({
            depthTest: {
                enabled: !showThroughEllipsoid
            },
            depthMask: false,
            blending: BlendingState.ALPHA_BLEND
        });
    } else {
        primitive._frontFaceRS = RenderState.fromCache({
            depthTest: {
                enabled: !showThroughEllipsoid
            },
            depthMask: true
        });

        primitive._pickRS = RenderState.fromCache({
            depthTest: {
                enabled: true
            },
            depthMask: true
        });
    }
}

//endregion

//region -- Command --

function createCommand(primitive, frontCommand, backCommand, frontFaceRS, backFaceRS, sp, va, uniforms, modelMatrix, translucent, pass, isLine) {
    if (translucent && backCommand) {
        backCommand.vertexArray = va;
        backCommand.renderState = backFaceRS;
        backCommand.shaderProgram = sp;
        backCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
        backCommand.uniformMap.u_normalDirection = function () {
            return -1.0;
        };
        backCommand.pass = pass;
        backCommand.modelMatrix = modelMatrix;
        primitive._colorCommands.push(backCommand);
    }

    frontCommand.vertexArray = va;
    frontCommand.renderState = frontFaceRS;
    frontCommand.shaderProgram = sp;
    frontCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
    if (isLine) {
        frontCommand.uniformMap.u_type = function () {
            return 1;
        };
    }
    frontCommand.pass = pass;
    frontCommand.modelMatrix = modelMatrix;
    primitive._colorCommands.push(frontCommand);
}

function createCommands(primitive, translucent) {
    primitive._colorCommands.length = 0;

    var pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;

    //显示扇面
    if (primitive.showLateralSurfaces) {
        createCommand(primitive, primitive._sectorFrontCommand, primitive._sectorBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass);
    }
    //显示扇面线
    if (primitive.showSectorLines) {
        createCommand(primitive, primitive._sectorLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
    }
    //显示扇面交接线
    if (primitive.showSectorSegmentLines) {
        createCommand(primitive, primitive._sectorSegmentLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorSegmentLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
    }
    //显示弧面
    if (primitive.showDomeSurfaces) {
        createCommand(primitive, primitive._domeFrontCommand, primitive._domeBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._domeVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass);
    }
    //显示弧面线
    if (primitive.showDomeLines) {
        createCommand(primitive, primitive._domeLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._domeLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
    }
    //显示扫描面
    if (primitive.showScanPlane) {
        createCommand(primitive, primitive._scanPlaneFrontCommand, primitive._scanPlaneBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._scanePlaneSP, primitive._scanPlaneVA, primitive._scanUniforms, primitive._computedScanPlaneModelMatrix, translucent, pass);
    }
}

//endregion

exports.RectangularSensorPrimitive = RectangularSensorPrimitive;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(92);

__webpack_require__(93);

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _version = __webpack_require__(47);

var ver = _interopRequireWildcard(_version);

var _ViewerEx = __webpack_require__(48);

var _MarsClass = __webpack_require__(3);

var _widgetManager = __webpack_require__(72);

var widget = _interopRequireWildcard(_widgetManager);

var _BaseWidget = __webpack_require__(133);

var _map = __webpack_require__(135);

var _layer = __webpack_require__(23);

var layer = _interopRequireWildcard(_layer);

var _FloodByEntity = __webpack_require__(137);

var _FloodByTerrain = __webpack_require__(138);

var _Measure = __webpack_require__(139);

var _MeasureAngle = __webpack_require__(74);

var _MeasureArea = __webpack_require__(36);

var _MeasureAreaSurface = __webpack_require__(76);

var _MeasureHeight = __webpack_require__(77);

var _MeasureHeightTriangle = __webpack_require__(78);

var _MeasureLength = __webpack_require__(37);

var _MeasureLengthSection = __webpack_require__(79);

var _MeasureLengthSurface = __webpack_require__(80);

var _MeasurePoint = __webpack_require__(81);

var _MeasureVolume = __webpack_require__(82);

var _Skyline = __webpack_require__(140);

var _TerrainClip = __webpack_require__(142);

var _TerrainClipPlan = __webpack_require__(143);

var _Underground = __webpack_require__(144);

var _ViewShed3D = __webpack_require__(145);

var _Sightline = __webpack_require__(147);

var _ContourLine = __webpack_require__(148);

var _Slope = __webpack_require__(75);

var _MixedOcclusion = __webpack_require__(149);

var _TilesEditor = __webpack_require__(151);

var _TilesClipPlan = __webpack_require__(86);

var _TilesClip = __webpack_require__(152);

var _TilesFlat = __webpack_require__(155);

var _TilesFlood = __webpack_require__(156);

var _GltfClipPlan = __webpack_require__(157);

var _FlyLine = __webpack_require__(158);

var _KeyboardRoam = __webpack_require__(70);

var _FirstPersonRoam = __webpack_require__(159);

var _Draw = __webpack_require__(6);

var _index = __webpack_require__(20);

var Attr = _interopRequireWildcard(_index);

var _Tooltip = __webpack_require__(7);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Edit = __webpack_require__(28);

var _Edit2 = __webpack_require__(65);

var _Edit3 = __webpack_require__(62);

var _Edit4 = __webpack_require__(60);

var _Edit5 = __webpack_require__(66);

var _Edit6 = __webpack_require__(59);

var _Edit7 = __webpack_require__(29);

var _Edit8 = __webpack_require__(11);

var _Edit9 = __webpack_require__(25);

var _Edit10 = __webpack_require__(61);

var _Edit11 = __webpack_require__(64);

var _Edit12 = __webpack_require__(67);

var _Edit13 = __webpack_require__(69);

var _Edit14 = __webpack_require__(68);

var _PlotUtil = __webpack_require__(9);

__webpack_require__(160);

__webpack_require__(162);

__webpack_require__(164);

__webpack_require__(166);

__webpack_require__(168);

__webpack_require__(170);

__webpack_require__(172);

__webpack_require__(174);

__webpack_require__(176);

__webpack_require__(178);

__webpack_require__(180);

__webpack_require__(181);

__webpack_require__(182);

__webpack_require__(183);

__webpack_require__(184);

__webpack_require__(185);

var _DrawP = __webpack_require__(186);

var _EditP = __webpack_require__(89);

var _CircleFadeMaterial = __webpack_require__(189);

var _CircleWaveMaterial = __webpack_require__(50);

var _CircleScanMaterial = __webpack_require__(191);

var _GroundLineFlowMaterial = __webpack_require__(193);

var _LineFlowMaterial = __webpack_require__(39);

var _TextMaterial = __webpack_require__(195);

var _RectangularSensorPrimitive = __webpack_require__(90);

var _RectangularSensorGraphics = __webpack_require__(85);

var _RectangularSensorVisualizer = __webpack_require__(201);

var _DivPoint = __webpack_require__(87);

var _DynamicRiver = __webpack_require__(202);

var _water = __webpack_require__(55);

var water = _interopRequireWildcard(_water);

var _ParticleSystemEx = __webpack_require__(206);

var _FlatBillboard = __webpack_require__(207);

var _FlatImage = __webpack_require__(210);

var _ConeGlow = __webpack_require__(212);

var _DiffuseWallGlow = __webpack_require__(217);

var _ScrollWallGlow = __webpack_require__(220);

var _FogEffect = __webpack_require__(223);

var _InvertedScene = __webpack_require__(225);

var _SnowCover = __webpack_require__(227);

var _Rain = __webpack_require__(229);

var _Rain2 = _interopRequireDefault(_Rain);

var _Snow = __webpack_require__(230);

var _Snow2 = _interopRequireDefault(_Snow);

var _ZoomNavigation = __webpack_require__(231);

var _matrix = __webpack_require__(17);

var matrix = _interopRequireWildcard(_matrix);

var _model = __webpack_require__(232);

var model = _interopRequireWildcard(_model);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _polygon = __webpack_require__(13);

var polygon = _interopRequireWildcard(_polygon);

var _polyline = __webpack_require__(22);

var polyline = _interopRequireWildcard(_polyline);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _config2Entity = __webpack_require__(32);

var _defaultContextMenu = __webpack_require__(71);

var _measure = __webpack_require__(30);

var measure = _interopRequireWildcard(_measure);

var _tileset = __webpack_require__(27);

var tileset = _interopRequireWildcard(_tileset);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _Video3D = __webpack_require__(233);

var _Video2D = __webpack_require__(235);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Cesium = Cesium; //方便vue等技术栈直接使用


//===========框架基本信息=========  


exports.name = "Okay3D ( MarsGIS for Cesium )三维地球框架";
exports.website = "http://cesium.marsgis.cn";
exports.author = "欧科科技 木遥";
exports.version = ver.version;
exports.update = ver.update;

//=============Cesium原生对象做的外挂扩展=====================

exports.ViewerEx = _ViewerEx.ViewerEx;

//=============基础类=====================

exports.MarsClass = _MarsClass.MarsClass;
exports.event = _MarsClass.eventType;

//=============widget=====================

exports.widget = widget;

exports.widget.BaseWidget = _BaseWidget.BaseWidget;

//=============三维框架类=====================

exports.createMap = _map.createMap;

exports.layer = layer;

//=====================分析相关=====================
exports.analysi = {};

//淹没分析（polygon矢量面抬高）

exports.analysi.FloodByEntity = _FloodByEntity.FloodByEntity;

//淹没分析 （基于terrain地形）

exports.analysi.FloodByTerrain = _FloodByTerrain.FloodByTerrain;

//量算（长度、面积、角度等）

exports.analysi.Measure = _Measure.Measure;

exports.analysi.MeasureAngle = _MeasureAngle.MeasureAngle;

exports.analysi.MeasureArea = _MeasureArea.MeasureArea;

exports.analysi.MeasureAreaSurface = _MeasureAreaSurface.MeasureAreaSurface;

exports.analysi.MeasureHeight = _MeasureHeight.MeasureHeight;

exports.analysi.MeasureHeightTriangle = _MeasureHeightTriangle.MeasureHeightTriangle;

exports.analysi.MeasureLength = _MeasureLength.MeasureLength;

exports.analysi.MeasureLengthSection = _MeasureLengthSection.MeasureLengthSection;

exports.analysi.MeasureLengthSurface = _MeasureLengthSurface.MeasureLengthSurface;

exports.analysi.MeasurePoint = _MeasurePoint.MeasurePoint;

exports.analysi.MeasureVolume = _MeasureVolume.MeasureVolume; //方量分析


//天际线 描边

exports.analysi.Skyline = _Skyline.Skyline;

//地形开挖 类 (基于地形)

exports.analysi.TerrainClip = _TerrainClip.TerrainClip;

//地形开挖 类（平面 Plan原生）

exports.analysi.TerrainClipPlan = _TerrainClipPlan.TerrainClipPlan;

//地下模式

exports.analysi.Underground = _Underground.Underground;

//可视域分析 

exports.analysi.ViewShed3D = _ViewShed3D.ViewShed3D;

//通视分析

exports.analysi.Sightline = _Sightline.Sightline;

//等高线

exports.analysi.ContourLine = _ContourLine.ContourLine;

//坡度坡向

exports.analysi.Slope = _Slope.Slope;

//=====================3dtiles模型 分析相关  =====================
exports.tiles = {};

//混合遮挡

exports.tiles.MixedOcclusion = _MixedOcclusion.MixedOcclusion;

//模型编辑（移动、旋转等）

exports.tiles.TilesEditor = _TilesEditor.TilesEditor;

//模型裁剪（平面 Plan原生）

exports.tiles.TilesClipPlan = _TilesClipPlan.TilesClipPlan;

//模型 裁剪（单个、对数据有要求）

exports.tiles.TilesClip = _TilesClip.TilesClip;

//模型 压平分析 （单个、对数据有要求）

exports.tiles.TilesFlat = _TilesFlat.TilesFlat;

//模型 淹没分析（单个、对数据有要求）

exports.tiles.TilesFlood = _TilesFlood.TilesFlood;

//gltf模型 裁剪

exports.GltfClipPlan = _GltfClipPlan.GltfClipPlan;

//=====================相机 视角 相关=====================

exports.FlyLine = _FlyLine.FlyLine;

exports.KeyboardType = _KeyboardRoam.KeyboardType;

exports.FirstPersonRoam = _FirstPersonRoam.FirstPersonRoam;

//=====================Draw标绘=====================

exports.Draw = _Draw.Draw;

exports.draw = {};
exports.draw.register = _Draw.register;

exports.draw.attr = Attr;

exports.draw.tooltip = _Tooltip.message;

exports.draw.dragger = draggerCtl;

exports.DrawEdit = {};

exports.DrawEdit.Base = _Edit.EditBase;

exports.DrawEdit.Circle = _Edit2.EditCircle;

exports.DrawEdit.Corridor = _Edit3.EditCorridor;

exports.DrawEdit.Curve = _Edit4.EditCurve;

exports.DrawEdit.Ellipsoid = _Edit5.EditEllipsoid;

exports.DrawEdit.Point = _Edit6.EditPoint;

exports.DrawEdit.Polygon = _Edit7.EditPolygon;

exports.DrawEdit.PolygonEx = _Edit8.EditPolygonEx;

exports.DrawEdit.Polyline = _Edit9.EditPolyline;

exports.DrawEdit.PolylineVolume = _Edit10.EditPolylineVolume;

exports.DrawEdit.Rectangle = _Edit11.EditRectangle;

exports.DrawEdit.Wall = _Edit12.EditWall;

exports.DrawEdit.Box = _Edit13.EditBox;

exports.DrawEdit.Plane = _Edit14.EditPlane;

//Draw标绘 扩展部分，下面也可以单独插件的方式另外打包

exports.draw.plotUtil = _PlotUtil.plotUtil;

//绘制primitive类型

exports.DrawP = _DrawP.DrawP;
exports.draw.registerP = _DrawP.registerP;

exports.DrawEdit.PModel = _EditP.EditPModel;

//=====================扩展的矢量对象=====================
//扩展的材质

exports.CircleFadeMaterial = _CircleFadeMaterial.CircleFadeMaterial;

exports.CircleWaveMaterial = _CircleWaveMaterial.CircleWaveMaterial;

exports.CircleScanMaterial = _CircleScanMaterial.CircleScanMaterial;

//贴地线

exports.GroundLineFlowMaterial = _GroundLineFlowMaterial.GroundLineFlowMaterial;

//动态线、墙

exports.LineFlowMaterial = _LineFlowMaterial.LineFlowMaterial;

//文本材质

exports.TextMaterial = _TextMaterial.TextMaterial;

//相控阵雷达

exports.RectangularSensorPrimitive = _RectangularSensorPrimitive.RectangularSensorPrimitive;
exports.RectangularSensorGraphics = _RectangularSensorGraphics.RectangularSensorGraphics;
exports.RectangularSensorVisualizer = _RectangularSensorVisualizer.RectangularSensorVisualizer;

//div点

exports.DivPoint = _DivPoint.DivPoint;

//动态河流、公路

exports.DynamicRiver = _DynamicRiver.DynamicRiver;

//水域 相关效果

exports.water = water;

//粒子效果封装

exports.ParticleSystemEx = _ParticleSystemEx.ParticleSystemEx;

//平放的图标

exports.FlatBillboard = _FlatBillboard.FlatBillboard;

//平放的图片（随地图缩放）

exports.FlatImage = _FlatImage.FlatImage;

//光柱椎体

exports.ConeGlow = _ConeGlow.ConeGlow;

//立体面(或圆)散射围墙效果

exports.DiffuseWallGlow = _DiffuseWallGlow.DiffuseWallGlow;

//走马灯围墙效果

exports.ScrollWallGlow = _ScrollWallGlow.ScrollWallGlow;

//=====================场景特效=====================
exports.scene = {};

//雾特效

exports.scene.FogEffect = _FogEffect.FogEffect;

//场景倒影

exports.scene.InvertedScene = _InvertedScene.InvertedScene;

//雾覆盖 效果

exports.scene.SnowCover = _SnowCover.SnowCover;

//=====================Shader特效=====================
exports.shader = {};
//雨雪 着色器

exports.shader.rain = _Rain2.default;

exports.shader.snow = _Snow2.default;

//===================== tool =====================

exports.ZoomNavigation = _ZoomNavigation.ZoomNavigation;

//===================== util =====================

exports.matrix = matrix;

exports.model = model;

exports.point = point;

exports.polygon = polygon;

exports.polyline = polyline;

exports.pointconvert = pointconvert;

exports.util = util;

exports.util.config2Entity = _config2Entity.config2Entity;

exports.util.getDefaultContextMenu = _defaultContextMenu.getDefaultContextMenu;

exports.measure = measure;

exports.tileset = tileset;

exports.log = marslog;

//=====================视频融合 相关  =====================
exports.video = {};

//视频融合（投射3D，贴物体表面）

exports.video.Video3D = _Video3D.Video3D;

//视频融合（投射2D平面） 

exports.video.Video2D = _Video2D.Video2D;

//打印信息
util.printVersion();

//===========兼容v2.2之前旧版本处理,非升级用户可删除下面代码 ============= 
exports.analysi.TerrainExcavate = _TerrainClip.TerrainClip; //1.9.0
exports.analysi.TerrainFlood = _FloodByTerrain.FloodByTerrain; //1.9.0
exports.analysi.VideoShed3D = _Video3D.Video3D; //1.9.0
exports.VideoShed3D = _Video3D.Video3D; //1.9.0

exports.util.terrainPolyline = polyline.computeSurfaceLine; //1.9.1
exports.point.formatPositon = point.formatPosition; //1.9.1  单词错误改正

exports.util.hasTerrain = layer.hasTerrain; //1.9.3
exports.util.getEllipsoidTerrain = layer.getEllipsoidTerrain; //1.9.3
exports.util.getTerrainProvider = layer.getTerrainProvider; //1.9.3

//移动了方法
exports.point.computePolygonHeightRange = polygon.getHeightRange; //2.0.2
exports.point.updateHeightForClampToGround = point.setPositionSurfaceHeight; //2.0.2 
exports.point.terrainPolyline = polyline.computeSurfaceLine; //2.0.2 
exports.util.getLinkedPointList = polyline.getLinkedPointList; //2.0.2 

exports.util.getLength = exports.measure.getLength; //2.1.0 
exports.util.getArea = exports.measure.getArea; //2.1.0 
exports.util.getAreaOfTriangle = exports.measure.getAreaOfTriangle; //2.1.0 
exports.util.getAngle = exports.measure.getAngle; //2.1.0 

exports.scene.RainFS = _Rain2.default; //2.2.0 
exports.scene.SnowFS = _Snow2.default; //2.2.0 
exports.draw.util = Attr; //2.2.0 
exports.draw.event = {
  DrawStart: _MarsClass.eventType.drawStart,
  DrawAddPoint: _MarsClass.eventType.drawAddPoint,
  DrawRemovePoint: _MarsClass.eventType.drawRemovePoint,
  DrawMouseMove: _MarsClass.eventType.drawMouseMove,
  DrawCreated: _MarsClass.eventType.drawCreated,
  EditStart: _MarsClass.eventType.editStart,
  EditMouseMoveStart: _MarsClass.eventType.editMouseDown,
  EditMouseMove: _MarsClass.eventType.editMouseMove,
  EditMovePoint: _MarsClass.eventType.editMovePoint,
  EditRemovePoint: _MarsClass.eventType.editRemovePoint,
  EditStop: _MarsClass.eventType.editStop,
  Delete: _MarsClass.eventType.delete,
  LoadEnd: _MarsClass.eventType.load
}; //2.2.0 
exports.analysi.HeightCounterByTerrain = _ContourLine.ContourLine; //2.2.0

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FlashingEntity = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.loopArrayForFun = loopArrayForFun;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//定时闪烁高亮Entity（点、线、面） 
var FlashingEntity = exports.FlashingEntity = function () {
    //========== 构造方法 ========== 
    function FlashingEntity(options) {
        _classCallCheck(this, FlashingEntity);

        this.color = Cesium.Color.YELLOW.withAlpha(0);
    }

    //========== 方法 ========== 


    _createClass(FlashingEntity, [{
        key: "highlight",
        value: function highlight(entitys, opts) {
            var that = this;
            this.unHighlight();

            opts = opts || {};

            this.entitys = entitys;
            this.maxAlpha = Cesium.defaultValue(opts.maxAlpha, 0.3);
            this.time = Cesium.defaultValue(opts.time, 10); //播放时长 
            this.color = Cesium.defaultValue(opts.color, Cesium.Color.YELLOW);
            this.color = this.color.withAlpha(this.maxAlpha);
            this.onEnd = opts.onEnd;

            this._startTime();

            loopArrayForFun(entitys, function (entity) {
                if (entity.polygon) {
                    entity.polygon.material_bak = entity.polygon.material;
                    entity.polygon.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                        return that.color;
                    }, false));
                }
                if (entity.polyline) {
                    entity.polyline.material_bak = entity.polyline.material;
                    entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                        return that.color;
                    }, false));
                }
                if (entity.ellipse) {
                    entity.ellipse.material_bak = entity.ellipse.material;
                    entity.ellipse.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                        return that.color;
                    }, false));
                }
                if (entity.rectangle) {
                    entity.rectangle.material_bak = entity.rectangle.material;
                    entity.rectangle.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                        return that.color;
                    }, false));
                }
                if (entity.wall) {
                    entity.wall.material_bak = entity.wall.material;
                    entity.wall.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                        return that.color;
                    }, false));
                }

                if (entity.point) {
                    entity.point.color_bak = entity.point.color;
                    entity.point.color = that.color;
                }
                if (entity.billboard) {
                    entity.billboard.color_bak = entity.billboard.color;
                    entity.billboard.color = that.color;
                }
                if (entity.model) {
                    entity.model.color_bak = entity.model.color;
                    entity.model.color = that.color;
                }
                if (entity.label) {
                    entity.label.fillColor_bak = entity.label.fillColor;
                    entity.label.fillColor = that.color;
                }
            });
            return this;
        }
    }, {
        key: "unHighlight",
        value: function unHighlight() {
            this._stopTime();

            if (this.entitys) {
                loopArrayForFun(this.entitys, function (entity) {
                    if (entity.polygon) {
                        if (entity.polygon.material_bak) entity.polygon.material = entity.polygon.material_bak;
                    }
                    if (entity.polyline) {
                        if (entity.polyline.material_bak) entity.polyline.material = entity.polyline.material_bak;
                    }
                    if (entity.ellipse) {
                        if (entity.ellipse.material_bak) entity.ellipse.material = entity.ellipse.material_bak;
                    }
                    if (entity.rectangle) {
                        if (entity.rectangle.material_bak) entity.rectangle.material = entity.rectangle.material_bak;
                    }
                    if (entity.wall) {
                        if (entity.wall.material_bak) entity.wall.material = entity.wall.material_bak;
                    }

                    if (entity.point) {
                        if (entity.point.color_bak) entity.point.color = entity.point.color_bak;
                    }
                    if (entity.billboard) {
                        if (entity.billboard.color_bak) entity.billboard.color = entity.billboard.color_bak;
                    }
                    if (entity.model) {
                        if (entity.model.color_bak) entity.model.color = entity.model.color_bak;
                    }
                    if (entity.label) {
                        if (entity.label.fillColor_bak) entity.label.fillColor = entity.label.fillColor_bak;
                    }
                });
                if (this.onEnd) this.onEnd(this.entitys);
                delete this.entitys;
            }
            return this;
        }
    }, {
        key: "_updateClr",
        value: function _updateClr() {
            var that = this;
            if (this.entitys) {
                loopArrayForFun(this.entitys, function (entity) {
                    if (entity.point) {
                        entity.point.color = that.color;
                    }
                    if (entity.billboard) {
                        entity.billboard.color = that.color;
                    }
                    if (entity.model) {
                        entity.model.color = that.color;
                    }
                    if (entity.label) {
                        entity.label.fillColor = that.color;
                    }
                });
            }
        }
    }, {
        key: "_startTime",
        value: function _startTime() {
            var _this = this;

            var time = 30;
            var setp = this.maxAlpha / time;

            var alpha = 0;
            this.interVal = setInterval(function () {
                alpha += setp;
                if (alpha > _this.maxAlpha) alpha = 0;
                _this.color = _this.color.withAlpha(alpha);
                _this._updateClr();
            }, time);

            this.timeEndVal = setTimeout(function () {
                _this.unHighlight();
            }, this.time * 1000);
        }
    }, {
        key: "_stopTime",
        value: function _stopTime() {
            clearInterval(this.interVal);
            clearTimeout(this.timeEndVal);
        }
    }]);

    return FlashingEntity;
}();

//循环执行数组或对象 
// 调用示例 loopArrayForFun(ArrOrObj, function (entity) {
//    drawControl.deleteEntity(entity);
// }); 


function loopArrayForFun(ArrOrObj, callback) {
    if (ArrOrObj == null) return;
    if (haoutil.isutil.isArray(ArrOrObj)) {
        var arr = [];
        for (var i = 0, len = ArrOrObj.length; i < len; i++) {
            arr.push(callback(ArrOrObj[i]));
        }
        return arr;
    } else {
        return callback(ArrOrObj);
    }
}

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    vec2 st = repeat * materialInput.st;\r\n    vec4 colorImage = texture2D(image, vec2(fract((axisY?st.t:st.s) - time), st.t));\r\n    if(color.a == 0.0)\r\n    {\r\n        material.alpha = colorImage.a;\r\n        material.diffuse = colorImage.rgb; \r\n    }\r\n    else\r\n    {\r\n        material.alpha = colorImage.a * color.a;\r\n        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \r\n    }\r\n    return material;\r\n}"

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = "//2个图片的叠加融合\r\nczm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    vec2 st = repeat * materialInput.st;\r\n    vec4 colorImage = texture2D(image, vec2(fract((axisY?st.t:st.s) - time), st.t));\r\n    if(color.a == 0.0)\r\n    {\r\n        material.alpha = colorImage.a;\r\n        material.diffuse = colorImage.rgb; \r\n    }\r\n    else\r\n    {\r\n        material.alpha = colorImage.a * color.a;\r\n        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \r\n    }\r\n    vec4 colorBG = texture2D(image2,materialInput.st);\r\n    if(colorBG.a>0.5){\r\n        material.diffuse = bgColor.rgb;\r\n    }\r\n    return material;\r\n}"

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    material.diffuse = 1.5 * color.rgb;\r\n    vec2 st = materialInput.st;\r\n    vec3 str = materialInput.str;\r\n    float dis = distance(st, vec2(0.5, 0.5));\r\n    float per = fract(time);\r\n    if(abs(str.z)>0.001){\r\n        discard;\r\n    }\r\n    if(dis >0.5){\r\n        discard;\r\n    }else {\r\n        float perDis = 0.5/count;\r\n        float disNum;\r\n        float bl = .0;\r\n        for(int i=0;i<=999;i++){\r\n            if(float(i)<=count){\r\n                disNum = perDis*float(i) - dis + per/count;\r\n                if(disNum>0.0){\r\n                    if(disNum<perDis){\r\n                        bl = 1.0-disNum/perDis;\r\n                    }\r\n                    else if(disNum-perDis<perDis){\r\n                        bl = 1.0 - abs(1.0-disNum/perDis);\r\n                    }\r\n                    material.alpha = pow(bl,gradient);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return material;\r\n}"

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GroupLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _BaseLayer2 = __webpack_require__(15);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupLayer = exports.GroupLayer = function (_BaseLayer) {
    _inherits(GroupLayer, _BaseLayer);

    function GroupLayer() {
        _classCallCheck(this, GroupLayer);

        return _possibleConstructorReturn(this, (GroupLayer.__proto__ || Object.getPrototypeOf(GroupLayer)).apply(this, arguments));
    }

    _createClass(GroupLayer, [{
        key: "create",
        value: function create() {
            this._layers = this.options._layers;
            var arr = this._layers;
            for (var i = 0, len = arr.length; i < len; i++) {
                this.hasOpacity = arr[i].hasOpacity;
                this.hasZIndex = arr[i].hasZIndex;
            }
        }
        //添加 

    }, {
        key: "add",
        value: function add() {
            this._visible = true;

            var arr = this._layers;
            for (var i = 0, len = arr.length; i < len; i++) {
                arr[i].visible = true;
            }
            _get(GroupLayer.prototype.__proto__ || Object.getPrototypeOf(GroupLayer.prototype), "add", this).call(this);
        }
        //移除

    }, {
        key: "remove",
        value: function remove() {
            this._visible = false;

            var arr = this._layers;
            for (var i = 0, len = arr.length; i < len; i++) {
                arr[i].visible = false;
            }
            _get(GroupLayer.prototype.__proto__ || Object.getPrototypeOf(GroupLayer.prototype), "remove", this).call(this);
        }
        //定位至数据区域

    }, {
        key: "centerAt",
        value: function centerAt(duration) {
            var arr = this._layers;
            for (var i = 0, len = arr.length; i < len; i++) {
                arr[i].centerAt(duration);
            }
        }
        //设置透明度

    }, {
        key: "setOpacity",
        value: function setOpacity(value) {
            var arr = this._layers;
            for (var i = 0, len = arr.length; i < len; i++) {
                if (!arr[i].hasOpacity) continue;
                arr[i].setOpacity(value);
            }
        }
    }]);

    return GroupLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SuperMapImgLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TileLayer2 = __webpack_require__(41);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuperMapImgLayer = exports.SuperMapImgLayer = function (_TileLayer) {
    _inherits(SuperMapImgLayer, _TileLayer);

    function SuperMapImgLayer() {
        _classCallCheck(this, SuperMapImgLayer);

        return _possibleConstructorReturn(this, (SuperMapImgLayer.__proto__ || Object.getPrototypeOf(SuperMapImgLayer)).apply(this, arguments));
    }

    _createClass(SuperMapImgLayer, [{
        key: "add",
        value: function add() {
            _get(SuperMapImgLayer.prototype.__proto__ || Object.getPrototypeOf(SuperMapImgLayer.prototype), "add", this).call(this);

            var options = this.options;
            if (Cesium.defined(options.transparentBackColorTolerance)) {
                this.layer.transparentBackColorTolerance = options.transparentBackColorTolerance; //去黑边
            }
        }
    }]);

    return SuperMapImgLayer;
}(_TileLayer2.TileLayer);

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GraticuleLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _BaseLayer2 = __webpack_require__(15);

var _GraticuleProvider = __webpack_require__(101);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GraticuleLayer = exports.GraticuleLayer = function (_BaseLayer) {
    _inherits(GraticuleLayer, _BaseLayer);

    function GraticuleLayer() {
        _classCallCheck(this, GraticuleLayer);

        return _possibleConstructorReturn(this, (GraticuleLayer.__proto__ || Object.getPrototypeOf(GraticuleLayer)).apply(this, arguments));
    }

    _createClass(GraticuleLayer, [{
        key: 'add',


        //添加 
        value: function add() {
            if (this.layer == null) {
                this.initData();
            }
            this.layer.setVisible(true);
            _get(GraticuleLayer.prototype.__proto__ || Object.getPrototypeOf(GraticuleLayer.prototype), 'add', this).call(this);
        }
        //移除

    }, {
        key: 'remove',
        value: function remove() {
            if (this.layer == null) return;

            this.layer.setVisible(false);
            _get(GraticuleLayer.prototype.__proto__ || Object.getPrototypeOf(GraticuleLayer.prototype), 'remove', this).call(this);
        }
    }, {
        key: 'initData',
        value: function initData() {
            this.layer = new _GraticuleProvider.GraticuleProvider({
                scene: this.viewer.scene,
                numLines: 10
            });
            this.fire(_MarsClass.eventType.load, { layer: this.layer });
        }
    }, {
        key: 'layer',
        get: function get() {
            return this.layer;
        }
    }]);

    return GraticuleLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GraticuleProvider = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var mins = [Cesium.Math.toRadians(0.05), Cesium.Math.toRadians(0.1), Cesium.Math.toRadians(0.2), Cesium.Math.toRadians(0.5), Cesium.Math.toRadians(1.0), Cesium.Math.toRadians(2.0), Cesium.Math.toRadians(5.0), Cesium.Math.toRadians(10.0)];

function gridPrecision(dDeg) {
    if (dDeg < 0.01) return 2;
    if (dDeg < 0.1) return 1;
    if (dDeg < 1) return 0;
    return 0;
}

function GraticuleProvider(options) {
    this._tilingScheme = options.tilingScheme || new Cesium.GeographicTilingScheme();

    this._color = options.color || new Cesium.Color(1.0, 1.0, 1.0, 0.4);

    this._tileWidth = options.tileWidth || 256;
    this._tileHeight = options.tileHeight || 256;

    this._ready = true;

    // default to decimal intervals
    this._sexagesimal = options.sexagesimal || false;
    this._numLines = options.numLines || 50;

    this._scene = options.scene;
    this._labels = new Cesium.LabelCollection();
    scene.primitives.add(this._labels);
    this._polylines = new Cesium.PolylineCollection();
    scene.primitives.add(this._polylines);
    this._ellipsoid = scene.globe.ellipsoid;

    var canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    this._canvas = canvas;

    var that = this;
    scene.camera.moveEnd.addEventListener(function () {
        if (!that._show) return;

        that._polylines.removeAll();
        that._labels.removeAll();
        that._currentExtent = null;
        that._drawGrid(that._getExtentView());
    });
    scene.imageryLayers.addImageryProvider(this);
};

var definePropertyWorks = function () {
    try {
        return 'x' in Object.defineProperty({}, 'x', {});
    } catch (e) {
        return false;
    }
}();

/**
 * Defines properties on an object, using Object.defineProperties if available,
 * otherwise returns the object unchanged.  This function should be used in
 * setup code to prevent errors from completely halting JavaScript execution
 * in legacy browsers.
 *
 * @private
 *
 * @exports defineProperties
 */
var defineProperties = Object.defineProperties;
if (!definePropertyWorks || !defineProperties) {
    defineProperties = function defineProperties(o) {
        return o;
    };
}

Object.defineProperties(GraticuleProvider.prototype, {
    url: {
        get: function get() {
            return undefined;
        }
    },

    proxy: {
        get: function get() {
            return undefined;
        }
    },

    tileWidth: {
        get: function get() {
            return this._tileWidth;
        }
    },

    tileHeight: {
        get: function get() {
            return this._tileHeight;
        }
    },

    maximumLevel: {
        get: function get() {
            return 18;
        }
    },

    minimumLevel: {
        get: function get() {
            return 0;
        }
    },
    tilingScheme: {
        get: function get() {
            return this._tilingScheme;
        }
    },
    rectangle: {
        get: function get() {
            return this._tilingScheme.rectangle;
        }
    },
    tileDiscardPolicy: {
        get: function get() {
            return undefined;
        }
    },
    errorEvent: {
        get: function get() {
            return this._errorEvent;
        }
    },
    ready: {
        get: function get() {
            return this._ready;
        }
    },
    credit: {
        get: function get() {
            return this._credit;
        }
    },
    hasAlphaChannel: {
        get: function get() {
            return true;
        }
    }
});

GraticuleProvider.prototype.makeLabel = function (lng, lat, text, top, color) {
    this._labels.add({
        position: this._ellipsoid.cartographicToCartesian(new Cesium.Cartographic(lng, lat, 10.0)),
        text: text,
        //font: 'normal',
        //style: Cesium.LabelStyle.FILL,
        //fillColor: 'white',
        //outlineColor: 'white',
        font: 'normal small-caps normal 16px 楷体',
        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
        fillColor: Cesium.Color.AZURE,
        outlineColor: Cesium.Color.BLACK,
        outlineWidth: 2,

        pixelOffset: new Cesium.Cartesian2(5, top ? 5 : -5),
        eyeOffset: Cesium.Cartesian3.ZERO,
        horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
        verticalOrigin: top ? Cesium.VerticalOrigin.BOTTOM : Cesium.VerticalOrigin.TOP,
        scale: 1.0
    });
};

GraticuleProvider.prototype._drawGrid = function (extent) {

    if (this._currentExtent && this._currentExtent.equals(extent)) {
        return;
    }
    this._currentExtent = extent;

    this._polylines.removeAll();
    this._labels.removeAll();

    var minPixel = 0;
    var maxPixel = this._canvasSize;

    var dLat = 0,
        dLng = 0,
        index;
    // get the nearest to the calculated value
    for (index = 0; index < mins.length && dLat < (extent.north - extent.south) / 10; index++) {
        dLat = mins[index];
    }
    for (index = 0; index < mins.length && dLng < (extent.east - extent.west) / 10; index++) {
        dLng = mins[index];
    }

    // round iteration limits to the computed grid interval
    var minLng = (extent.west < 0 ? Math.ceil(extent.west / dLng) : Math.floor(extent.west / dLng)) * dLng;
    var minLat = (extent.south < 0 ? Math.ceil(extent.south / dLat) : Math.floor(extent.south / dLat)) * dLat;
    var maxLng = (extent.east < 0 ? Math.ceil(extent.east / dLat) : Math.floor(extent.east / dLat)) * dLat;
    var maxLat = (extent.north < 0 ? Math.ceil(extent.north / dLng) : Math.floor(extent.north / dLng)) * dLng;

    // extend to make sure we cover for non refresh of tiles
    minLng = Math.max(minLng - 2 * dLng, -Math.PI);
    maxLng = Math.min(maxLng + 2 * dLng, Math.PI);
    minLat = Math.max(minLat - 2 * dLat, -Math.PI / 2);
    maxLat = Math.min(maxLat + 2 * dLng, Math.PI / 2);

    var ellipsoid = this._ellipsoid;
    var lat,
        lng,
        granularity = Cesium.Math.toRadians(1);

    // labels positions
    var latitudeText = minLat + Math.floor((maxLat - minLat) / dLat / 2) * dLat;
    for (lng = minLng; lng < maxLng; lng += dLng) {
        // draw meridian
        var path = [];
        for (lat = minLat; lat < maxLat; lat += granularity) {
            path.push(new Cesium.Cartographic(lng, lat));
        }
        path.push(new Cesium.Cartographic(lng, maxLat));
        this._polylines.add({
            positions: ellipsoid.cartographicArrayToCartesianArray(path),
            width: 1
        });
        var degLng = Cesium.Math.toDegrees(lng);
        this.makeLabel(lng, latitudeText, this._sexagesimal ? this._decToSex(degLng) : degLng.toFixed(gridPrecision(dLng)), false);
    }

    // lats
    var longitudeText = minLng + Math.floor((maxLng - minLng) / dLng / 2) * dLng;
    for (lat = minLat; lat < maxLat; lat += dLat) {
        // draw parallels
        var path = [];
        for (lng = minLng; lng < maxLng; lng += granularity) {
            path.push(new Cesium.Cartographic(lng, lat));
        }
        path.push(new Cesium.Cartographic(maxLng, lat));
        this._polylines.add({
            positions: ellipsoid.cartographicArrayToCartesianArray(path),
            width: 1
        });
        var degLat = Cesium.Math.toDegrees(lat);
        this.makeLabel(longitudeText, lat, this._sexagesimal ? this._decToSex(degLat) : degLat.toFixed(gridPrecision(dLat)), true);
    }
};

GraticuleProvider.prototype.requestImage = function (x, y, level) {

    if (this._show) {
        this._drawGrid(this._getExtentView());
    }

    return this._canvas;
};

GraticuleProvider.prototype.setVisible = function (visible) {
    this._show = visible;
    if (!visible) {
        this._polylines.removeAll();
        this._labels.removeAll();
    } else {
        this._currentExtent = null;
        this._drawGrid(this._getExtentView());
    }
};

GraticuleProvider.prototype.isVisible = function () {
    return this._show;
};

GraticuleProvider.prototype._decToSex = function (d) {
    var degs = Math.floor(d);
    var mins = ((Math.abs(d) - degs) * 60.0).toFixed(2);
    if (mins == "60.00") {
        degs += 1.0;mins = "0.00";
    }
    return [degs, ":", mins].join('');
};

GraticuleProvider.prototype._getExtentView = function () {
    var camera = this._scene.camera;
    var canvas = this._scene.canvas;
    var corners = [camera.pickEllipsoid(new Cesium.Cartesian2(0, 0), this._ellipsoid), camera.pickEllipsoid(new Cesium.Cartesian2(canvas.width, 0), this._ellipsoid), camera.pickEllipsoid(new Cesium.Cartesian2(0, canvas.height), this._ellipsoid), camera.pickEllipsoid(new Cesium.Cartesian2(canvas.width, canvas.height), this._ellipsoid)];
    for (var index = 0; index < 4; index++) {
        if (corners[index] === undefined) {
            return Cesium.Rectangle.MAX_VALUE;
        }
    }
    return Cesium.Rectangle.fromCartographicArray(this._ellipsoid.cartesianArrayToCartographicArray(corners));
};

exports.GraticuleProvider = GraticuleProvider;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FeatureGridLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _TileLayer2 = __webpack_require__(41);

var _config2Entity = __webpack_require__(32);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FeatureGridLayer = exports.FeatureGridLayer = function (_TileLayer) {
    _inherits(FeatureGridLayer, _TileLayer);

    //========== 构造方法 ========== 
    function FeatureGridLayer(viewer, options) {
        _classCallCheck(this, FeatureGridLayer);

        var _this = _possibleConstructorReturn(this, (FeatureGridLayer.__proto__ || Object.getPrototypeOf(FeatureGridLayer)).call(this, viewer, options));

        _this.hasOpacity = false;
        return _this;
    }
    //========== 对外属性 ========== 


    _createClass(FeatureGridLayer, [{
        key: "create",
        value: function create() {
            var _this2 = this;

            this.dataSource = new Cesium.CustomDataSource(); //用于entity
            this._bindClustering(this.options.clustering);

            this.primitives = new Cesium.PrimitiveCollection(); //用于primitive

            this.options.id = Cesium.defaultValue(this.options.id, new Date().getTime());

            var that = this;
            this.options.type_new = "custom_featuregrid";
            this.options.addImageryCache = function (opts) {
                return that._addImageryCache(opts);
            };
            this.options.removeImageryCache = function (opts) {
                return that._removeImageryCache(opts);
            };
            this.options.removeAllImageryCache = function (opts) {
                return that._removeAllImageryCache(opts);
            };

            if (Cesium.defined(this.options.minimumLevel)) this.options.minimumTerrainLevel = this.options.minimumLevel;
            if (Cesium.defined(this.options.maximumLevel)) this.options.maximumTerrainLevel = this.options.maximumLevel;

            //是建筑物单体化时
            if (this.options.dth) {
                var dthEvent = (0, _config2Entity.createDthEntity)(this.viewer, this.options.dth);

                if (this.options.dth.type == "click") {
                    this.on(_MarsClass.eventType.click, function (e) {
                        dthEvent.mouseover(e.sourceTarget);
                    });
                    this.viewer.mars.on(_MarsClass.eventType.clickMap, function (e) {
                        if (!_this2._visible) return;
                        dthEvent.mouseout();
                    });
                } else {
                    this.on(_MarsClass.eventType.mouseOver, function (e) {
                        dthEvent.mouseover(e.sourceTarget);
                    });
                    this.on(_MarsClass.eventType.mouseOut, function (e) {
                        dthEvent.mouseout();
                    });
                }
                this.dthEvent = dthEvent;
            }

            var config = this.options;
            if (config.symbol && config.symbol.styleOptions) {
                var style = config.symbol.styleOptions;
                if (Cesium.defined(style.clampToGround)) {
                    config.clampToGround = style.clampToGround;
                }
                if (Cesium.defined(style.color)) {
                    var color = Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 0.5)));
                    config.fill = color;
                }
                if (Cesium.defined(style.outlineColor)) {
                    var outlineColor = Cesium.Color.fromCssColorString(style.outlineColor || "#FFFFFF").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
                    config.stroke = outlineColor;
                }
                if (Cesium.defined(style.outlineWidth)) {
                    config.strokeWidth = style.outlineWidth;
                }
                this.options = config;
            }
        }
    }, {
        key: "getLength",
        value: function getLength() {
            return this.primitives.length + this.dataSource.entities.values.length;
        }
    }, {
        key: "addEx",
        value: function addEx() {
            this.viewer.dataSources.add(this.dataSource);
            this.viewer.scene.primitives.add(this.primitives);
        }
    }, {
        key: "removeEx",
        value: function removeEx() {
            //是建筑物单体化时
            if (this.dthEvent) {
                this.dthEvent.mouseout();
            }
            this.viewer.dataSources.remove(this.dataSource);
            this.viewer.scene.primitives.remove(this.primitives);
        }
    }, {
        key: "_addImageryCache",
        value: function _addImageryCache(opts) {}
    }, {
        key: "_removeImageryCache",
        value: function _removeImageryCache(opts) {}
    }, {
        key: "_removeAllImageryCache",
        value: function _removeAllImageryCache() {}
        //聚合处理

    }, {
        key: "_bindClustering",
        value: function _bindClustering(options) {
            options = options || { enabled: false };

            this.dataSource.clustering.enabled = Cesium.defaultValue(options.enabled, false);
            this.dataSource.clustering.pixelRange = Cesium.defaultValue(options.pixelRange, 20); //多少像素矩形范围内聚合

            //一些属性      
            var color = Cesium.Color.fromCssColorString(Cesium.defaultValue(options.color, "#00ff00")).withAlpha(Cesium.defaultValue(options.opacity, 1.0));
            var size = Cesium.defaultValue(options.pixelSize, 48);
            var heightReference = Cesium.defaultValue(options.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);
            if (options.clampToGround) heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;

            var singleDigitPins = {};
            var pinBuilder = new Cesium.PinBuilder();
            this.dataSource.clustering.clusterEvent.addEventListener(function (clusteredEntities, cluster) {
                var count = clusteredEntities.length;

                cluster.label.show = false;
                cluster.billboard.show = true;
                cluster.billboard.id = cluster.label.id;
                cluster.billboard.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
                cluster.billboard.heightReference = heightReference; //贴地

                if (!singleDigitPins[count]) {
                    singleDigitPins[count] = pinBuilder.fromText(count, color, size).toDataURL();
                }
                cluster.billboard.image = singleDigitPins[count];
            });
        }
    }, {
        key: "layer",
        get: function get() {
            return this.dataSource;
        }
    }]);

    return FeatureGridLayer;
}(_TileLayer2.TileLayer);

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.POILayer = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(8);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _CustomFeatureGridLayer = __webpack_require__(42);

var _Attr = __webpack_require__(35);

var _Attr2 = __webpack_require__(34);

var _Attr3 = __webpack_require__(12);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var POILayer = exports.POILayer = function (_CustomFeatureGridLay) {
    _inherits(POILayer, _CustomFeatureGridLay);

    //========== 构造方法 ========== 
    function POILayer(viewer, options) {
        _classCallCheck(this, POILayer);

        var _this = _possibleConstructorReturn(this, (POILayer.__proto__ || Object.getPrototypeOf(POILayer)).call(this, viewer, options));

        _this._key_index = 0;
        _this._keys = _this.options.key || ["ae29a37307840c7ae4a785ac905927e0", //2020-6-18
        "888a52a74c55ca47abe6c55ab3661d11", "0bc2903efcb3b67ebf1452d2f664a238", "0df8f6f984adc49fca5b7b1108664da2", "72f75689dff38a781055e68843474751"];
        return _this;
    }
    //========== 对外属性 ========== 

    _createClass(POILayer, [{
        key: 'getKey',
        value: function getKey() {
            var thisidx = this._key_index++ % this._keys.length;
            return this._keys[thisidx];
        }

        //获取网格内的数据，callback为回调方法，参数传数据数组 

    }, {
        key: 'getDataForGrid',
        value: function getDataForGrid(opts, callback) {
            var jwd1 = pointconvert.wgs2gcj([opts.rectangle.xmin, opts.rectangle.ymax]); //加偏
            var jwd2 = pointconvert.wgs2gcj([opts.rectangle.xmax, opts.rectangle.ymin]); //加偏
            var polygon = jwd1[0] + "," + jwd1[1] + "|" + jwd2[0] + "," + jwd2[1];

            var filter = this.options.filter || {};
            filter.output = "json";
            filter.key = this.getKey();
            filter.polygon = polygon;
            if (!filter.offset) filter.offset = 25;
            if (!filter.types) filter.types = "120000|130000|190000";

            //查询POI服务
            var that = this;
            _zepto.zepto.ajax({
                url: 'https://restapi.amap.com/v3/place/polygon',
                type: "get",
                dataType: "jsonp",
                timeout: 5000,
                data: filter,
                success: function success(data) {
                    if (data.infocode !== "10000") {
                        marslog.log("POI 请求失败(" + data.infocode + ")：" + data.info);
                        return;
                    }
                    var arrdata = data.pois;
                    callback(arrdata);
                },
                error: function error(data) {
                    marslog.log("POI 请求出错(" + data.status + ")：" + data.statusText);
                }
            });
        }
        //根据数据创造entity

    }, {
        key: 'createEntity',
        value: function createEntity(opts, attributes) {
            var inthtml = "<div>名称：" + attributes.name + "</div>" + "<div>地址：" + attributes.address + "</div>" + "<div>区域：" + attributes.pname + attributes.cityname + attributes.adname + "</div>" + "<div>类别：" + attributes.type + "</div>";

            var arrjwd = attributes.location.split(",");
            arrjwd = pointconvert.gcj2wgs(arrjwd); //纠偏
            var lnglat = this.viewer.mars.point2map({ x: arrjwd[0], y: arrjwd[1] });

            var entityOptions = {
                name: attributes.name,
                position: Cesium.Cartesian3.fromDegrees(lnglat.x, lnglat.y, this.options.height || 3),
                popup: {
                    html: inthtml,
                    anchor: [0, -15]
                },
                properties: attributes
            };

            var symbol = this.options.symbol;
            if (symbol) {
                var styleOpt = symbol.styleOptions;
                if (symbol.styleField) {
                    //存在多个symbol，按styleField进行分类
                    var styleFieldVal = attr[symbol.styleField];
                    var styleOptField = symbol.styleFieldOptions[styleFieldVal];
                    if (styleOptField != null) {
                        // styleOpt = clone(styleOpt);
                        styleOpt = _extends({}, styleOpt, styleOptField);
                    }
                }
                styleOpt = styleOpt || {};

                if (styleOpt.image) {
                    entityOptions.billboard = (0, _Attr2.style2Entity)(styleOpt);
                    entityOptions.billboard.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                } else {
                    entityOptions.point = (0, _Attr.style2Entity)(styleOpt);
                }

                //加上文字标签 
                if (styleOpt.label) {
                    entityOptions.label = (0, _Attr3.style2Entity)(styleOpt.label);
                    entityOptions.label.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                    entityOptions.label.text = attributes.name;
                }
            } else {
                //无配置时的默认值
                entityOptions.point = {
                    color: Cesium.Color.fromCssColorString("#3388ff"),
                    pixelSize: 10,
                    outlineColor: Cesium.Color.fromCssColorString("#ffffff"),
                    outlineWidth: 2,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                    scaleByDistance: new Cesium.NearFarScalar(1000, 1, 20000, 0.5)
                };
                entityOptions.label = {
                    text: attributes.name,
                    font: 'normal small-caps normal 16px 楷体',
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    fillColor: Cesium.Color.AZURE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    pixelOffset: new Cesium.Cartesian2(0, -15), //偏移量   
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, //是地形上方的高度 
                    scaleByDistance: new Cesium.NearFarScalar(1000, 1, 5000, 0.8),
                    distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0.0, 5000)
                };
            }

            var entity = this.dataSource.entities.add(entityOptions);
            return entity;
        }
    }]);

    return POILayer;
}(_CustomFeatureGridLayer.CustomFeatureGridLayer);

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WFSLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _CustomFeatureGridLayer = __webpack_require__(42);

var _util = __webpack_require__(1);

var _zepto = __webpack_require__(8);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WFSLayer = exports.WFSLayer = function (_CustomFeatureGridLay) {
    _inherits(WFSLayer, _CustomFeatureGridLay);

    function WFSLayer() {
        _classCallCheck(this, WFSLayer);

        return _possibleConstructorReturn(this, (WFSLayer.__proto__ || Object.getPrototypeOf(WFSLayer)).apply(this, arguments));
    }

    _createClass(WFSLayer, [{
        key: 'getDataForGrid',

        //获取网格内的数据，callback为回调方法，参数传数据数组 
        value: function getDataForGrid(opts, callback) {
            var that = this;

            //请求的wfs参数
            var parameters = {
                service: "WFS",
                request: "GetFeature",
                typeName: this.options.layer || this.options.typeName,
                version: "1.0.0",
                outputFormat: "application/json",
                bbox: opts.rectangle.xmin + "," + opts.rectangle.ymin + "," + opts.rectangle.xmax + "," + opts.rectangle.ymax
            };

            //其他可选参数
            if (Cesium.defined(this.options.parameters)) {
                for (var key in this.options.parameters) {
                    parameters[key] = this.options.parameters[key];
                }
            }

            _zepto.zepto.ajax({
                url: this.options.url,
                type: "get",
                data: parameters,
                success: function success(featureCollection) {
                    if (!that._visible || !that._cacheGrid[opts.key]) {
                        return; //异步请求结束时,如果已经卸载了网格就直接跳出。
                    }

                    if (featureCollection == undefined || featureCollection == null) {
                        return; //数据为空
                    }

                    if (featureCollection.type == "Feature") featureCollection = { "type": "FeatureCollection", "features": [featureCollection] };

                    callback(featureCollection.features);
                },
                error: function error(data) {
                    marslog.warn("请求出错(" + data.status + ")：" + data.statusText);
                }
            });
        }
        //根据数据创造entity

    }, {
        key: 'createEntity',
        value: function createEntity(opts, item, callback) {
            if (this.options.dth && this.options.dth.buffer > 0) {
                //是建筑物单体化时,缓冲扩大点范围
                item = (0, _util.buffer)(item, this.options.dth.buffer);
            }

            var that = this;
            var dataSource = Cesium.GeoJsonDataSource.load(item, this.options);
            dataSource.then(function (dataSource) {
                if (that.checkHasBreak[opts.key]) {
                    return; //异步请求结束时，如果已经卸载了网格就直接跳出。
                }

                if (dataSource.entities.values.length == 0) return null;
                var entity = dataSource.entities.values[0];
                entity.entityCollection.remove(entity); //从原有的集合中删除  

                entity._id = that.options.id + "_" + opts.key + "_" + entity.id;

                that._addEntity(entity, callback);
            }).otherwise(function (error) {
                that.showError("服务出错", error);
            });

            return null;
        }
        //更新entity，并添加到地图上

    }, {
        key: '_addEntity',
        value: function _addEntity(entity, callback) {
            // this.dataSource.entities.removeById(entity._id); 
            // if (this.dataSource.entities.contains(entity))return          
            if (this.dataSource.entities.getById(entity._id)) return;

            this.dataSource.entities.add(entity); //加入到当前图层集合图层中

            //根据config配置，更新entitys  
            this.config2Entity(entity);

            callback(entity);
        }
    }]);

    return WFSLayer;
}(_CustomFeatureGridLayer.CustomFeatureGridLayer);

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WaterLayer = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _point = __webpack_require__(2);

var _BaseLayer2 = __webpack_require__(15);

var _zepto = __webpack_require__(8);

var _Attr = __webpack_require__(21);

var _water = __webpack_require__(55);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WaterLayer = exports.WaterLayer = function (_BaseLayer) {
    _inherits(WaterLayer, _BaseLayer);

    function WaterLayer() {
        _classCallCheck(this, WaterLayer);

        return _possibleConstructorReturn(this, (WaterLayer.__proto__ || Object.getPrototypeOf(WaterLayer)).apply(this, arguments));
    }

    _createClass(WaterLayer, [{
        key: 'create',
        value: function create() {}
        //添加 

    }, {
        key: 'add',
        value: function add() {
            this.primitives = new Cesium.PrimitiveCollection();
            this.viewer.scene.primitives.add(this.primitives);

            if (this.arrData) {
                this.createWater();
            } else {
                this.queryData();
            }
            _get(WaterLayer.prototype.__proto__ || Object.getPrototypeOf(WaterLayer.prototype), 'add', this).call(this);
        }
        //移除

    }, {
        key: 'remove',
        value: function remove() {
            this.viewer.scene.primitives.remove(this.primitives);
            _get(WaterLayer.prototype.__proto__ || Object.getPrototypeOf(WaterLayer.prototype), 'remove', this).call(this);
        }
        //定位至数据区域

    }, {
        key: 'centerAt',
        value: function centerAt(duration) {
            if (this.options.extent || this.options.center) {
                this.viewer.mars.centerAt(this.options.extent || this.options.center, { duration: duration, isWgs84: true });
            } else {
                if (this.rectangle) this.viewer.mars.centerAt(this.rectangle, { duration: duration });
            }
        }
    }, {
        key: 'clearData',
        value: function clearData() {
            if (this.primitives) this.primitives.removeAll();
            this.arrData = null;
        }
    }, {
        key: 'setData',
        value: function setData(geojson) {
            //兼容不同命名
            this.clearData();
            return this.queryData(geojson);
        }
    }, {
        key: 'queryData',
        value: function queryData(geojson) {
            var that = this;

            var config = (0, _util.getProxyUrl)(this.options);
            geojson = geojson || config.url || config.data;
            if (!geojson) return; //没有需要加载的对象

            if (config.url) {
                _zepto.zepto.ajax({
                    type: "get",
                    dataType: "json",
                    url: config.url,
                    timeout: Cesium.defaultValue(config.timeout, 0), //永不超时
                    success: function success(geojson) {
                        var dataSource = Cesium.GeoJsonDataSource.load(geojson);
                        dataSource.then(function (dataSource) {
                            var entities = dataSource.entities.values;
                            that.showResult(entities);
                        }).otherwise(function (error) {
                            that.showError("服务出错", error);
                        });
                    },
                    error: function error(XMLHttpRequest, textStatus, errorThrown) {
                        marslog.warn(config.url + "文件加载失败！");
                    }
                });
            } else {
                var dataSource = Cesium.GeoJsonDataSource.load(geojson, config);
                dataSource.then(function (dataSource) {
                    var entities = dataSource.entities.values;
                    that.showResult(entities);
                }).otherwise(function (error) {
                    that.showError("服务出错", error);
                });
            }
        }
    }, {
        key: 'showResult',
        value: function showResult(entities) {
            var positionsALL = [];
            var arrData = [];

            for (var i = 0; i < entities.length; i++) {
                var entity = entities[i];

                var positions = (0, _Attr.getPositions)(entity);
                positionsALL = positionsALL.concat(positions);

                positions = (0, _point.setPositionsHeight)(positions, 0);

                var watercfg = this.getWaterCfg(entity);
                var height = Cesium.defaultValue(watercfg.height, 0);

                arrData.push({
                    positions: positions,
                    height: height,
                    config: watercfg
                });
            }

            this.rectangle = (0, _point.getRectangle)(positionsALL, true);

            this.arrData = arrData;
            this.createWater();

            this.fire(_MarsClass.eventType.load, {
                primitives: this.primitives,
                data: arrData
            });
        }
    }, {
        key: 'createWater',
        value: function createWater() {
            if (!this._visible) return;

            for (var i = 0; i < this.arrData.length; i++) {
                var item = this.arrData[i];

                // 水效果
                var polygon = new Cesium.PolygonGeometry({
                    height: item.height, //水面高度
                    extrudedHeight: item.height, //底部高 
                    polygonHierarchy: new Cesium.PolygonHierarchy(item.positions)
                });
                var primitive = (0, _water.createWaterPrimitive)(polygon, item.config);
                primitive.height_bak = item.height;
                this.primitives.add(primitive);
            }

            if (this.options.flyTo) this.centerAt(this.options.flyToDuration);
        }
    }, {
        key: 'getWaterCfg',
        value: function getWaterCfg(entity) {
            var attr = (0, _util.getAttrVal)(entity.properties);

            var symbol = this.options.symbol;
            var styleOpt = symbol.styleOptions;

            if (symbol.styleField) {
                //存在多个symbol，按styleField进行分类
                var styleFieldVal = attr[symbol.styleField];
                var styleOptField = symbol.styleFieldOptions[styleFieldVal];
                if (styleOptField != null) {
                    styleOpt = clone(styleOpt);
                    styleOpt = _extends({}, styleOpt, styleOptField);
                }
            }

            if (typeof symbol.callback === 'function') {
                //只是动态返回symbol的自定义的回调方法，返回style
                var styleOptField = symbol.callback(attr, entity, symbol);
                if (!styleOptField) return;

                styleOpt = clone(styleOpt);
                styleOpt = _extends({}, styleOpt, styleOptField);
            }
            styleOpt = styleOpt || {};

            return styleOpt;
        }

        //更新 闸门内 水域

    }, {
        key: 'updateHeight',
        value: function updateHeight(height) {
            var eRadis = 6378137;
            for (var i = 0; i < this.primitives.length; i++) {
                var primitive = this.primitives.get(i);

                var n = (eRadis + height) / (eRadis + primitive.height_bak);
                var modelMatrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(n, n, n));
                primitive.modelMatrix = modelMatrix;
            }
        }
    }, {
        key: 'layer',
        get: function get() {
            return this.primitives;
        }
    }]);

    return WaterLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GltfLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _BaseLayer2 = __webpack_require__(15);

var _Attr = __webpack_require__(31);

var _util = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GltfLayer = exports.GltfLayer = function (_BaseLayer) {
    _inherits(GltfLayer, _BaseLayer);

    //========== 构造方法 ========== 
    function GltfLayer(viewer, options) {
        _classCallCheck(this, GltfLayer);

        var _this = _possibleConstructorReturn(this, (GltfLayer.__proto__ || Object.getPrototypeOf(GltfLayer)).call(this, viewer, options));

        _this.hasOpacity = true;
        return _this;
    }

    _createClass(GltfLayer, [{
        key: 'add',

        //添加 
        value: function add() {
            if (this.entity) {
                this.viewer.entities.add(this.entity);
            } else {
                this.initData();
            }
            _get(GltfLayer.prototype.__proto__ || Object.getPrototypeOf(GltfLayer.prototype), 'add', this).call(this);
        }
        //移除

    }, {
        key: 'remove',
        value: function remove() {
            this.viewer.entities.remove(this.entity);
            _get(GltfLayer.prototype.__proto__ || Object.getPrototypeOf(GltfLayer.prototype), 'remove', this).call(this);
        }
        //定位至数据区域

    }, {
        key: 'centerAt',
        value: function centerAt(duration) {
            if (this.entity == null) return;

            if (this.options.extent || this.options.center) {
                this.viewer.mars.centerAt(this.options.extent || this.options.center, { duration: duration, isWgs84: true });
            } else {
                var cfg = this.options.position;
                this.viewer.mars.centerPoint(cfg, { duration: duration, isWgs84: true });
            }
        }
    }, {
        key: 'initData',
        value: function initData() {
            var _this2 = this;

            //位置信息
            var cfg = this.options.position;
            cfg = this.viewer.mars.point2map(cfg); //转换坐标系
            var position = Cesium.Cartesian3.fromDegrees(cfg.x, cfg.y, cfg.z || 0);

            //样式信息
            var style = this.options.style || {};
            if (Cesium.defined(this._opacity) && this._opacity != 1) style.opacity = this._opacity;

            //方向
            var heading = Cesium.Math.toRadians(style.heading || cfg.heading || 0);
            var pitch = Cesium.Math.toRadians(style.pitch || cfg.pitch || 0);
            var roll = Cesium.Math.toRadians(style.roll || cfg.roll || 0);
            var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
            var converter = this.options.converter || Cesium.Transforms.eastNorthUpToFixedFrame;
            var orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr, this.viewer.scene.globe.ellipsoid, converter);

            var modelattr = (0, _Attr.style2Entity)(style);
            modelattr.uri = this.options.url;

            this.entity = this.viewer.entities.add({
                name: this.options.name,
                position: position,
                orientation: orientation,
                model: modelattr,
                //okay3d扩展的属性
                _config: this.options,
                eventTarget: this
            });

            //readyPromise为修改cesium内部源码来实现的回调
            this.entity.readyPromise = function (entity, model) {
                _this2.fire(_MarsClass.eventType.load, { entity: entity, model: model });
            };

            var config = this.options;
            if (this.options.popup) {
                this.entity.popup = {
                    html: function html(entity) {
                        var attr = entity.properties || entity.data || {};

                        if ((0, _util.isString)(attr)) return attr;else return (0, _util.getPopupForConfig)(config, attr);
                    },
                    anchor: config.popupAnchor || [0, -15]
                };
            }
            if (this.options.tooltip) {
                this.entity.tooltip = {
                    html: function html(entity) {
                        var attr = entity.properties || entity.data || {};

                        if ((0, _util.isString)(attr)) return attr;else return (0, _util.getPopupForConfig)({ popup: config.tooltip }, attr);
                    },
                    anchor: config.tooltipAnchor || [0, -15]
                };
            }

            this.fire(_MarsClass.eventType.loadBefore, { entity: this.entity });
        }
        //设置透明度

    }, {
        key: 'setOpacity',
        value: function setOpacity(value) {
            if (this.entity == null) return;
            this.entity.model.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(value);
        }
    }, {
        key: 'layer',
        get: function get() {
            return this.entity;
        }
    }, {
        key: 'model',
        get: function get() {
            return this.entity;
        }
    }]);

    return GltfLayer;
}(_BaseLayer2.BaseLayer);

//[静态属性]本类中支持的事件类型常量


GltfLayer.event = {
    load: _MarsClass.eventType.load,
    loadBefore: _MarsClass.eventType.loadBefore,
    click: _MarsClass.eventType.click,
    mouseOver: _MarsClass.eventType.mouseOver,
    mouseOut: _MarsClass.eventType.mouseOut
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tiles3dLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _BaseLayer2 = __webpack_require__(15);

var _util = __webpack_require__(1);

var _tileset = __webpack_require__(27);

var _point = __webpack_require__(2);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tiles3dLayer = exports.Tiles3dLayer = function (_BaseLayer) {
    _inherits(Tiles3dLayer, _BaseLayer);

    //========== 构造方法 ========== 
    function Tiles3dLayer(viewer, options) {
        _classCallCheck(this, Tiles3dLayer);

        var _this = _possibleConstructorReturn(this, (Tiles3dLayer.__proto__ || Object.getPrototypeOf(Tiles3dLayer)).call(this, viewer, options));

        _this.hasOpacity = true;

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        if (_this.options.readyPromise) {
            _this.on(_MarsClass.eventType.loadBefore, function (event) {
                _this.options.readyPromise(event.tileset);
            });
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        return _this;
    }

    _createClass(Tiles3dLayer, [{
        key: 'add',

        //添加 
        value: function add() {
            if (this.tileset) {
                if (!this.viewer.scene.primitives.contains(this.tileset)) this.viewer.scene.primitives.add(this.tileset);
            } else {
                this.initData();
            }
            _get(Tiles3dLayer.prototype.__proto__ || Object.getPrototypeOf(Tiles3dLayer.prototype), 'add', this).call(this);
        }
        //移除

    }, {
        key: 'remove',
        value: function remove() {
            if (Cesium.defined(this.options.visibleDistanceMax)) this.viewer.scene.camera.changed.removeEventListener(this.updateVisibleDistance, this);

            //解除绑定的事件 
            if (this.tileset) {
                this.tileset.initialTilesLoaded.removeEventListener(this.onInitialTilesLoaded, this);
                this.tileset.allTilesLoaded.removeEventListener(this.onAllTilesLoaded, this);

                if (this.viewer.scene.primitives.contains(this.tileset)) this.viewer.scene.primitives.remove(this.tileset);

                delete this.tileset;
            }
            if (this.boundingSphere) delete this.boundingSphere;
            _get(Tiles3dLayer.prototype.__proto__ || Object.getPrototypeOf(Tiles3dLayer.prototype), 'remove', this).call(this);
        }
        //定位至数据区域

    }, {
        key: 'centerAt',
        value: function centerAt(duration) {
            if (this.options.extent || this.options.center) {
                this.viewer.mars.centerAt(this.options.extent || this.options.center, { duration: duration, isWgs84: true });
            } else if (this.boundingSphere) {
                this.viewer.camera.flyToBoundingSphere(this.boundingSphere, {
                    offset: new Cesium.HeadingPitchRange(0.0, -0.5, this.boundingSphere.radius * 2),
                    duration: duration
                });
            }
        }
    }, {
        key: 'initData',
        value: function initData() {
            var _this2 = this;

            this.tileset = this.viewer.scene.primitives.add(new Cesium.Cesium3DTileset((0, _util.getProxyUrl)(this.options)));
            this.tileset.eventTarget = this;
            this.tileset._config = this.options;

            for (var key in this.options) {
                if (key == "url" || key == "type" || key == "style" || key == "classificationType") continue;
                try {
                    this.tileset[key] = this.options[key];
                } catch (e) {}
            }
            if (this.options.style) {
                //设置style
                this.tileset.style = new Cesium.Cesium3DTileStyle(this.options.style);
            }

            //绑定一些事件 
            this.tileset.initialTilesLoaded.addEventListener(this.onInitialTilesLoaded, this);
            this.tileset.allTilesLoaded.addEventListener(this.onAllTilesLoaded, this);

            this.tileset.readyPromise.then(function (tileset) {
                _this2.fire(_MarsClass.eventType.loadBefore, { tileset: tileset });

                if (_this2.hasOpacity && _this2._opacity != 1) {
                    //透明度
                    _this2.setOpacity(_this2._opacity);
                }

                //记录模型原始的中心点
                var boundingSphere = tileset.boundingSphere;
                _this2.boundingSphere = boundingSphere;

                if (tileset._root && tileset._root.transform) {
                    _this2.orginMatrixInverse = Cesium.Matrix4.inverse(Cesium.Matrix4.fromArray(tileset._root.transform), new Cesium.Matrix4());

                    //缩放
                    if (_this2.options.scale > 0 && _this2.options.scale != 1) {
                        tileset._root.transform = Cesium.Matrix4.multiplyByUniformScale(tileset._root.transform, _this2.options.scale, tileset._root.transform);
                    }
                }

                var position = boundingSphere.center; //模型原始的中心点
                _this2.positionCenter = position;
                var catographic = Cesium.Cartographic.fromCartesian(position);

                var height = Number(catographic.height.toFixed(2));
                var longitude = Number(Cesium.Math.toDegrees(catographic.longitude).toFixed(6));
                var latitude = Number(Cesium.Math.toDegrees(catographic.latitude).toFixed(6));
                _this2.originalCenter = { x: longitude, y: latitude, z: height };
                marslog.log((_this2.options.name || "") + " 模型原始位置:" + JSON.stringify(_this2.originalCenter));

                //转换坐标系【如果是高德谷歌国测局坐标系时转换坐标进行加偏，其它的原样返回】
                var rawCenter = _this2.viewer.mars.point2map(_this2.originalCenter);
                if (rawCenter.x != _this2.originalCenter.x || rawCenter.y != _this2.originalCenter.y || _this2.options.offset != null) {

                    _this2.options.offset = _this2.options.offset || {}; //配置信息中指定的坐标信息或高度信息
                    _this2.options.rotation = _this2.options.rotation || {};

                    if (_this2.options.offset.x && _this2.options.offset.y) {
                        _this2.options.offset = _this2.viewer.mars.point2map(_this2.options.offset); //转换坐标系【如果是高德谷歌国测局坐标系时转换坐标进行加偏，其它的原样返回】
                    }

                    var offsetopt = {
                        x: _this2.options.offset.x || rawCenter.x,
                        y: _this2.options.offset.y || rawCenter.y,
                        z: _this2.options.offset.z || 0,
                        rotation_z: _this2.options.rotation.z || _this2.options.offset.heading,
                        rotation_x: _this2.options.rotation.x,
                        rotation_y: _this2.options.rotation.y,
                        axis: _this2.options.axis,
                        scale: _this2.options.scale,
                        transform: _this2.options.offset.hasOwnProperty("transform") ? _this2.options.offset.transform : _this2.options.offset.heading != null || _this2.options.rotation.z != null
                    };

                    if (_this2.options.offset.z == "-height") {
                        offsetopt.z = -height + 5;
                        _this2.updateMatrix(offsetopt);
                    } else if (_this2.options.offset.z == "auto") {
                        _this2.autoHeight(position, offsetopt);
                    } else {
                        _this2.updateMatrix(offsetopt);
                    }
                }

                if (_this2.options.flyTo) {
                    if (_this2.viewer.mars.isFlyAnimation()) {
                        _this2.viewer.mars.openFlyAnimationEndFun = function () {
                            _this2.centerAt(0);
                        };
                    } else {
                        _this2.centerAt(0);
                    }
                }

                if (Cesium.defined(_this2.options.visibleDistanceMax)) _this2.bindVisibleDistance();

                _this2.fire(_MarsClass.eventType.load, { tileset: tileset });
            });
        }
        //刷新事件

    }, {
        key: 'refreshEvent',
        value: function refreshEvent() {
            if (this.tileset == null) return false;

            this.tileset.eventTarget = this;
            this.tileset.contextmenuItems = this.options.contextmenuItems;
            return true;
        }
        //该回调只执行一次

    }, {
        key: 'onInitialTilesLoaded',
        value: function onInitialTilesLoaded(e) {
            this.fire(_MarsClass.eventType.initialTilesLoaded, { tile: e });
        }
        //该回调会执行多次，视角变化后重新加载一次完成后都会回调

    }, {
        key: 'onAllTilesLoaded',
        value: function onAllTilesLoaded(e) {
            this.fire(_MarsClass.eventType.allTilesLoaded, { tile: e });
        }
    }, {
        key: 'autoHeight',
        value: function autoHeight(position, offsetopt) {
            var that = this;
            //求地面海拔
            (0, _point.getSurfaceTerrainHeight)(this.viewer.scene, position, {
                asyn: true, //是否异步求准确高度 
                callback: function callback(newHeight, cartOld) {
                    if (newHeight == null) return;

                    var offsetZ = newHeight - that.originalCenter.z + 1;
                    offsetopt.z = offsetZ;

                    that.updateMatrix(offsetopt);
                }
            });
        }
        //变换原点坐标

    }, {
        key: 'updateMatrix',
        value: function updateMatrix(offsetopt) {
            if (this.tileset == null) return;

            marslog.log((this.options.name || "") + " 模型修改后位置:" + JSON.stringify(offsetopt));

            this.positionCenter = Cesium.Cartesian3.fromDegrees(offsetopt.x, offsetopt.y, offsetopt.z);

            (0, _tileset.updateMatrix)(this.tileset, offsetopt);
        }

        //设置透明度

    }, {
        key: 'setOpacity',
        value: function setOpacity(value) {
            this._opacity = value;

            if (this.options.onSetOpacity) {
                this.options.onSetOpacity(value); //外部自定义处理
            } else {
                if (this.tileset) {
                    this.tileset.style = new Cesium.Cesium3DTileStyle({
                        color: "color() *vec4(1,1,1," + value + ")"
                    });
                }
            }
        }
    }, {
        key: 'showClickFeature',
        value: function showClickFeature(value) {
            if (this.tileset) {
                this.tileset._config.showClickFeature = value;
            } else {
                this.options.showClickFeature = value;
            }
        }
        //绑定

    }, {
        key: 'bindVisibleDistance',
        value: function bindVisibleDistance() {
            this.viewer.scene.camera.changed.addEventListener(this.updateVisibleDistance, this);
        }
    }, {
        key: 'updateVisibleDistance',
        value: function updateVisibleDistance() {
            if (!this._visible) return;
            if (this.viewer.scene.mode !== Cesium.SceneMode.SCENE3D) return;
            if (!this.tileset || !this.boundingSphere || !this.positionCenter) return;

            var camera_distance = Cesium.Cartesian3.distance(this.positionCenter, this.viewer.camera.positionWC);
            if (camera_distance > this.options.visibleDistanceMax + 100000) {
                //在模型的外包围外
                this.tileset.show = false;
            } else {
                var target = (0, _point.pickCenterPoint)(this.viewer.scene); //取屏幕中心点坐标
                if (Cesium.defined(target)) {
                    var camera_distance = Cesium.Cartesian3.distance(target, this.viewer.camera.positionWC);
                    this.tileset.show = camera_distance < this.options.visibleDistanceMax;
                } else {
                    this.tileset.show = true;
                }
            }
        }
    }, {
        key: 'layer',
        get: function get() {
            return this.tileset;
        }
    }, {
        key: 'model',
        get: function get() {
            return this.tileset;
        }
    }]);

    return Tiles3dLayer;
}(_BaseLayer2.BaseLayer);

//[静态属性]本类中支持的事件类型常量


Tiles3dLayer.event = {
    load: _MarsClass.eventType.load,
    loadBefore: _MarsClass.eventType.loadBefore,
    initialTilesLoaded: _MarsClass.eventType.initialTilesLoaded,
    allTilesLoaded: _MarsClass.eventType.allTilesLoaded,
    click: _MarsClass.eventType.click,
    mouseOver: _MarsClass.eventType.mouseOver,
    mouseOut: _MarsClass.eventType.mouseOut
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KmlLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _GeoJsonLayer2 = __webpack_require__(43);

var _util = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KmlLayer = exports.KmlLayer = function (_GeoJsonLayer) {
    _inherits(KmlLayer, _GeoJsonLayer);

    function KmlLayer() {
        _classCallCheck(this, KmlLayer);

        return _possibleConstructorReturn(this, (KmlLayer.__proto__ || Object.getPrototypeOf(KmlLayer)).apply(this, arguments));
    }

    _createClass(KmlLayer, [{
        key: 'queryData',
        value: function queryData() {
            var that = this;

            var config = (0, _util.getProxyUrl)(this.options);

            if (config.symbol && config.symbol.styleOptions) {
                var style = config.symbol.styleOptions;
                if (Cesium.defined(style.clampToGround)) {
                    config.clampToGround = style.clampToGround;
                }
            }

            var dataSource = Cesium.KmlDataSource.load(config.url, {
                camera: this.viewer.scene.camera,
                canvas: this.viewer.scene.canvas,
                clampToGround: config.clampToGround
            });
            dataSource.then(function (dataSource) {
                that.showResult(dataSource);
            }).otherwise(function (error) {
                that.showError("服务出错", error);
            });
        }
    }, {
        key: 'getEntityAttr',
        value: function getEntityAttr(entity) {
            var attr = { name: entity.name, description: entity.description };
            var extendedData = entity._kml.extendedData;
            for (var key in extendedData) {
                attr[key] = extendedData[key].value;
            }
            attr = (0, _util.getAttrVal)(attr);

            if (attr.description) {
                attr.description = attr.description.replace(/<div[^>]+>/g, ""); //剔除div html标签
            }

            return attr;
        }
    }]);

    return KmlLayer;
}(_GeoJsonLayer2.GeoJsonLayer);

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CzmlLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _GeoJsonLayer2 = __webpack_require__(43);

var _util = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CzmlLayer = exports.CzmlLayer = function (_GeoJsonLayer) {
    _inherits(CzmlLayer, _GeoJsonLayer);

    function CzmlLayer() {
        _classCallCheck(this, CzmlLayer);

        return _possibleConstructorReturn(this, (CzmlLayer.__proto__ || Object.getPrototypeOf(CzmlLayer)).apply(this, arguments));
    }

    _createClass(CzmlLayer, [{
        key: "queryData",
        value: function queryData() {
            var that = this;

            var config = (0, _util.getProxyUrl)(this.options);

            var dataSource = Cesium.CzmlDataSource.load(config.url, config);
            dataSource.then(function (dataSource) {
                that.showResult(dataSource);
            }).otherwise(function (error) {
                that.showError("服务出错", error);
            });
        }
    }, {
        key: "getEntityAttr",
        value: function getEntityAttr(entity) {
            if (entity.description && entity.description.getValue) return entity.description.getValue(this.viewer.clock.currentTime);
        }
    }]);

    return CzmlLayer;
}(_GeoJsonLayer2.GeoJsonLayer);

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerrainLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _BaseLayer2 = __webpack_require__(15);

var _layer = __webpack_require__(23);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TerrainLayer = exports.TerrainLayer = function (_BaseLayer) {
    _inherits(TerrainLayer, _BaseLayer);

    function TerrainLayer() {
        _classCallCheck(this, TerrainLayer);

        return _possibleConstructorReturn(this, (TerrainLayer.__proto__ || Object.getPrototypeOf(TerrainLayer)).apply(this, arguments));
    }

    _createClass(TerrainLayer, [{
        key: 'add',

        //添加 
        value: function add() {
            if (!this.terrain) {
                this.terrain = (0, _layer.getTerrainProvider)(this.options.terrain || this.options);
                this.fire(_MarsClass.eventType.load, { terrain: this.terrain });
            }
            this.viewer.terrainProvider = this.terrain;
            _get(TerrainLayer.prototype.__proto__ || Object.getPrototypeOf(TerrainLayer.prototype), 'add', this).call(this);
        }
        //移除

    }, {
        key: 'remove',
        value: function remove() {
            this.viewer.terrainProvider = (0, _layer.getEllipsoidTerrain)();
            _get(TerrainLayer.prototype.__proto__ || Object.getPrototypeOf(TerrainLayer.prototype), 'remove', this).call(this);
        }
    }, {
        key: 'layer',
        get: function get() {
            return this.terrain;
        }
    }]);

    return TerrainLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _zepto = __webpack_require__(8);

var _BaseLayer2 = __webpack_require__(15);

var _Draw = __webpack_require__(6);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawLayer = exports.DrawLayer = function (_BaseLayer) {
    _inherits(DrawLayer, _BaseLayer);

    function DrawLayer() {
        _classCallCheck(this, DrawLayer);

        return _possibleConstructorReturn(this, (DrawLayer.__proto__ || Object.getPrototypeOf(DrawLayer)).apply(this, arguments));
    }

    _createClass(DrawLayer, [{
        key: 'create',
        value: function create() {
            this.drawControl = new _Draw.Draw(this.viewer, {
                hasEdit: false,
                nameTooltip: false,
                removeScreenSpaceEvent: false
            });
        }
        //添加 

    }, {
        key: 'add',
        value: function add() {
            if (this._isload) this.drawControl.setVisible(true);else this._loadData();
            _get(DrawLayer.prototype.__proto__ || Object.getPrototypeOf(DrawLayer.prototype), 'add', this).call(this);
        }
        //移除

    }, {
        key: 'remove',
        value: function remove() {
            this.drawControl.setVisible(false);
            _get(DrawLayer.prototype.__proto__ || Object.getPrototypeOf(DrawLayer.prototype), 'remove', this).call(this);
        }
        //定位至数据区域

    }, {
        key: 'centerAt',
        value: function centerAt(duration) {
            var arr = this.drawControl.getEntitys();
            this.viewer.mars.flyTo(arr, { duration: duration });
        }
    }, {
        key: '_loadData',
        value: function _loadData() {
            var that = this;
            _zepto.zepto.ajax({
                type: "get",
                dataType: "json",
                url: this.options.url,
                timeout: 10000,
                success: function success(data) {
                    that._isload = true;
                    var arr = that.drawControl.jsonToEntity(data, true, that.options.flyTo);
                    that._bindEntityConfig(arr);

                    that.fire(_MarsClass.eventType.load, {
                        draw: that.drawControl,
                        entities: arr
                    });
                },
                error: function error(XMLHttpRequest, textStatus, errorThrown) {
                    marslog.warn("json文件" + that.options.url + "加载失败！");
                }
            });
        }
    }, {
        key: '_bindEntityConfig',
        value: function _bindEntityConfig(arrEntity) {
            var that = this;

            for (var i = 0, len = arrEntity.length; i < len; i++) {
                var entity = arrEntity[i];

                //popup弹窗
                if (this.options.columns || this.options.popup) {
                    entity.popup = (0, _util.bindLayerPopup)(this.options.popup, function (entity) {
                        var attr = entity.attribute.attr;
                        attr.layer_name = that.options.name;
                        attr.draw_type = entity.attribute.type;
                        attr.draw_typename = entity.attribute.name;
                        return (0, _util.getPopupForConfig)(that.options, attr);
                    });
                }
                if (this.options.tooltip) {
                    entity.tooltip = (0, _util.bindLayerPopup)(this.options.tooltip, function (entity) {
                        var attr = entity.attribute.attr;
                        attr.layer_name = that.options.name;
                        attr.draw_type = entity.attribute.type;
                        attr.draw_typename = entity.attribute.name;
                        return (0, _util.getPopupForConfig)({ popup: that.options.tooltip }, attr);
                    });
                }
                entity.eventTarget = this;

                if (this.options.contextmenuItems) {
                    entity.contextmenuItems = this.options.contextmenuItems;
                }
            }
        }

        //刷新事件

    }, {
        key: 'refreshEvent',
        value: function refreshEvent() {
            var arrEntity = this.drawControl.getEntitys();
            for (var i = 0, len = arrEntity.length; i < len; i++) {
                var entity = arrEntity[i];

                entity.eventTarget = this;
                entity.contextmenuItems = this.options.contextmenuItems;
            }
            return true;
        }
    }, {
        key: 'updateStyle',
        value: function updateStyle(style) {
            var arrEntity = this.drawControl.getEntitys();
            for (var i = 0, len = arrEntity.length; i < len; i++) {
                var entity = arrEntity[i];
                this.drawControl.updateStyle(style, entity);
            }
            return arrEntity;
        }
    }, {
        key: 'layer',
        get: function get() {
            if (this.drawControl) return this.drawControl.dataSource;else return null;
        }
    }]);

    return DrawLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaiduImageryProvider = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function BaiduImageryProvider(option) {
    var url = option.url;
    if (Cesium.defined(option.layer)) {
        switch (option.layer) {
            case "vec":
                url = 'http://online{s}.map.bdimg.com/onlinelabel/?qt=tile&x={x}&y={y}&z={z}&styles=' + (option.bigfont ? 'ph' : 'pl') + '&scaler=1&p=1';
                break;
            case "img_d":
                url = 'http://shangetu{s}.map.bdimg.com/it/u=x={x};y={y};z={z};v=009;type=sate&fm=46';
                break;
            case "img_z":
                url = 'http://online{s}.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=' + (option.bigfont ? 'sh' : 'sl') + '&v=020';
                break;

            case "custom":
                //Custom 各种自定义样式
                //可选值：dark,midnight,grayscale,hardedge,light,redalert,googlelite,grassgreen,pink,darkgreen,bluish
                option.customid = option.customid || 'midnight';
                url = 'http://api{s}.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&scale=1&customid=' + option.customid;
                break;

            case "time":
                //实时路况
                var time = new Date().getTime();
                url = 'http://its.map.baidu.com:8002/traffic/TrafficTileService?x={x}&y={y}&level={z}&time=' + time + '&label=web2D&v=017';
                break;
        }
    }
    this._url = url;

    this._tileWidth = 256;
    this._tileHeight = 256;
    this._maximumLevel = 18;

    this._tilingScheme = new Cesium.WebMercatorTilingScheme({
        rectangleSouthwestInMeters: new Cesium.Cartesian2(-33554054, -33746824),
        rectangleNortheastInMeters: new Cesium.Cartesian2(33554054, 33746824)
    });

    this._credit = undefined;
    this._rectangle = this._tilingScheme.rectangle;
    this._ready = true;
} //百度地图

Object.defineProperties(BaiduImageryProvider.prototype, {
    url: {
        get: function get() {
            return this._url;
        }
    },

    token: {
        get: function get() {
            return this._token;
        }
    },

    proxy: {
        get: function get() {
            return this._proxy;
        }
    },

    tileWidth: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._tileWidth;
        }
    },

    tileHeight: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._tileHeight;
        }
    },

    maximumLevel: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._maximumLevel;
        }
    },

    minimumLevel: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return 0;
        }
    },

    tilingScheme: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._tilingScheme;
        }
    },

    rectangle: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('rectangle must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._rectangle;
        }
    },

    tileDiscardPolicy: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._tileDiscardPolicy;
        }
    },

    errorEvent: {
        get: function get() {
            return this._errorEvent;
        }
    },

    ready: {
        get: function get() {
            return this._ready;
        }
    },

    readyPromise: {
        get: function get() {
            return this._readyPromise.promise;
        }
    },

    credit: {
        get: function get() {
            return this._credit;
        }
    },

    usingPrecachedTiles: {
        get: function get() {
            return this._useTiles;
        }
    },

    hasAlphaChannel: {
        get: function get() {
            return true;
        }
    },

    layers: {
        get: function get() {
            return this._layers;
        }
    }
});

BaiduImageryProvider.prototype.getTileCredits = function (x, y, level) {
    return undefined;
};

BaiduImageryProvider.prototype.requestImage = function (x, y, level) {
    if (!this._ready) {
        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
    }

    var xTiles = this._tilingScheme.getNumberOfXTilesAtLevel(level);
    var yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);

    var url = this._url.replace('{x}', x - xTiles / 2).replace('{y}', yTiles / 2 - y - 1).replace('{z}', level).replace('{s}', "0");

    return Cesium.ImageryProvider.loadImage(this, url);
};

exports.BaiduImageryProvider = BaiduImageryProvider;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TencentImageryProvider = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //腾讯地图


var TencentImageryProvider = exports.TencentImageryProvider = function (_Cesium$UrlTemplateIm) {
    _inherits(TencentImageryProvider, _Cesium$UrlTemplateIm);

    function TencentImageryProvider() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, TencentImageryProvider);

        var url = options.url;
        if (Cesium.defined(options.layer)) {
            switch (options.layer) {
                case "vec":
                    url = 'https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=1&scene=0';
                    break;
                case "img_d":
                    url = 'https://p{s}.map.gtimg.com/sateTiles/{z}/{sx}/{sy}/{x}_{reverseY}.jpg?version=400';
                    options['customTags'] = {
                        sx: function sx(imageryProvider, x, y, level) {
                            return x >> 4;
                        },
                        sy: function sy(imageryProvider, x, y, level) {
                            return (1 << level) - y >> 4;
                        }
                    };
                    break;
                case "img_z":
                    url = 'https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=2&scene=0';
                    break;
                case "custom":
                    //Custom 各种自定义样式
                    //可选值：灰白地图:3,暗色地图:4
                    options.customid = options.customid || '4';
                    url = 'https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=' + options.customid + '&scene=0';
                    break;
            }
        }
        options.url = url;
        options.subdomains = Cesium.defaultValue(options.subdomains, ['0', '1', '2']);

        return _possibleConstructorReturn(this, (TencentImageryProvider.__proto__ || Object.getPrototypeOf(TencentImageryProvider)).call(this, options));
    }

    return TencentImageryProvider;
}(Cesium.UrlTemplateImageryProvider);

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FeatureGridImageryProvider = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function FeatureGridImageryProvider(options) {
    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
    this.options = options;

    this._tileWidth = Cesium.defaultValue(options.tileWidth, 256);
    this._tileHeight = Cesium.defaultValue(options.tileHeight, 256);
    this._minimumLevel = Cesium.defaultValue(options.minimumLevel, 0);
    this._maximumLevel = options.maximumLevel;

    if (options.rectangle && options.rectangle.xmin && options.rectangle.xmax && options.rectangle.ymin && options.rectangle.ymax) {
        var xmin = options.rectangle.xmin;
        var xmax = options.rectangle.xmax;
        var ymin = options.rectangle.ymin;
        var ymax = options.rectangle.ymax;
        options.rectangle = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);
    }
    if (Cesium.defined(options.bbox) && options.bbox.length && options.bbox.length == 4) {
        options.rectangle = Cesium.Rectangle.fromDegrees(options.bbox[0], options.bbox[1], options.bbox[2], options.bbox[3]); //[xmin,ymin,xmax,ymax]
    }

    this._tilingScheme = Cesium.defaultValue(options.tilingScheme, new Cesium.GeographicTilingScheme({ ellipsoid: options.ellipsoid }));
    this._rectangle = Cesium.defaultValue(options.rectangle, this._tilingScheme.rectangle);
    this._rectangle = Cesium.Rectangle.intersection(this._rectangle, this._tilingScheme.rectangle);
    this._hasAlphaChannel = Cesium.defaultValue(options.hasAlphaChannel, true);

    this._errorEvent = new Cesium.Event();
    this._readyPromise = Cesium.when.resolve(true);
    this._credit = undefined;
    this._ready = true;
}

Object.defineProperties(FeatureGridImageryProvider.prototype, {
    url: {
        get: function get() {
            return this._url;
        }
    },

    token: {
        get: function get() {
            return this._token;
        }
    },

    proxy: {
        get: function get() {
            return this._proxy;
        }
    },

    tileWidth: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._tileWidth;
        }
    },

    tileHeight: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._tileHeight;
        }
    },

    maximumLevel: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._maximumLevel;
        }
    },

    minimumLevel: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug'); 
            return 0;
        }
    },

    tilingScheme: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._tilingScheme;
        }
    },

    rectangle: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('rectangle must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._rectangle;
        }
    },

    tileDiscardPolicy: {
        get: function get() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._tileDiscardPolicy;
        }
    },

    errorEvent: {
        get: function get() {
            return this._errorEvent;
        }
    },

    ready: {
        get: function get() {
            return this._ready;
        }
    },

    readyPromise: {
        get: function get() {
            return this._readyPromise.promise;
        }
    },

    credit: {
        get: function get() {
            return this._credit;
        }
    },

    usingPrecachedTiles: {
        get: function get() {
            return this._useTiles;
        }
    },

    hasAlphaChannel: {
        get: function get() {
            return true;
        }
    },

    layers: {
        get: function get() {
            return this._layers;
        }
    }
});

FeatureGridImageryProvider.prototype.getTileCredits = function (x, y, level) {
    return undefined;
};

//显示瓦片信息
FeatureGridImageryProvider.prototype.requestImage = function (x, y, level) {
    var canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;

    if (level < this._minimumLevel || Cesium.defined(this._maximumLevel) && level > this._maximumLevel) return canvas;

    if (this.options.debuggerTileInfo) {
        var context = canvas.getContext('2d');

        context.strokeStyle = '#ffff00';
        context.lineWidth = 2;
        context.strokeRect(1, 1, 255, 255);

        var label = 'L' + level + 'X' + x + 'Y' + y;
        context.font = 'bold 25px Arial';
        context.textAlign = 'center';
        context.fillStyle = 'black';
        context.fillText(label, 127, 127);
        context.fillStyle = '#ffff00';
        context.fillText(label, 124, 124);
    }
    return canvas;
};

FeatureGridImageryProvider.prototype._getGridKey = function (opts) {
    return opts.level + "_x" + opts.x + "_y" + opts.y;
};

FeatureGridImageryProvider.prototype.addImageryCache = function (opts) {
    if (opts.level < this._minimumLevel || opts.level < opts.maxLevel - 1 || Cesium.defined(this._maximumLevel) && opts.level >= this._maximumLevel) return;

    // marslog.log('新增' + JSON.stringify(opts));
    if (this.options.addImageryCache) {
        opts.key = this._getGridKey(opts);
        this.options.addImageryCache(opts);
    }
};

FeatureGridImageryProvider.prototype.removeImageryCache = function (opts) {
    var hasRemoveAll = opts.maxLevel < this._minimumLevel || Cesium.defined(this._maximumLevel) && opts.level >= this._maximumLevel;
    if (hasRemoveAll && this.options.removeAllImageryCache) {
        this.options.removeAllImageryCache();
        return;
    }

    // marslog.log('删除' + JSON.stringify(opts));
    if (this.options.removeImageryCache) {
        opts.key = this._getGridKey(opts);
        this.options.removeImageryCache(opts);
    }
};

exports.FeatureGridImageryProvider = FeatureGridImageryProvider;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawLabel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(24);

var _Attr = __webpack_require__(12);

var attr = _interopRequireWildcard(_Attr);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawLabel = exports.DrawLabel = function (_DrawPoint) {
    _inherits(DrawLabel, _DrawPoint);

    //========== 构造方法 ========== 
    function DrawLabel(opts) {
        _classCallCheck(this, DrawLabel);

        var _this = _possibleConstructorReturn(this, (DrawLabel.__proto__ || Object.getPrototypeOf(DrawLabel)).call(this, opts));

        _this.type = 'label';
        _this.attrClass = attr; //对应的属性控制静态类   
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawLabel, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = null;

            //绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
            var _drawShow = Cesium.defaultValue(attribute.drawShow, false);

            var that = this;
            var addattr = {
                show: _drawShow,
                _drawShow: _drawShow, //edit编辑时使用
                position: new Cesium.CallbackProperty(function (time) {
                    return that.getDrawPosition();
                }, false),
                label: attr.style2Entity(attribute.style),
                attribute: attribute
            };
            this.entity = dataSource.entities.add(addattr); //创建要素对象
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.label);
        }
    }]);

    return DrawLabel;
}(_Draw.DrawPoint);

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawModel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _point = __webpack_require__(2);

var _Draw = __webpack_require__(24);

var _Attr = __webpack_require__(31);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(12);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawModel = exports.DrawModel = function (_DrawPoint) {
    _inherits(DrawModel, _DrawPoint);

    //========== 构造方法 ========== 
    function DrawModel(opts) {
        _classCallCheck(this, DrawModel);

        var _this = _possibleConstructorReturn(this, (DrawModel.__proto__ || Object.getPrototypeOf(DrawModel)).call(this, opts));

        _this.type = 'model';
        _this.attrClass = attr; //对应的属性控制静态类   
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawModel, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            var _this2 = this;

            dataSource = dataSource || this.dataSource;
            this._positions_draw = null;

            //绘制时，是否自动隐藏模型，可避免拾取坐标存在问题。
            var _drawShow = Cesium.defaultValue(attribute.drawShow, false);

            var that = this;
            var addattr = {
                show: _drawShow,
                _drawShow: _drawShow, //edit编辑时使用
                position: new Cesium.CallbackProperty(function (time) {
                    return that.getDrawPosition();
                }, false),
                model: attr.style2Entity(attribute.style),
                attribute: attribute
            };

            if (attribute.style && attribute.style.label) {
                //同时加文字
                addattr.label = (0, _Attr2.style2Entity)(attribute.style.label);
            }

            this.entity = dataSource.entities.add(addattr); //创建要素对象 
            this.entity.loadOk = false;
            this.entity.readyPromise = function (entity, model) {
                entity.loadOk = true;
                _this2.fire(_MarsClass.eventType.load, { drawtype: _this2.type, entity: entity, model: model });
            };
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            this.updateOrientation(style, entity);
            if (style && style.label) {
                //同时加文字
                (0, _Attr2.style2Entity)(style.label, entity.label);
            }
            return attr.style2Entity(style, entity.model);
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing() {
            this.updateOrientation(this.entity.attribute.style, this.entity);
        }
        //角度更新

    }, {
        key: 'updateOrientation',
        value: function updateOrientation(style, entity) {
            var position = (0, _point.getPositionValue)(entity.position);
            if (position == null) return;

            var heading = Cesium.Math.toRadians(Number(style.heading || 0.0));
            var pitch = Cesium.Math.toRadians(Number(style.pitch || 0.0));
            var roll = Cesium.Math.toRadians(Number(style.roll || 0.0));

            var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
            entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
        }
    }]);

    return DrawModel;
}(_Draw.DrawPoint);

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(16);

var _Attr = __webpack_require__(19);

var _Edit = __webpack_require__(60);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawCurve = exports.DrawCurve = function (_DrawPolyline) {
    _inherits(DrawCurve, _DrawPolyline);

    //========== 构造方法 ========== 
    function DrawCurve(opts) {
        _classCallCheck(this, DrawCurve);

        var _this = _possibleConstructorReturn(this, (DrawCurve.__proto__ || Object.getPrototypeOf(DrawCurve)).call(this, opts));

        _this.type = 'curve';
        _this.editClass = _Edit.EditCurve; //获取编辑对象

        return _this;
    }

    _createClass(DrawCurve, [{
        key: 'getDrawPosition',
        value: function getDrawPosition() {
            return this._positions_show;
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing() {
            if (this._positions_draw == null || this._positions_draw.length < 3) {
                this._positions_show = this._positions_draw;
                return;
            }

            this._positions_show = (0, _Attr.line2curve)(this._positions_draw, this.entity.attribute.style.closure);
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   


            this.entity._positions_draw = this._positions_draw;
            this.entity._positions_show = this._positions_show;

            entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                return entity._positions_show;
            }, false);

            this._positions_show = null;
        }
    }]);

    return DrawCurve;
}(_Draw.DrawPolyline);

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawPolylineVolume = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(16);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(52);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(61);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPolylineVolume = exports.DrawPolylineVolume = function (_DrawPolyline) {
    _inherits(DrawPolylineVolume, _DrawPolyline);

    //========== 构造方法 ========== 
    function DrawPolylineVolume(opts) {
        _classCallCheck(this, DrawPolylineVolume);

        var _this = _possibleConstructorReturn(this, (DrawPolylineVolume.__proto__ || Object.getPrototypeOf(DrawPolylineVolume)).call(this, opts));

        _this.type = 'polylineVolume';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditPolylineVolume; //获取编辑对象

        _this._minPointNum = 2; //至少需要点的个数 
        _this._maxPointNum = 9999; //最多允许点的个数 
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawPolylineVolume, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = [];

            if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
            if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

            if (attribute.config) {
                //允许外部传入
                this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
            } else {
                this._minPointNum = this._minPointNum_def;
                this._maxPointNum = this._maxPointNum_def;
            }

            var that = this;
            var addattr = {
                polylineVolume: attr.style2Entity(attribute.style),
                attribute: attribute
            };
            addattr.polylineVolume.positions = new Cesium.CallbackProperty(function (time) {
                return that.getDrawPosition();
            }, false);

            this.entity = dataSource.entities.add(addattr); //创建要素对象
            this.entity._positions_draw = this._positions_draw;

            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.polylineVolume);
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing() {}
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this.getDrawPosition();
            entity.polylineVolume.positions = new Cesium.CallbackProperty(function (time) {
                return entity._positions_draw;
            }, false);
        }
    }]);

    return DrawPolylineVolume;
}(_Draw.DrawPolyline);

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawCorridor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(16);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

var _Attr = __webpack_require__(54);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(62);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawCorridor = exports.DrawCorridor = function (_DrawPolyline) {
    _inherits(DrawCorridor, _DrawPolyline);

    //========== 构造方法 ========== 
    function DrawCorridor(opts) {
        _classCallCheck(this, DrawCorridor);

        var _this = _possibleConstructorReturn(this, (DrawCorridor.__proto__ || Object.getPrototypeOf(DrawCorridor)).call(this, opts));

        _this.type = 'corridor';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditCorridor; //获取编辑对象

        _this._minPointNum = 2; //至少需要点的个数 
        _this._maxPointNum = 9999; //最多允许点的个数 
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawCorridor, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = [];

            if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
            if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

            if (attribute.config) {
                //允许外部传入
                this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
            } else {
                this._minPointNum = this._minPointNum_def;
                this._maxPointNum = this._maxPointNum_def;
            }

            var that = this;
            var addattr = {
                corridor: attr.style2Entity(attribute.style),
                attribute: attribute
            };
            addattr.corridor.positions = new Cesium.CallbackProperty(function (time) {
                return that.getDrawPosition();
            }, false);

            this.entity = dataSource.entities.add(addattr); //创建要素对象
            this.entity._positions_draw = this._positions_draw;

            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.corridor);
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing() {
            var style = this.entity.attribute.style;
            if (!style.clampToGround) {
                var maxHight = (0, _point.getMaxHeight)(this.getDrawPosition());
                if (maxHight != 0) {
                    this.entity.corridor.height = maxHight;
                    style.height = maxHight;

                    if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) this.entity.corridor.extrudedHeight = maxHight + Number(style.extrudedHeight);
                }
            }
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this.getDrawPosition();
            entity.corridor.positions = new Cesium.CallbackProperty(function (time) {
                return entity._positions_draw;
            }, false);
        }
    }]);

    return DrawCorridor;
}(_Draw.DrawPolyline);

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawRectangle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(16);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

var _Attr = __webpack_require__(57);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(19);

var _Edit = __webpack_require__(64);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawRectangle = exports.DrawRectangle = function (_DrawPolyline) {
    _inherits(DrawRectangle, _DrawPolyline);

    //========== 构造方法 ========== 
    function DrawRectangle(opts) {
        _classCallCheck(this, DrawRectangle);

        var _this = _possibleConstructorReturn(this, (DrawRectangle.__proto__ || Object.getPrototypeOf(DrawRectangle)).call(this, opts));

        _this.type = 'rectangle';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditRectangle; //获取编辑对象

        _this._minPointNum = 2; //至少需要点的个数 
        _this._maxPointNum = 2; //最多允许点的个数 
        return _this;
    }

    _createClass(DrawRectangle, [{
        key: 'getRectangle',
        value: function getRectangle() {
            var positions = this.getDrawPosition();
            if (positions.length < 2) return null;
            return Cesium.Rectangle.fromCartesianArray(positions);
        }
        //根据attribute参数创建Entity

    }, {
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = [];

            var that = this;
            var addattr = {
                rectangle: attr.style2Entity(attribute.style),
                attribute: attribute
            };
            addattr.rectangle.coordinates = new Cesium.CallbackProperty(function (time) {
                return that.getRectangle();
            }, false);

            //线：边线宽度大于1时用polyline 
            var lineStyle = _extends({
                "color": attribute.style.outlineColor,
                "width": attribute.style.outlineWidth,
                "opacity": attribute.style.outlineOpacity
            }, attribute.style.outlineStyle || {});
            addattr.polyline = (0, _Attr2.style2Entity)(lineStyle, {
                clampToGround: attribute.style.clampToGround,
                arcType: Cesium.ArcType.RHUMB,
                outline: false,
                show: false
            });

            this.entity = dataSource.entities.add(addattr); //创建要素对象
            this.entity._positions_draw = this._positions_draw;
            this.bindOutline(this.entity, lineStyle); //边线

            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.rectangle);
        }
    }, {
        key: 'bindOutline',
        value: function bindOutline(entity, lineStyle) {
            var attribute = entity.attribute;

            //本身的outline需要隐藏
            entity.rectangle.outline = new Cesium.CallbackProperty(function (time) {
                return attribute.style.outline && attribute.style.outlineWidth == 1;
            }, false);

            //是否显示：边线宽度大于1时
            entity.polyline.show = new Cesium.CallbackProperty(function (time) {
                return attribute.style.outline && attribute.style.outlineWidth > 1;
            }, false);
            entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                if (!entity.polyline.show.getValue(time)) return null;
                if (!entity._positions_draw) return null;

                return attr.getOutlinePositions(entity);
            }, false);
            entity.polyline.width = new Cesium.CallbackProperty(function (time) {
                return entity.rectangle.outlineWidth;
            }, false);
            //虚线等情况下不支持动态修改颜色,只有实线可以动态改颜色。
            if (!lineStyle.lineType || lineStyle.lineType == "solid") {
                entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                    return entity.rectangle.outlineColor.getValue(time);
                }, false));
            }
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing() {
            var style = this.entity.attribute.style;
            if (!style.clampToGround) {
                var maxHight = (0, _point.getMaxHeight)(this.getDrawPosition());
                if (maxHight != 0) {
                    this.entity.rectangle.height = maxHight;
                    style.height = maxHight;

                    if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) this.entity.rectangle.extrudedHeight = maxHight + Number(style.extrudedHeight);
                }
            }
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this._positions_draw;
            //entity.rectangle.coordinates = this.getRectangle(); 
            entity.rectangle.coordinates = new Cesium.CallbackProperty(function (time) {
                if (entity._positions_draw.length < 2) return null;
                return Cesium.Rectangle.fromCartesianArray(entity._positions_draw);
            }, false);
        }
    }]);

    return DrawRectangle;
}(_Draw.DrawPolyline);

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawCircle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(16);

var _Attr = __webpack_require__(40);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(19);

var _Edit = __webpack_require__(65);

var _polygon = __webpack_require__(13);

var _util = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawCircle = exports.DrawCircle = function (_DrawPolyline) {
    _inherits(DrawCircle, _DrawPolyline);

    //========== 构造方法 ========== 
    function DrawCircle(opts) {
        _classCallCheck(this, DrawCircle);

        var _this = _possibleConstructorReturn(this, (DrawCircle.__proto__ || Object.getPrototypeOf(DrawCircle)).call(this, opts));

        _this.type = 'ellipse';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditCircle; //获取编辑对象 

        _this._minPointNum = 2; //至少需要点的个数 
        _this._maxPointNum = 2; //最多允许点的个数
        return _this;
    }

    _createClass(DrawCircle, [{
        key: 'getShowPosition',
        value: function getShowPosition(time) {
            if (this._positions_draw && this._positions_draw.length > 0) return this._positions_draw[0];
            return null;
        }
        //根据attribute参数创建Entity

    }, {
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = [];

            if (attribute.type == "ellipse") //椭圆
                this._maxPointNum = 3;else //圆
                this._maxPointNum = 2;

            var that = this;
            var addattr = {
                position: new Cesium.CallbackProperty(function (time) {
                    return that.getShowPosition(time);
                }, false),
                ellipse: attr.style2Entity(attribute.style),
                attribute: attribute
            };

            //线：边线宽度大于1时用polyline 
            var lineStyle = _extends({
                "color": attribute.style.outlineColor,
                "width": attribute.style.outlineWidth,
                "opacity": attribute.style.outlineOpacity
            }, attribute.style.outlineStyle || {});
            addattr.polyline = (0, _Attr2.style2Entity)(lineStyle, {
                clampToGround: attribute.style.clampToGround,
                arcType: Cesium.ArcType.RHUMB,
                outline: false,
                show: false
            });

            this.entity = dataSource.entities.add(addattr); //创建要素对象 
            this.bindOutline(this.entity, lineStyle); //边线
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.ellipse);
        }
    }, {
        key: 'bindOutline',
        value: function bindOutline(entity, lineStyle) {
            var attribute = entity.attribute;

            //本身的outline需要隐藏
            entity.ellipse.outline = new Cesium.CallbackProperty(function (time) {
                return attribute.style.outline && attribute.style.outlineWidth == 1;
            }, false);

            //是否显示：边线宽度大于1时
            entity.polyline.show = new Cesium.CallbackProperty(function (time) {
                return attribute.style.outline && attribute.style.outlineWidth > 1;
            }, false);
            entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                if (!entity.polyline.show.getValue(time)) return null;

                return attr.getOutlinePositions(entity);
            }, false);
            entity.polyline.width = new Cesium.CallbackProperty(function (time) {
                return entity.ellipse.outlineWidth;
            }, false);

            //虚线等情况下不支持动态修改颜色,只有实线可以动态改颜色。
            if (!lineStyle.lineType || lineStyle.lineType == "solid") {
                entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                    return entity.ellipse.outlineColor.getValue(time);
                }, false));
            }
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing(isLoad) {
            if (!this._positions_draw) return;

            if (isLoad) {
                if (this._positions_draw instanceof Cesium.Cartesian3) {
                    this._positions_draw = [this._positions_draw];
                }
                this.addPositionsForRadius(this._positions_draw[0]);
                return;
            }

            if (this._positions_draw.length < 2) return;

            var style = this.entity.attribute.style;

            //高度处理
            if (!style.clampToGround) {
                var height = this.formatNum(Cesium.Cartographic.fromCartesian(this._positions_draw[0]).height, 2);
                this.entity.ellipse.height = height;
                style.height = height;

                if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) {
                    var extrudedHeight = height + Number(style.extrudedHeight);
                    this.entity.ellipse.extrudedHeight = extrudedHeight;
                }
            }

            //半径处理
            var radius = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
            this.entity.ellipse.semiMinorAxis = radius; //短半轴

            if (this._maxPointNum == 3) {
                //长半轴
                var semiMajorAxis;
                if (this._positions_draw.length == 3) {
                    semiMajorAxis = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[2]), 2);
                } else {
                    semiMajorAxis = radius;
                }
                this.entity.ellipse.semiMajorAxis = semiMajorAxis;

                style.semiMinorAxis = radius;
                style.semiMajorAxis = semiMajorAxis;
            } else {
                this.entity.ellipse.semiMajorAxis = radius;

                style.radius = radius;
            }
        }
    }, {
        key: 'addPositionsForRadius',
        value: function addPositionsForRadius(position) {
            var style = this.entity.attribute.style;

            //获取圆（或椭圆）边线上的坐标点数组
            var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                position: position,
                semiMajorAxis: this.entity.ellipse.semiMajorAxis.getValue(this.viewer.clock.currentTime), //长半轴
                semiMinorAxis: this.entity.ellipse.semiMinorAxis.getValue(this.viewer.clock.currentTime), //短半轴
                rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
            });

            //长半轴上的坐标点
            var majorPos = outerPositions[1];
            this._positions_draw.push(majorPos);

            if (this._maxPointNum == 3) {
                //椭圆
                //短半轴上的坐标点 
                var minorPos = outerPositions[0];
                this._positions_draw.push(minorPos);
            }
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this._positions_draw;
            //this.entity.position = this.getShowPosition();
            entity.position = new Cesium.CallbackProperty(function (time) {
                if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw[0];
                return null;
            }, false);
        }
    }]);

    return DrawCircle;
}(_Draw.DrawPolyline);

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawCylinder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(16);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(56);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(123);

var _polygon = __webpack_require__(13);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawCylinder = exports.DrawCylinder = function (_DrawPolyline) {
    _inherits(DrawCylinder, _DrawPolyline);

    //========== 构造方法 ========== 
    function DrawCylinder(opts) {
        _classCallCheck(this, DrawCylinder);

        var _this = _possibleConstructorReturn(this, (DrawCylinder.__proto__ || Object.getPrototypeOf(DrawCylinder)).call(this, opts));

        _this.type = 'cylinder';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditCylinder; //获取编辑对象

        _this._minPointNum = 2; //至少需要点的个数 
        _this._maxPointNum = 2; //最多允许点的个数 
        return _this;
    }

    _createClass(DrawCylinder, [{
        key: 'getShowPosition',
        value: function getShowPosition(time) {
            if (this._positions_draw && this._positions_draw.length > 1) return (0, _point.addPositionsHeight)(this._positions_draw[0], this.entity.cylinder.length.getValue(time) / 2);
            return null;
        }
        //根据attribute参数创建Entity

    }, {
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = [];

            var that = this;
            var addattr = {
                position: new Cesium.CallbackProperty(function (time) {
                    return that.getShowPosition(time);
                }, false),
                cylinder: attr.style2Entity(attribute.style),
                attribute: attribute
            };

            this.entity = dataSource.entities.add(addattr); //创建要素对象 
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.cylinder);
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing(isLoad) {
            if (!this._positions_draw) return;

            if (isLoad) {
                if (this._positions_draw instanceof Cesium.Cartesian3) {
                    this._positions_draw = [this._positions_draw];
                }
                this.addPositionsForRadius(this._positions_draw[0]);
                return;
            }

            if (this._positions_draw.length < 2) return;

            var style = this.entity.attribute.style;

            //半径处理
            var radius = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
            this.entity.cylinder.bottomRadius = radius;

            style.topRadius = this.entity.cylinder.topRadius.getValue(this.viewer.clock.currentTime);
            style.bottomRadius = radius;
        }
    }, {
        key: 'addPositionsForRadius',
        value: function addPositionsForRadius(position) {
            var style = this.entity.attribute.style;

            //获取圆（或椭圆）边线上的坐标点数组
            var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                position: position,
                semiMajorAxis: style.bottomRadius, //长半轴
                semiMinorAxis: style.bottomRadius //短半轴 
            });

            //长半轴上的坐标点 
            this._positions_draw.push(outerPositions[0]);
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this._positions_draw;
            //this.entity.position = this.getShowPosition();
            entity.position = new Cesium.CallbackProperty(function (time) {
                if (entity._positions_draw && entity._positions_draw.length > 0) return (0, _point.addPositionsHeight)(entity._positions_draw[0], entity.cylinder.length.getValue(time) / 2);
                return null;
            }, false);
        }
    }]);

    return DrawCylinder;
}(_Draw.DrawPolyline);

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
        value: true
});
exports.EditCylinder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(7);

var _Edit = __webpack_require__(29);

var _point = __webpack_require__(2);

var _polygon = __webpack_require__(13);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCylinder = exports.EditCylinder = function (_EditPolygon) {
        _inherits(EditCylinder, _EditPolygon);

        function EditCylinder() {
                _classCallCheck(this, EditCylinder);

                return _possibleConstructorReturn(this, (EditCylinder.__proto__ || Object.getPrototypeOf(EditCylinder)).apply(this, arguments));
        }

        _createClass(EditCylinder, [{
                key: 'getGraphic',

                //取enity对象的对应矢量数据
                value: function getGraphic() {
                        return this.entity.cylinder;
                }
                //修改坐标会回调，提高显示的效率

        }, {
                key: 'changePositionsToCallback',
                value: function changePositionsToCallback() {
                        this._positions_draw = this.entity._positions_draw;

                        var time = this.viewer.clock.currentTime;
                        var style = this.entity.attribute.style;

                        style.topRadius = this.getGraphic().topRadius.getValue(time);
                        this.getGraphic().topRadius = new Cesium.CallbackProperty(function (time) {
                                return style.topRadius;
                        }, false);

                        style.bottomRadius = this.getGraphic().bottomRadius.getValue(time);
                        this.getGraphic().bottomRadius = new Cesium.CallbackProperty(function (time) {
                                return style.bottomRadius;
                        }, false);

                        style.length = this.getGraphic().length.getValue(time);
                        this.getGraphic().length = new Cesium.CallbackProperty(function (time) {
                                return style.length;
                        }, false);
                }
                //图形编辑结束后调用

        }, {
                key: 'finish',
                value: function finish() {
                        this.entity._positions_draw = this._positions_draw;

                        var style = this.entity.attribute.style;
                        this.getGraphic().topRadius = style.topRadius;
                        this.getGraphic().bottomRadius = style.bottomRadius;
                        this.getGraphic().length = style.length;
                }
        }, {
                key: 'bindDraggers',
                value: function bindDraggers() {
                        var that = this;

                        var positions = this.getPosition();
                        var style = this.entity.attribute.style;
                        var time = this.viewer.clock.currentTime;

                        //中心点
                        var index = 0;
                        var position = positions[index];
                        var dragger = draggerCtl.createDragger(this.entityCollection, {
                                position: position,
                                onDrag: function onDrag(dragger, position) {
                                        positions[dragger.index] = position;

                                        //=====全部更新========== 
                                        that.updateDraggers();
                                }
                        });
                        dragger.index = index;
                        this.draggers.push(dragger);

                        //获取圆（或椭圆）边线上的坐标点数组
                        var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                                position: position,
                                semiMajorAxis: style.bottomRadius, //长半轴
                                semiMinorAxis: style.bottomRadius, //短半轴
                                rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
                        });

                        //长半轴上的坐标点
                        index = 1;
                        var majorPos = outerPositions[0];
                        positions[index] = majorPos;
                        var bottomRadiusDragger = draggerCtl.createDragger(this.entityCollection, {
                                position: majorPos,
                                type: draggerCtl.PointType.EditAttr,
                                tooltip: _Tooltip.message.dragger.editRadius,
                                onDrag: function onDrag(dragger, position) {
                                        positions[dragger.index] = position;

                                        var radius = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
                                        style.bottomRadius = radius;

                                        that.updateDraggers();
                                }
                        });
                        bottomRadiusDragger.index = index;
                        this.draggers.push(bottomRadiusDragger);

                        //创建高度拖拽点  
                        index = 2;
                        var position = (0, _point.addPositionsHeight)(positions[0], style.length);
                        positions[index] = position;
                        var draggerTop = draggerCtl.createDragger(this.entityCollection, {
                                position: position,
                                type: draggerCtl.PointType.MoveHeight,
                                tooltip: _Tooltip.message.dragger.moveHeight,
                                onDrag: function onDrag(dragger, position) {
                                        positions[dragger.index] = position;
                                        var length = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
                                        style.length = length;

                                        that.updateDraggers();
                                }
                        });
                        draggerTop.index = index;
                        this.draggers.push(draggerTop);

                        // if (style.topRadius > 0) {
                        //     //获取圆（或椭圆）边线上的坐标点数组
                        //     var outerPositionsTop = getEllipseOuterPositions({
                        //         position: position,
                        //         semiMajorAxis: style.topRadius, //长半轴
                        //         semiMinorAxis: style.topRadius, //短半轴
                        //         rotation: Cesium.Math.toRadians(Number(style.rotation || 0)),
                        //     }); 
                        //     //长半轴上的坐标点
                        //     index = 3
                        //     var majorPos = outerPositionsTop[0];
                        //     positions[index] = majorPos;
                        //     var topRadiusDragger = draggerCtl.createDragger(this.entityCollection, {
                        //         position: majorPos,
                        //         type: draggerCtl.PointType.EditAttr,
                        //         tooltip: message.dragger.editRadius,
                        //         onDrag: function (dragger, position) {
                        //             var center = positions[2]

                        //             //高度改为圆锥高度
                        //             var height = Cesium.Cartographic.fromCartesian(center).height;
                        //             var car = Cesium.Cartographic.fromCartesian(position)
                        //             position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
                        //             dragger.position.setValue(position)

                        //             position = position
                        //             positions[dragger.index] = position;

                        //             var radius = that.formatNum(Cesium.Cartesian3.distance(center, position), 2);
                        //             style.topRadius = radius;

                        //             that.updateDraggers();
                        //         }
                        //     });
                        //     topRadiusDragger.index = index;
                        //     this.draggers.push(topRadiusDragger);
                        // }

                }
        }]);

        return EditCylinder;
}(_Edit.EditPolygon);

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawEllipsoid = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(16);

var _Attr = __webpack_require__(58);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(66);

var _polygon = __webpack_require__(13);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawEllipsoid = exports.DrawEllipsoid = function (_DrawPolyline) {
    _inherits(DrawEllipsoid, _DrawPolyline);

    //========== 构造方法 ========== 
    function DrawEllipsoid(opts) {
        _classCallCheck(this, DrawEllipsoid);

        var _this = _possibleConstructorReturn(this, (DrawEllipsoid.__proto__ || Object.getPrototypeOf(DrawEllipsoid)).call(this, opts));

        _this.type = 'ellipsoid';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditEllipsoid; //获取编辑对象

        _this._minPointNum = 2; //至少需要点的个数 
        _this._maxPointNum = 3; //最多允许点的个数 
        return _this;
    }

    _createClass(DrawEllipsoid, [{
        key: 'getShowPosition',
        value: function getShowPosition(time) {
            if (this._positions_draw && this._positions_draw.length > 0) return this._positions_draw[0];
            return null;
        }
        //根据attribute参数创建Entity

    }, {
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = [];

            var that = this;
            var addattr = {
                position: new Cesium.CallbackProperty(function (time) {
                    return that.getShowPosition(time);
                }, false),
                ellipsoid: attr.style2Entity(attribute.style),
                attribute: attribute
            };

            this.entity = dataSource.entities.add(addattr); //创建要素对象 
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.ellipsoid);
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing(isLoad) {
            if (!this._positions_draw) return;

            if (isLoad) {
                if (this._positions_draw instanceof Cesium.Cartesian3) {
                    this._positions_draw = [this._positions_draw];
                }
                this.addPositionsForRadius(this._positions_draw[0]);
                return;
            }

            if (this._positions_draw.length < 2) return;

            var style = this.entity.attribute.style;

            //半径处理
            var radius = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
            style.extentRadii = radius; //短半轴
            style.heightRadii = radius;

            //长半轴
            var semiMajorAxis;
            if (this._positions_draw.length == 3) {
                semiMajorAxis = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[2]), 2);
            } else {
                semiMajorAxis = radius;
            }
            style.widthRadii = semiMajorAxis;

            this.updateRadii(style);
        }
    }, {
        key: 'updateRadii',
        value: function updateRadii(style) {
            this.entity.ellipsoid.radii.setValue(new Cesium.Cartesian3(style.extentRadii, style.widthRadii, style.heightRadii));
        }
    }, {
        key: 'addPositionsForRadius',
        value: function addPositionsForRadius(position) {
            var style = this.entity.attribute.style;

            //获取圆（或椭圆）边线上的坐标点数组
            var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                position: position,
                semiMajorAxis: Number(style.extentRadii), //长半轴
                semiMinorAxis: Number(style.widthRadii), //短半轴 
                rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
            });

            //长半轴上的坐标点 
            this._positions_draw.push(outerPositions[0]);

            //短半轴上的坐标点  
            this._positions_draw.push(outerPositions[1]);
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            // this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象   
            // this.entity._positions_draw = this._positions_draw;
            // this.entity.position = this.getShowPosition(); 

            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this._positions_draw;
            entity.position = new Cesium.CallbackProperty(function (time) {
                if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw[0];
                return null;
            }, false);
        }
    }]);

    return DrawEllipsoid;
}(_Draw.DrawPolyline);

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawWall = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(16);

var _Attr = __webpack_require__(53);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(67);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawWall = exports.DrawWall = function (_DrawPolyline) {
    _inherits(DrawWall, _DrawPolyline);

    //========== 构造方法 ========== 
    function DrawWall(opts) {
        _classCallCheck(this, DrawWall);

        var _this = _possibleConstructorReturn(this, (DrawWall.__proto__ || Object.getPrototypeOf(DrawWall)).call(this, opts));

        _this.type = 'wall';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditWall; //获取编辑对象

        _this._minPointNum = 2; //至少需要点的个数 
        _this._maxPointNum = 9999; //最多允许点的个数 

        _this.maximumHeights = null;
        _this.minimumHeights = null;
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawWall, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = [];

            if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
            if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

            if (attribute.config) {
                //允许外部传入
                this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
            } else {
                this._minPointNum = this._minPointNum_def;
                this._maxPointNum = this._maxPointNum_def;
            }

            this.maximumHeights = [];
            this.minimumHeights = [];

            var that = this;
            var addattr = {
                wall: attr.style2Entity(attribute.style),
                attribute: attribute
            };
            addattr.wall.positions = new Cesium.CallbackProperty(function (time) {
                return that.getDrawPosition();
            }, false);
            addattr.wall.minimumHeights = new Cesium.CallbackProperty(function (time) {
                return that.getMinimumHeights();
            }, false);
            addattr.wall.maximumHeights = new Cesium.CallbackProperty(function (time) {
                return that.getMaximumHeights();
            }, false);

            this.entity = dataSource.entities.add(addattr); //创建要素对象   
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.wall);
        }
    }, {
        key: 'getMaximumHeights',
        value: function getMaximumHeights(entity) {
            return this.maximumHeights;
        }
    }, {
        key: 'getMinimumHeights',
        value: function getMinimumHeights(entity) {
            return this.minimumHeights;
        }
    }, {
        key: 'updateAttrForDrawing',
        value: function updateAttrForDrawing() {
            var style = this.entity.attribute.style;
            var position = this.getDrawPosition();
            var len = position.length;

            this.maximumHeights = new Array(len);
            this.minimumHeights = new Array(len);

            for (var i = 0; i < len; i++) {
                var height = Cesium.Cartographic.fromCartesian(position[i]).height;
                this.minimumHeights[i] = height;
                this.maximumHeights[i] = height + Number(style.extrudedHeight);
            }
        }
        //获取外部entity的坐标到_positions_draw

    }, {
        key: 'setDrawPositionByEntity',
        value: function setDrawPositionByEntity(entity) {
            var positions = this.getPositions(entity);
            this._positions_draw = positions;

            var time = this.viewer.clock.currentTime;
            this._minimumHeights = entity.wall.minimumHeights && entity.wall.minimumHeights.getValue(time);
            this._maximumHeights = entity.wall.maximumHeights && entity.wall.maximumHeights.getValue(time);
            if (!this._minimumHeights || this._minimumHeights.length == 0 || !this._maximumHeights || this._maximumHeights.length == 0) return;

            entity.attribute.style = entity.attribute.style || {};
            entity.attribute.style.extrudedHeight = this._maximumHeights[0] - this._minimumHeights[0];
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象  
            // this.entity.wall.positions = this.getDrawPosition();
            // this.entity.wall.minimumHeights = this.getMinimumHeights();
            // this.entity.wall.maximumHeights = this.getMaximumHeights(); 

            entity._positions_draw = this.getDrawPosition();
            entity.wall.positions = new Cesium.CallbackProperty(function (time) {
                return entity._positions_draw;
            }, false);

            entity._minimumHeights = this.getMinimumHeights();
            entity.wall.minimumHeights = new Cesium.CallbackProperty(function (time) {
                return entity._minimumHeights;
            }, false);

            entity._maximumHeights = this.getMaximumHeights();
            entity.wall.maximumHeights = new Cesium.CallbackProperty(function (time) {
                return entity._maximumHeights;
            }, false);
        }
    }]);

    return DrawWall;
}(_Draw.DrawPolyline);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawPlane = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(24);

var _Attr = __webpack_require__(49);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(68);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPlane = exports.DrawPlane = function (_DrawPoint) {
    _inherits(DrawPlane, _DrawPoint);

    //========== 构造方法 ========== 
    function DrawPlane(opts) {
        _classCallCheck(this, DrawPlane);

        var _this = _possibleConstructorReturn(this, (DrawPlane.__proto__ || Object.getPrototypeOf(DrawPlane)).call(this, opts));

        _this.type = 'plane';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditPlane; //获取编辑对象 
        return _this;
    }
    //根据attribute参数创建Entity


    _createClass(DrawPlane, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = null;

            var that = this;
            var addattr = {
                position: new Cesium.CallbackProperty(function (time) {
                    return that.getDrawPosition();
                }, false),
                plane: attr.style2Entity(attribute.style),
                attribute: attribute
            };
            this.entity = dataSource.entities.add(addattr); //创建要素对象
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.plane);
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this.getDrawPosition();
            entity.position = new Cesium.CallbackProperty(function (time) {
                return entity._positions_draw;
            }, false);
        }
    }]);

    return DrawPlane;
}(_Draw.DrawPoint);

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawBox = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(24);

var _Attr = __webpack_require__(51);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(69);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawBox = exports.DrawBox = function (_DrawPoint) {
    _inherits(DrawBox, _DrawPoint);

    //========== 构造方法 ========== 
    function DrawBox(opts) {
        _classCallCheck(this, DrawBox);

        var _this = _possibleConstructorReturn(this, (DrawBox.__proto__ || Object.getPrototypeOf(DrawBox)).call(this, opts));

        _this.type = 'box';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _Edit.EditBox; //获取编辑对象 
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawBox, [{
        key: 'createFeature',
        value: function createFeature(attribute, dataSource) {
            dataSource = dataSource || this.dataSource;
            this._positions_draw = null;

            var that = this;
            var addattr = {
                position: new Cesium.CallbackProperty(function (time) {
                    return that.getDrawPosition();
                }, false),
                box: attr.style2Entity(attribute.style),
                attribute: attribute
            };
            this.entity = dataSource.entities.add(addattr); //创建要素对象
            return this.entity;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            return attr.style2Entity(style, entity.box);
        }
        //图形绘制结束后调用

    }, {
        key: 'finish',
        value: function finish() {
            var entity = this.entity;

            entity.editing = this.getEditClass(entity); //绑定编辑对象   

            entity._positions_draw = this.getDrawPosition();
            entity.position = new Cesium.CallbackProperty(function (time) {
                return entity._positions_draw;
            }, false);
        }
    }]);

    return DrawBox;
}(_Draw.DrawPoint);

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Popup = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _zepto = __webpack_require__(8);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _index = __webpack_require__(20);

var attrUtil = _interopRequireWildcard(_index);

var _config2Entity = __webpack_require__(32);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//该类不仅仅是popup处理，是所有一些有关单击事件的统一处理入口（从效率考虑）。

var Popup = exports.Popup = function () {
    //========== 构造方法 ========== 
    function Popup(viewer, options) {
        _classCallCheck(this, Popup);

        this.viewer = viewer;
        this.options = options || {};

        this._isOnly = true;
        this._enable = true;
        this._depthTest = true;
        this.viewerid = viewer._container.id;
        this.objPopup = {};

        this.highlighted = {
            feature: undefined,
            originalColor: new Cesium.Color()
        };
        this.defaultHighlightedClr = Cesium.Color.fromCssColorString("#95e40c");

        //兼容历史接口
        this.getPopupForConfig = _util.getPopupForConfig;
        this.getPopup = _util.getPopup;

        //添加弹出框 
        var infoDiv = '<div id="' + this.viewerid + '-okay3d-pupup-all" ></div>';
        (0, _zepto.zepto)("#" + this.viewerid).append(infoDiv);

        //单击事件
        this.viewer.mars.on(_MarsClass.eventType.click, this.mousePickingClick, this);
        //移动事件
        this.viewer.scene.postRender.addEventListener(this.bind2scene, this);
    }

    //========== 对外属性 ==========  
    //显示单个模式


    _createClass(Popup, [{
        key: 'mousePickingClick',


        //========== 方法 ========== 

        //鼠标点击事件
        value: function mousePickingClick(event) {
            this.removeFeatureForImageryLayer();
            this.removeFeatureFor3dtiles();

            if (this._isOnly) this.close();
            if (!this._enable) return;

            var position = event.position;
            var pickedObject;
            try {
                pickedObject = this.viewer.scene.pick(position);
            } catch (e) {}

            var isFindPopup = false;
            var isFindClick = false;

            //存在单击的对象
            if (Cesium.defined(pickedObject)) {
                //普通entity对象 && viewer.scene.pickPositionSupported
                if (Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
                    var entity = pickedObject.id;

                    //popup
                    if (Cesium.defined(entity.popup)) {
                        var cartesian;
                        if (entity.billboard || entity.label || entity.point || entity.model) {
                            //对点状数据做特殊处理，
                            cartesian = entity.position;
                        } else {
                            cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
                        }
                        this.show(entity, cartesian, position);
                        isFindPopup = true;
                    }

                    //单击对象所关联的管理类(基于MarsClass)，进行click事件抛出。
                    if (entity.eventTarget && entity.eventTarget.fire) {
                        entity.eventTarget.fire(_MarsClass.eventType.click, {
                            sourceTarget: entity,
                            position: position
                        });
                        isFindClick = true;
                    }
                    //加统一的click处理
                    else if (entity.click && typeof entity.click === 'function') {
                            entity.click(entity, position);
                            isFindClick = true;
                        }
                }
                //单体化3dtiles数据的处理(如：BIM的构件，城市白膜建筑)
                else if (Cesium.defined(pickedObject.tileset) && Cesium.defined(pickedObject.getProperty)) {
                        //取属性
                        var attr = {};
                        var names = pickedObject.getPropertyNames();
                        for (var i = 0; i < names.length; i++) {
                            var name = names[i];
                            if (!pickedObject.hasProperty(name)) continue;

                            var val = pickedObject.getProperty(name);
                            if (val == null) continue;
                            attr[name] = val;
                        }

                        var cfg = pickedObject.tileset._config || pickedObject.tileset;
                        if (cfg) {
                            //popup
                            if (Cesium.defined(cfg.popup)) {
                                var cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
                                var item = {
                                    id: pickedObject._batchId,
                                    popup: (0, _util.bindLayerPopup)(cfg.popup, function (entity) {
                                        return (0, _util.getPopupForConfig)(cfg, attr);
                                    }),
                                    popupPosition: cfg.popupPosition,
                                    data: attr
                                };
                                this.show(item, cartesian, position);
                                isFindPopup = true;
                            }

                            //高亮显示单体对象
                            if (cfg.showClickFeature) {
                                if (cfg.clickFeatureColor) {
                                    //兼容历史写法
                                    cfg.pickFeatureStyle = cfg.pickFeatureStyle || {};
                                    cfg.pickFeatureStyle.color = cfg.clickFeatureColor;
                                }
                                this.showFeatureFor3dtiles(pickedObject, cfg.pickFeatureStyle);
                            }

                            //单击对象所关联的管理类(基于MarsClass)，进行click事件抛出。
                            if (pickedObject.tileset.eventTarget && pickedObject.tileset.eventTarget.fire) {
                                pickedObject.tileset.eventTarget.fire(_MarsClass.eventType.click, {
                                    sourceTarget: pickedObject,
                                    tileset: pickedObject.tileset,
                                    data: attr,
                                    position: position
                                });
                                isFindClick = true;
                            }
                            //加统一的click处理
                            else if (cfg.click && typeof cfg.click === 'function') {
                                    cfg.click({ attr: attr, feature: pickedObject, tileset: pickedObject.tileset }, position);
                                    isFindClick = true;
                                }
                        }
                    }
                    //primitive对象 
                    else if (Cesium.defined(pickedObject.primitive)) {
                            var primitive = pickedObject.primitive;

                            //popup
                            if (Cesium.defined(primitive.popup)) {
                                var cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
                                this.show(primitive, cartesian, position);
                                isFindPopup = true;
                            }

                            //单击对象所关联的管理类(基于MarsClass)，进行click事件抛出。
                            if (primitive.eventTarget && primitive.eventTarget.fire) {
                                primitive.eventTarget.fire(_MarsClass.eventType.click, {
                                    sourceTarget: primitive,
                                    position: position
                                });
                                isFindClick = true;
                            }
                            //加统一的click处理
                            else if (primitive.click && typeof primitive.click === 'function') {
                                    primitive.click(primitive, position);
                                    isFindClick = true;
                                }
                        } else {
                            //未单击到矢量或模型数据时  
                            marslog.log(pickedObject);
                        }
            }

            if (!isFindPopup) {
                this.pickImageryLayerFeatures(position);
            }

            //单击地图空白（未单击到矢量或模型数据）时
            if (!isFindClick) {
                this.viewer.mars.fire(_MarsClass.eventType.clickMap, {
                    position: position
                });
            }
        }

        //瓦片图层上的矢量对象，动态获取

    }, {
        key: 'pickImageryLayerFeatures',
        value: function pickImageryLayerFeatures(position) {
            var scene = this.viewer.scene;
            var pickRay = scene.camera.getPickRay(position); //position : Cesium.Cartesian2
            var imageryLayerFeaturePromise = scene.imageryLayers.pickImageryLayerFeatures(pickRay, scene);
            if (!Cesium.defined(imageryLayerFeaturePromise)) {
                return;
            }

            var that = this;
            Cesium.when(imageryLayerFeaturePromise, function (features) {
                if (!Cesium.defined(features) || features.length === 0) {
                    return;
                }

                //单击选中的要素对象
                var feature = features[0];
                if (feature.imageryLayer == null || feature.imageryLayer.config == null) return;
                var cfg = feature.imageryLayer.config;

                that.pickFeatures(feature, position, cfg);

                //单击对象所关联的管理类(基于MarsClass)，进行click事件抛出。
                if (feature.imageryLayer.eventTarget && feature.imageryLayer.eventTarget.fire) {
                    feature.imageryLayer.eventTarget.fire(_MarsClass.eventType.click, {
                        sourceTarget: feature.imageryLayer,
                        features: features,
                        position: position
                    });
                } else if (cfg.click && typeof cfg.click === 'function') {
                    cfg.click(features, position); //返回所有的features
                }
            }, function (e) {
                marslog.warn(e);
            });
        }
    }, {
        key: 'pickFeatures',
        value: function pickFeatures(feature, viewerPoint, cfg) {
            //属性
            var attr = feature.properties;
            if (!Cesium.defined(attr) && feature.data) {
                attr = feature.data.properties || feature.data.attributes;
            }

            //显示popup
            var result = (0, _util.getPopupForConfig)(cfg, attr);
            if (result) {
                var position = (0, _point.getCurrentMousePosition)(this.viewer.scene, viewerPoint);
                this.show({
                    id: 'imageryLayerFeaturePromise',
                    popup: {
                        html: result,
                        anchor: cfg.popupAnchor || [0, -12]
                    },
                    popupPosition: cfg.popupPosition
                }, position, viewerPoint);
            }

            //显示要素
            if (cfg.showClickFeature && feature.data) {
                if (feature.data.geometry && JSON.stringify(feature.data.geometry).length > Cesium.defaultValue(cfg.pickFeatureMax, 9000)) {
                    //配置有maxLength时，屏蔽大数据下的页面卡顿 
                    marslog.log(feature.data.geometry);
                    return;
                }

                this.showFeatureForImageryLayer(feature.data, cfg.pickFeatureStyle);
            }
        }

        //popup处理

    }, {
        key: 'show',
        value: function show(entity, cartesian, viewPoint) {
            if (entity == null || entity.popup == null) return;

            if (!cartesian) {
                //外部直接传入entity调用show时，可以不传入坐标，自动取值
                cartesian = attrUtil.getCenterPosition(entity);
            }

            //对点状贴地数据做特殊处理，
            var graphic = entity.billboard || entity.label || entity.point || entity.model;
            if (graphic && graphic.heightReference) {
                cartesian = (0, _point.getPositionValue)(cartesian);

                var tempCarto = Cesium.Cartographic.fromCartesian(cartesian);
                if (tempCarto) {
                    // && tempCarto.height == 0
                    var that = this;
                    if (graphic.heightReference._value == Cesium.HeightReference.CLAMP_TO_GROUND) {
                        //贴地点，重新计算高度
                        cartesian = (0, _point.setPositionSurfaceHeight)(this.viewer, cartesian, {
                            asyn: true,
                            callback: function callback(newHeight, cartOld) {
                                //marslog.log("原始高度为：" + cartOld.height.toFixed(2) + ",贴地高度：" + newHeight.toFixed(2))

                                var cartesianNew = Cesium.Cartesian3.fromRadians(cartOld.longitude, cartOld.latitude, newHeight);
                                that._showView(entity, cartesianNew, viewPoint);
                            }
                        });
                        return;
                    } else if (graphic.heightReference._value == Cesium.HeightReference.RELATIVE_TO_GROUND) {
                        cartesian = (0, _point.setPositionSurfaceHeight)(this.viewer, cartesian, {
                            relativeHeight: true,
                            asyn: true,
                            callback: function callback(newHeight, cartOld) {
                                //marslog.log("原始高度为：" + cartOld.height.toFixed(2) + ",贴地高度：" + newHeight.toFixed(2))

                                var cartesianNew = Cesium.Cartesian3.fromRadians(cartOld.longitude, cartOld.latitude, newHeight);
                                that._showView(entity, cartesianNew, viewPoint);
                            }
                        });
                        return;
                    }
                }
            }

            this._showView(entity, cartesian, viewPoint);
        }
    }, {
        key: '_showView',
        value: function _showView(entity, cartesian, viewPoint) {
            var eleId = this.getPopupId(entity);
            this.close(eleId);

            this.objPopup[eleId] = {
                id: entity.id,
                popup: entity.popup,
                popupPosition: entity.popupPosition, //配置的固定位置 类似弹窗
                entity: entity,
                cartesian: cartesian,
                viewPoint: viewPoint
            };

            //显示内容
            var inhtml;
            if (_typeof(entity.popup) === 'object') {
                inhtml = entity.popup.html;
                this.objPopup[eleId].onAdd = entity.popup.onAdd;
                this.objPopup[eleId].onRemove = entity.popup.onRemove;

                if (typeof entity.popup.visible === 'function') {
                    if (!entity.popup.visible(entity)) {
                        return;
                    }
                }
            } else {
                inhtml = entity.popup;
            }
            if (!inhtml) return;

            var that = this;
            if (typeof inhtml === 'function') {
                //回调方法 
                inhtml = inhtml(entity, cartesian, function (inhtml) {
                    that._camera_cache = null;
                    (0, _zepto.zepto)("#" + eleId).remove();
                    that._showHtml(inhtml, eleId, entity, cartesian, viewPoint);
                });
            }

            if (!inhtml) return;

            this._showHtml(inhtml, eleId, entity, cartesian, viewPoint);
        }
    }, {
        key: 'getItem',
        value: function getItem(eleId) {
            return this.objPopup[eleId];
        }
    }, {
        key: '_showHtml',
        value: function _showHtml(inhtml, eleId, entity, cartesian, viewPoint) {
            (0, _zepto.zepto)('#' + this.viewerid + '-okay3d-pupup-all').append('<div id="' + eleId + '" class="okay3d-popup">' + '            <a id="' + eleId + '-popup-close" data-id="' + eleId + '" class="okay3d-popup-close-button okay3d-popup-color" >×</a>' + '            <div class="okay3d-popup-content-wrapper okay3d-popup-background">' + '                <div class="okay3d-popup-content okay3d-popup-color">' + inhtml + '</div>' + '            </div>' + '            <div id="' + eleId + '-popup-btmtip" class="okay3d-popup-tip-container"><div class="okay3d-popup-tip okay3d-popup-background"></div></div>' + '        </div>');

            var that = this;
            (0, _zepto.zepto)('#' + eleId + '-popup-close').click(function () {
                var eleId = (0, _zepto.zepto)(this).attr("data-id");
                that.close(eleId, true);
            });

            //计算显示位置
            if (entity.popupPosition) {
                //固定显示，类似弹窗
                this.showFixViewPoint(eleId, entity.popup, entity.popupPosition);
                (0, _zepto.zepto)('#' + eleId + '-popup-btmtip').remove(); //去掉小箭头
            } else {
                this._camera_cache = null;

                var result = this.updateViewPoint(eleId, cartesian, entity.popup, viewPoint);
                if (!result && this._depthTest) {
                    this.close(eleId);
                    return;
                }
            }

            //popup的DOM添加到页面的回调方法
            if (this.objPopup[eleId] && this.objPopup[eleId].onAdd) {
                this.objPopup[eleId].onAdd(eleId, entity);
            }
        }
    }, {
        key: 'updateViewPoint',
        value: function updateViewPoint(eleId, position, popup, point) {
            var _position = (0, _point.getPositionValue)(position);
            if (!Cesium.defined(_position)) {
                return false;
            }

            //如果视角和位置都没有变化，直接返回
            var camera = this.viewer.camera;
            var _thiscache = _position.x + '=' + _position.y + '-' + _position.z + '-' + camera.positionWC.x + '=' + camera.positionWC.y + '-' + camera.positionWC.z + '-' + camera.heading + '-' + camera.pitch + '-' + camera.roll;
            if (_thiscache == this._camera_cache) {
                return true;
            }
            this._camera_cache = _thiscache;
            //如果视角和位置都没有变化，直接返回

            var newpoint = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, _position);
            if (Cesium.defined(newpoint)) {
                point = newpoint;
                if (this.objPopup[eleId]) this.objPopup[eleId].viewPoint = newpoint;
            }

            var _dom = (0, _zepto.zepto)("#" + eleId);
            if (!Cesium.defined(point)) {
                marslog.log('wgs84ToWindowCoordinates无法转换为屏幕坐标');
                _dom.hide();
                return true;
            }

            //判断是否在球的背面
            var scene = this.viewer.scene;
            if (this._depthTest && scene.mode === Cesium.SceneMode.SCENE3D) {
                //三维模式下  
                var occluder = new Cesium.EllipsoidalOccluder(scene.globe.ellipsoid, scene.camera.positionWC);
                var visible = occluder.isPointVisible(_position);
                //visible为true说明点在球的正面，否则点在球的背面。 
                //需要注意的是不能用这种方法判断点的可见性，如果球放的比较大，点跑到屏幕外面，它返回的依然为true
                if (!visible) {
                    _dom.hide();
                    return true;
                }
            }
            //判断是否在球的背面

            _dom.show();

            //更新html ，实时更新
            if ((typeof popup === 'undefined' ? 'undefined' : _typeof(popup)) === 'object' && popup.timeRender && popup.html && typeof popup.html === 'function') {
                var inhtml = popup.html(this.objPopup[eleId] && this.objPopup[eleId].entity, _position);
                (0, _zepto.zepto)("#" + eleId + " .okay3d-popup-content").html(inhtml);
            }

            var x = point.x - _dom.width() / 2;
            var y = point.y - _dom.height();

            if (popup && (typeof popup === 'undefined' ? 'undefined' : _typeof(popup)) === 'object' && popup.anchor) {
                x += popup.anchor[0];
                y += popup.anchor[1];
            }
            _dom.css('transform', 'translate3d(' + x + 'px,' + y + 'px, 0)');

            return true;
        }

        //固定显示再一个配置的popupPosition位置（类似弹窗）

    }, {
        key: 'showFixViewPoint',
        value: function showFixViewPoint(eleId, popup, popupPosition) {
            //更新html ，实时更新
            if ((typeof popup === 'undefined' ? 'undefined' : _typeof(popup)) === 'object' && popup.timeRender && popup.html && typeof popup.html === 'function') {
                var inhtml = popup.html(this.objPopup[eleId] && this.objPopup[eleId].entity, _position);
                (0, _zepto.zepto)("#" + eleId + " .okay3d-popup-content").html(inhtml);
            }

            var _dom = (0, _zepto.zepto)("#" + eleId);

            var x = 0;
            if (Cesium.defined(popupPosition.left)) x = popupPosition.left;
            if (Cesium.defined(popupPosition.right)) {
                x = document.documentElement.clientWidth - _dom.width() - popupPosition.right;
            }

            var y = 0;
            if (Cesium.defined(popupPosition.top)) y = popupPosition.top;
            if (Cesium.defined(popupPosition.bottom)) {
                y = document.documentElement.clientHeight - _dom.height() - popupPosition.bottom;
            }

            _dom.css('transform', 'translate3d(' + x + 'px,' + y + 'px, 0)');

            return true;
        }
    }, {
        key: 'bind2scene',
        value: function bind2scene() {
            for (var i in this.objPopup) {
                var item = this.objPopup[i];
                if (item.popupPosition) continue;

                var result = this.updateViewPoint(i, item.cartesian, item.popup, item.viewPoint);
                if (!result && this._depthTest) {
                    this.close(i);
                }
            }
        }
    }, {
        key: 'getPopupId',
        value: function getPopupId(entity) {
            var eleId = this.viewerid + 'popup_' + ((entity.id || "") + "").replace(new RegExp("[^0-9a-zA-Z\_]", "gm"), "_");
            return eleId;
        }
    }, {
        key: 'close',
        value: function close(eleId, removFea) {
            if (!this._isOnly && eleId) {
                if ((typeof eleId === 'undefined' ? 'undefined' : _typeof(eleId)) === 'object') {
                    //传入参数是eneity对象                
                    eleId = this.getPopupId(eleId);
                }

                for (var i in this.objPopup) {
                    if (eleId == this.objPopup[i].id || eleId == i) {

                        //popup的DOM从页面移除的回调方法
                        if (this.objPopup[i] && this.objPopup[i].onRemove) {
                            this.objPopup[i].onRemove(i, this.objPopup[i].entity);
                        }

                        (0, _zepto.zepto)("#" + i).remove();
                        delete this.objPopup[i];
                        break;
                    }
                }
            } else {
                for (var i in this.objPopup) {
                    //popup的DOM从页面移除的回调方法
                    if (this.objPopup[i] && this.objPopup[i].onRemove) {
                        this.objPopup[i].onRemove(i, this.objPopup[i].entity);
                    }
                }

                (0, _zepto.zepto)('#' + this.viewerid + '-okay3d-pupup-all').empty();
                this.objPopup = {};
            }
            this._camera_cache = null;

            if (removFea) {
                this.removeFeatureForImageryLayer();
                this.removeFeatureFor3dtiles();
            }
        }

        //=====================单击高亮对象处理========================
        //单击Tile瓦片时同步，高亮显示要素处理

    }, {
        key: 'removeFeatureForImageryLayer',
        value: function removeFeatureForImageryLayer() {
            if (this.lastShowFeature == null) return;
            this.viewer.dataSources.remove(this.lastShowFeature);
            this.lastShowFeature = null;
        }
    }, {
        key: 'showFeatureForImageryLayer',
        value: function showFeatureForImageryLayer(item, style) {
            var that = this;
            this.removeFeatureForImageryLayer();

            var feature = item;
            if (item.geometryType && item.geometryType.indexOf('esri') != -1) {
                //arcgis图层时 
                var L = window.okay3d.L || window.L;
                if (L && L.esri) {
                    feature = L.esri.Util.arcgisToGeoJSON(item.geometry);
                } else {
                    marslog.warn('需要引入 mars-esri 插件解析arcgis标准的json数据！');
                    return;
                }
            } else if (item.geometry && item.geometry.type) {
                var L = window.okay3d.L || window.L;
                if (L) {
                    //处理数据里面的坐标为4326
                    var geojson = L.geoJSON(item.geometry, {
                        coordsToLatLng: function coordsToLatLng(coords) {
                            if (coords[0] > 180 || coords[0] < -180) {
                                return L.CRS.EPSG3857.unproject(L.point(coords[0], coords[1]));
                            }
                            return new L.LatLng(coords[1], coords[0], coords[2]);
                        }
                    });
                    feature = geojson.toGeoJSON();
                }
            }

            if (feature == null) return;

            var loadOpts;
            if (style) {
                loadOpts = {
                    clampToGround: Cesium.defaultValue(style.clampToGround, false),
                    fill: Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 0.5))),
                    stroke: Cesium.Color.fromCssColorString(style.outlineColor || style.color || "#FFFFFF").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0))),
                    strokeWidth: Cesium.defaultValue(style.outlineWidth, 1)
                };
            }

            var dataSource = Cesium.GeoJsonDataSource.load(feature, loadOpts);
            dataSource.then(function (dataSource) {
                that.viewer.dataSources.add(dataSource);
                that.lastShowFeature = dataSource;

                if (style) {
                    var entities = dataSource.entities.values;
                    (0, _config2Entity.style2Entity)(entities, style);

                    if (Cesium.defined(style.showTime)) {
                        //定时自动关闭
                        setTimeout(function () {
                            that.removeFeatureForImageryLayer();
                        }, style.showTime);
                    }
                }
            }).otherwise(function (error) {
                marslog.warn(error);
            });
        }

        //单击3dtiles单体化，高亮显示构件处理

    }, {
        key: 'removeFeatureFor3dtiles',
        value: function removeFeatureFor3dtiles() {
            if (Cesium.defined(this.highlighted.feature)) {
                try {
                    this.highlighted.feature.color = this.highlighted.originalColor;
                } catch (ex) {}
                this.highlighted.feature = undefined;
            }
        }
    }, {
        key: 'showFeatureFor3dtiles',
        value: function showFeatureFor3dtiles(pickedFeature, style) {
            this.removeFeatureFor3dtiles();
            this.highlighted.feature = pickedFeature;

            Cesium.Color.clone(pickedFeature.color, this.highlighted.originalColor);

            if (style) {
                pickedFeature.color = Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));
            } else {
                pickedFeature.color = this.defaultHighlightedClr;
            }
        }

        //=================================================


    }, {
        key: 'destroy',
        value: function destroy() {
            this.close();
            this.viewer.scene.postRender.removeEventListener(this.bind2scene, this);
            this.viewer.mars.off(_MarsClass.eventType.click, this.mousePickingClick, this);

            (0, _zepto.zepto)('#' + this.viewerid + '-okay3d-pupup-all').remove();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: 'isOnly',
        get: function get() {
            return this._isOnly;
        },
        set: function set(val) {
            this._isOnly = val;
        }

        //是否禁用

    }, {
        key: 'enable',
        get: function get() {
            return this._enable;
        },
        set: function set(value) {
            this._enable = value;
            if (!value) {
                this.close();
            }
        }

        //是否打开深度判断（true时判断是否在球背面）

    }, {
        key: 'depthTest',
        get: function get() {
            return this._depthTest;
        },
        set: function set(value) {
            this._depthTest = value;
        }
    }]);

    return Popup;
}();

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tooltip = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _zepto = __webpack_require__(8);

var _point = __webpack_require__(2);

var _util = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tooltip = exports.Tooltip = function () {
    //========== 构造方法 ========== 
    function Tooltip(viewer, options) {
        _classCallCheck(this, Tooltip);

        this.viewer = viewer;
        this.options = options || {};

        this._enable = true;
        this.viewerid = viewer._container.id;
        this.tooltipcontentid = this.viewerid + '-okay3d-tooltip-content';

        this.highlighted = {
            feature: undefined,
            originalColor: new Cesium.Color()
        };
        this.defaultHighlightedClr = Cesium.Color.fromCssColorString("#95e40c");

        //兼容历史接口
        this.getTooltipForConfig = _util.getTooltipForConfig;

        //添加弹出框  
        var infoDiv = '<div id="' + this.viewerid + '-okay3d-tooltip-view" class="okay3d-popup" style="display:none;">' + '     <div class="okay3d-popup-content-wrapper  okay3d-popup-background">' + '         <div id="' + this.tooltipcontentid + '" class="okay3d-popup-content okay3d-popup-color"></div>' + '     </div>' + '     <div class="okay3d-popup-tip-container"><div class="okay3d-popup-tip  okay3d-popup-background"></div></div>' + '</div> ';
        (0, _zepto.zepto)("#" + this.viewerid).append(infoDiv);

        this._tooltipDOM = (0, _zepto.zepto)('#' + this.viewerid + '-okay3d-tooltip-view');
        this._tooltipContentDOM = (0, _zepto.zepto)('#' + this.tooltipcontentid);

        //鼠标移动事件
        this.options.cacheTime = Cesium.defaultValue(this.options.cacheTime, 100);
        this.viewer.mars.on(_MarsClass.eventType.mouseMove, this.mouseMoveHandler, this);

        this.handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        this.handler.setInputAction(function (event) {//鼠标移动事件

        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }

    //========== 对外属性 ==========  

    //是否禁用


    _createClass(Tooltip, [{
        key: 'mouseMoveHandler',


        //========== 方法 ========== 
        //鼠标移动事件，setTimeout是为了优化效率
        value: function mouseMoveHandler(event) {
            var _this = this;

            if (this.moveTimer) {
                clearTimeout(this.moveTimer);
                delete this.moveTimer;
            }
            this.moveTimer = setTimeout(function () {
                delete _this.moveTimer;
                _this.mouseMovingPicking(event);
            }, this.options.cacheTime);
        }
        //鼠标移动事件

    }, {
        key: 'mouseMovingPicking',
        value: function mouseMovingPicking(event) {
            var _this2 = this;

            if (!this._enable) return;

            (0, _zepto.zepto)('.cesium-viewer').css('cursor', '');

            if (this.viewer.scene.screenSpaceCameraController.enableRotate === false || this.viewer.scene.screenSpaceCameraController.enableTilt === false || this.viewer.scene.screenSpaceCameraController.enableTranslate === false) {
                this.close();
                return;
            }

            var position = event.endPosition;

            var entity; //鼠标感知的对象，可能是entity或primitive等 
            var pickedObject;
            try {
                pickedObject = this.viewer.scene.pick(position, 5, 5);
            } catch (e) {}

            //普通entity对象 && this.viewer.scene.pickPositionSupported
            if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
                entity = pickedObject.id;
            }
            //单体化3dtiles数据的处理(如：BIM的构件，城市白膜建筑)
            else if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.tileset) && Cesium.defined(pickedObject.getProperty)) {
                    var cfg = pickedObject.tileset._config || pickedObject.tileset;
                    if (cfg) {
                        //取属性
                        var attr = {};
                        var names = pickedObject.getPropertyNames();
                        for (var i = 0; i < names.length; i++) {
                            var name = names[i];
                            if (!pickedObject.hasProperty(name)) continue;

                            var val = pickedObject.getProperty(name);
                            if (val == null) continue;
                            attr[name] = val;
                        }

                        entity = {
                            id: pickedObject._batchId,
                            tooltip: {
                                html: (0, _util.getTooltipForConfig)(cfg, attr),
                                anchor: cfg.popupAnchor || [0, -15]
                            },
                            attr: attr, //回调方法中用
                            feature: pickedObject //回调方法中用
                        };
                        if (!cfg.noMouseMove) {
                            if (cfg.mouseover) entity.mouseover = cfg.mouseover;
                            if (cfg.mouseout) entity.mouseout = cfg.mouseout;
                        }

                        //高亮显示单体对象 
                        if (cfg.showMoveFeature) {
                            this.showFeatureFor3dtiles(pickedObject, cfg.moveFeatureColor);
                        }
                    }
                }
                //primitive对象 
                else if (pickedObject && Cesium.defined(pickedObject.primitive)) {
                        entity = pickedObject.primitive;
                    }

            if (entity) {
                //存在鼠标感知的对象
                if (entity.popup || entity.click || entity.cursorCSS) {
                    (0, _zepto.zepto)('.cesium-viewer').css('cursor', entity.cursorCSS || 'pointer');
                }

                //加统一的 mouseover 鼠标移入处理
                if (!entity.noMouseMove) {
                    //排除标识了不处理其移入事件的对象 ，比如高亮对象本身
                    if (this.lastTime) {
                        clearTimeout(this.lastTime);
                        this.lastTime = null;
                    }
                    this.lastTime = setTimeout(function (e) {
                        _this2.lastTime = null;
                        _this2.activateMouseOver(entity, position);
                    }, 20);
                }

                //tooltip
                if (entity.tooltip) {
                    var cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
                    this.show(entity, cartesian, position);
                } else {
                    this.close();
                }
            } else {
                this.close();

                if (this.lastTime) {
                    clearTimeout(this.lastTime);
                    this.lastTime = null;
                }
                this.lastTime = setTimeout(function (e) {
                    _this2.lastTime = null;
                    _this2.activateMouseOut();
                }, 20);
            }
        }
    }, {
        key: 'show',
        value: function show(entity, cartesian, position) {
            if (entity == null || entity.tooltip == null) return;

            //计算显示位置 
            if (position == null) position = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, cartesian);
            if (position == null) {
                this.close();
                return;
            }

            if (this._lastTooltipEntity !== entity) {
                //避免鼠标移动时重复构造DOM
                //显示内容
                var inhtml;
                var onAdd;
                if (_typeof(entity.tooltip) === 'object') {
                    inhtml = entity.tooltip.html;
                    onAdd = entity.tooltip.onAdd;
                    this.onRemove = entity.tooltip.onRemove;

                    if (typeof entity.tooltip.visible === 'function') {
                        if (!entity.tooltip.visible(entity)) {
                            this.close();
                            return;
                        }
                    }
                } else {
                    inhtml = entity.tooltip;
                }

                if (typeof inhtml === 'function') {
                    inhtml = inhtml(entity, cartesian); //回调方法
                }
                if (!inhtml) return;

                this._tooltipContentDOM.html(inhtml);
                this._tooltipDOM.show();

                //tooltip的DOM添加到页面的回调方法
                if (onAdd) onAdd(this.tooltipcontentid);
            }
            this._lastTooltipEntity = entity;

            //定位位置
            var x = position.x - this._tooltipDOM.width() / 2;
            var y = position.y - this._tooltipDOM.height();

            var tooltip = entity.tooltip;
            if (tooltip && (typeof tooltip === 'undefined' ? 'undefined' : _typeof(tooltip)) === 'object' && tooltip.anchor) {
                x += tooltip.anchor[0];
                y += tooltip.anchor[1];
            } else {
                y -= 15; //默认偏上10像素
            }
            this._tooltipDOM.css('transform', 'translate3d(' + x + 'px,' + y + 'px, 0)');
        }
    }, {
        key: 'close',
        value: function close() {
            if (this.moveTimer) {
                clearTimeout(this.moveTimer);
                delete this.moveTimer;
            }
            if (this.onRemove) {
                this.onRemove(this.tooltipcontentid);
                delete this.onRemove;
            }

            this._tooltipContentDOM.empty();
            this._tooltipDOM.hide();

            this.removeFeatureFor3dtiles();
            delete this._lastTooltipEntity;
        }
    }, {
        key: 'activateMouseOver',
        value: function activateMouseOver(entity, position) {
            if (this._lastMouseEntity === entity) return;

            this.activateMouseOut();

            //鼠标移入对象所关联的管理类(基于MarsClass)，进行mouseOver事件抛出。
            if (entity.eventTarget && entity.eventTarget.fire) {
                entity.eventTarget.fire(_MarsClass.eventType.mouseOver, {
                    sourceTarget: entity,
                    position: position
                });
            }
            if (entity.mouseover && typeof entity.mouseover === 'function') entity.mouseover(entity, position);

            this._lastMouseEntity = entity;
        }
    }, {
        key: 'activateMouseOut',
        value: function activateMouseOut() {
            if (this._lastMouseEntity == null) return;

            //鼠标移入对象所关联的管理类(基于MarsClass)，进行mouseOver事件抛出。
            if (this._lastMouseEntity.eventTarget && this._lastMouseEntity.eventTarget.fire) {
                this._lastMouseEntity.eventTarget.fire(_MarsClass.eventType.mouseOut, {
                    sourceTarget: this._lastMouseEntity
                });
            }
            if (this._lastMouseEntity.mouseout && typeof this._lastMouseEntity.mouseout === 'function') this._lastMouseEntity.mouseout(this._lastMouseEntity);
            this._lastMouseEntity = null;
        }

        //=====================高亮对象处理========================
        //鼠标移入3dtiles单体化，高亮显示构件处理

    }, {
        key: 'removeFeatureFor3dtiles',
        value: function removeFeatureFor3dtiles() {
            if (Cesium.defined(this.highlighted.feature)) {
                try {
                    this.highlighted.feature.color = this.highlighted.originalColor;
                } catch (ex) {}
                this.highlighted.feature = undefined;
            }
        }
    }, {
        key: 'showFeatureFor3dtiles',
        value: function showFeatureFor3dtiles(pickedFeature, color) {
            this.removeFeatureFor3dtiles();
            this.highlighted.feature = pickedFeature;

            Cesium.Color.clone(pickedFeature.color, this.highlighted.originalColor);
            if (color && typeof color === 'string') color = Cesium.Color.fromCssColorString(color);
            pickedFeature.color = color || this.defaultHighlightedClr;
        }

        //=================================================


    }, {
        key: 'destroy',
        value: function destroy() {
            this.close();
            this.viewer.mars.off(_MarsClass.eventType.mouseMove, this.mouseMoveHandler, this);
            this._tooltipDOM.remove();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: 'enable',
        get: function get() {
            return this._enable;
        },
        set: function set(value) {
            this._enable = value;
            if (!value) {
                this.close();
            }
        }
    }]);

    return Tooltip;
}();

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContextMenu = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(8);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ContextMenu = exports.ContextMenu = function () {
    //========== 构造方法 ========== 
    function ContextMenu(viewer, options) {
        var _this = this;

        _classCallCheck(this, ContextMenu);

        this.viewer = viewer;
        this.viewerid = viewer._container.id;

        this._enable = true;
        this.menuIndex = 0;
        this.objMenu = {};

        //添加弹出框 
        var infoDiv = '<div id="' + this.viewerid + '-okay3d-contextmenu" class="okay3d-contextmenu open" style="display:none;">\n                            <ul id="' + this.viewerid + '-okay3d-contextmenu-ul" class="okay3d-contextmenu-ul"> \n                            </ul>\n                        </div>';
        (0, _zepto.zepto)("#" + viewer._container.id).append(infoDiv);

        this._contextmenuDOM = (0, _zepto.zepto)('#' + this.viewerid + '-okay3d-contextmenu');
        this._contextmenuULDOM = (0, _zepto.zepto)('#' + this.viewerid + '-okay3d-contextmenu-ul');

        var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        handler.setInputAction(function (event) {
            _this.close();
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
        handler.setInputAction(function (event) {
            _this.close();
        }, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
        handler.setInputAction(function (event) {
            _this.close();
        }, Cesium.ScreenSpaceEventType.RIGHT_DOWN);
        handler.setInputAction(function (event) {
            _this.close();
        }, Cesium.ScreenSpaceEventType.PINCH_START);
        handler.setInputAction(function (event) {
            _this.close();
        }, Cesium.ScreenSpaceEventType.WHEEL);
        handler.setInputAction(function (event) {
            _this.close();
            if (!_this._enable) return;

            var position = event.position;

            var entity; //鼠标感知的对象，可能是entity或primitive
            var pickedObject = viewer.scene.pick(position, 5, 5);

            var contextmenuItems = viewer.mars.contextmenuItems;
            //普通entity对象 
            if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
                entity = pickedObject.id;
                if (Cesium.defined(entity.contextmenuItems)) contextmenuItems = entity.contextmenuItems;
            }
            //primitive对象 
            else if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.primitive)) {
                    entity = pickedObject.primitive;
                    if (Cesium.defined(entity.contextmenuItems)) contextmenuItems = entity.contextmenuItems;
                }

            _this.showView(contextmenuItems, position, entity);
        }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
        this.handler = handler;
    }

    //========== 对外属性 ==========  

    //是否禁用


    _createClass(ContextMenu, [{
        key: 'showView',


        //========== 方法 ========== 

        value: function showView(contextmenu, positionMouse, entity) {
            if (!contextmenu || contextmenu.length == 0) {
                this.close();
                return;
            };

            var cartesian = point.getCurrentMousePosition(this.viewer.scene, positionMouse);

            var inhtml = "";
            for (var i = 0, len = contextmenu.length; i < len; i++) {
                var item = contextmenu[i];
                var result = this.getItemHtml(item, {
                    positionMouse: positionMouse,
                    position: cartesian,
                    target: entity
                });
                if (result) inhtml += result;
            }

            if (inhtml == "") {
                this.close();
                return;
            };

            var that = this;
            this._contextmenuULDOM.html(inhtml);
            (0, _zepto.zepto)('#' + this.viewerid + '-okay3d-contextmenu-ul .contextmenu-item').click(function (e) {
                var index = Number((0, _zepto.zepto)(this).attr('data-index'));
                var item = that.objMenu[index];
                var callback = item.callback || item.calback; //兼容不同参数名
                if (callback) {
                    callback({
                        positionMouse: positionMouse,
                        position: cartesian,
                        data: item,
                        target: entity
                    });
                }
                that.close();
            });

            //鼠标滑过弹出二级菜单
            (0, _zepto.zepto)('#' + this.viewerid + '-okay3d-contextmenu-ul .contextmenu-item').mouseover(function (e) {
                (0, _zepto.zepto)('.okay3d-sub-menu').hide(); //所有的二级菜单隐藏

                var sub_menu = this.querySelector('.okay3d-sub-menu');
                if (sub_menu) {
                    sub_menu.style.display = 'block';
                }

                (0, _zepto.zepto)('#' + that.viewerid + '-okay3d-contextmenu-ul .active').removeClass('active');
                (0, _zepto.zepto)(this).addClass('active');
            });

            var top = positionMouse.y;
            var left = positionMouse.x;
            this._contextmenuDOM.css({ //不显示前，无法计算width和width
                "top": top,
                "left": left
            }).show();
            this._show = true;
            this._target = entity;

            var menuHeight = this._contextmenuDOM.height();
            var menuWidth = this._contextmenuDOM.width();

            (0, _zepto.zepto)('#' + this.viewerid + '-okay3d-contextmenu-ul .okay3d-sub-menu').css({
                left: menuWidth + 3 + "px"
            });

            //判断垂直方向 是否超过了 屏幕高度
            if (top + menuHeight > this.viewer.scene.canvas.clientHeight) {
                top -= menuHeight - 10;
                if (top <= 0) top = 0;
            } else {
                top += 10;
            }

            //判断水平方向 是否超过了屏幕宽度
            if (left + menuWidth > this.viewer.scene.canvas.clientWidth) {
                left -= menuWidth - 10;
                if (left <= 0) left = 0;
            } else {
                left += 10;
            }

            this._contextmenuDOM.css({
                "top": top,
                "left": left
            });
        }
    }, {
        key: 'getItemHtml',
        value: function getItemHtml(item, eventresult) {
            if (item.hasOwnProperty("visible")) {
                var visible = item.visible;
                try {
                    if (typeof visible === 'function') {
                        //回调方法 
                        eventresult.data = item;
                        visible = item.visible(eventresult);
                    }
                } catch (e) {
                    marslog.log(e);
                }

                if (!visible) return null;
            }

            var inhtml;
            if (item.text) {
                var childrenHtml = '';
                var childTip = '';
                if (item.children) {
                    childrenHtml = '<ul class="okay3d-contextmenu-ul okay3d-sub-menu">';
                    for (var j = 0, len2 = item.children.length; j < len2; j++) {
                        var childitem = item.children[j];
                        eventresult.data = childitem;
                        var result = this.getItemHtml(childitem, eventresult);
                        if (result) childrenHtml += result;
                    }
                    childrenHtml += '</ul>';
                    childTip = '&nbsp;&nbsp;<i class="fa fa-caret-right"></i>';
                }

                this.menuIndex++;
                this.objMenu[this.menuIndex] = item;

                inhtml = '<li class="contextmenu-item" data-index="' + this.menuIndex + '">\n                        <a href="javascript:void(0)"><i class="' + item.iconCls + '"></i>' + item.text + childTip + '</a>\n                        ' + childrenHtml + '\n                    </li>';
            } else inhtml = '<li class="line"></li>';
            return inhtml;
        }
    }, {
        key: 'close',
        value: function close() {
            if (!this._show) return;
            this._contextmenuDOM.hide();
            this._show = false;
            this._target = null;
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.close();

            this.handler.destroy();
            this._contextmenuDOM.remove();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: 'enable',
        get: function get() {
            return this._enable;
        },
        set: function set(value) {
            this._enable = value;
            if (!value) {
                this.close();
            }
        }
    }, {
        key: 'show',
        get: function get() {
            return this._show;
        }
    }, {
        key: 'target',
        get: function get() {
            return this._target;
        }
    }]);

    return ContextMenu;
}();

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Location = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _zepto = __webpack_require__(8);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _util2 = __webpack_require__(1);

var _util = _interopRequireWildcard(_util2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//“鼠标经纬度提示”控件
var Location = exports.Location = function () {
    //========== 构造方法 ========== 
    function Location(viewer, options) {
        var _this = this;

        _classCallCheck(this, Location);

        this.viewer = viewer;
        this.options = options;

        this.format = options.format || '<div>经度:{x}</div> <div>纬度:{y}</div> <div>海拔：{z}米</div> <div>方向：{heading}度</div> <div>俯仰角：{pitch}度</div>  <div>视高：{height}米</div>';

        var containerid = viewer._container.id + "-okay3d-location";
        var inhtml = '<div id="' + containerid + '"  class="okay3d-locationbar animation-slide-bottom no-print" ><div class="okay3d-locationbar-content"></div></div>';
        (0, _zepto.zepto)("#" + viewer._container.id).append(inhtml);

        this._dom = (0, _zepto.zepto)('#' + containerid);
        this._domContent = (0, _zepto.zepto)('#' + containerid + " .okay3d-locationbar-content");

        if (options.style) this._dom.css(options.style);else {
            this._dom.css({
                "left": viewer.animation ? "170px" : "0",
                "right": "0",
                "bottom": viewer.timeline ? "25px" : "0"
            });
        }
        this._visible = true;

        this.locationData = {};
        this.locationData.height = viewer.camera.positionCartographic.height.toFixed(1);
        this.locationData.heading = Cesium.Math.toDegrees(viewer.camera.heading).toFixed(0);
        this.locationData.pitch = Cesium.Math.toDegrees(viewer.camera.pitch).toFixed(0);

        this.options.cacheTime = Cesium.defaultValue(this.options.cacheTime, 100);
        this.viewer.mars.on(_MarsClass.eventType.mouseMove, this.mouseMoveHandler, this);

        //帧率
        if (options.fps) {
            // 帧率的计算借助了Cesium中的东西，需要开启debugShowFramesPerSecond
            viewer.scene.debugShowFramesPerSecond = true;

            var timeTik = setInterval(function () {
                if (!viewer || !viewer.scene._performanceDisplay) return;
                clearInterval(timeTik);
                _this.timeTik = null;

                var domFPS = (0, _zepto.zepto)(".cesium-performanceDisplay");

                //修改样式
                domFPS.addClass("okay3d-locationbar-content").removeClass("cesium-performanceDisplay");

                //移除空节点
                domFPS.children(".cesium-performanceDisplay-throttled").remove();

                //添加到状态栏
                _this._dom.prepend(domFPS);
            }, 500);
            this.timeTik = timeTik;
        }

        //相机移动结束事件
        viewer.scene.camera.moveEnd.addEventListener(this.updaeCamera, this);
    }

    //========== 对外属性 ==========  
    //是否显示


    _createClass(Location, [{
        key: 'mouseMoveHandler',


        //========== 方法 ==========  
        //鼠标移动事件，setTimeout是为了优化效率
        value: function mouseMoveHandler(event) {
            var _this2 = this;

            if (this.moveTimer) {
                clearTimeout(this.moveTimer);
                delete this.moveTimer;
            }
            this.moveTimer = setTimeout(function () {
                delete _this2.moveTimer;
                _this2.updateData(event);
            }, this.options.cacheTime);
        }
    }, {
        key: 'updateData',
        value: function updateData(movement) {
            if (!this._visible) return;

            var cartesian = point.getCurrentMousePosition(this.viewer.scene, movement.endPosition);
            if (!cartesian) return;

            var cartographic = Cesium.Cartographic.fromCartesian(cartesian);

            this.locationData.z = (cartographic.height / this.viewer.scene.terrainExaggeration).toFixed(1);
            this.locationData.height = this.viewer.camera.positionCartographic.height.toFixed(1);
            this.locationData.heading = Cesium.Math.toDegrees(this.viewer.camera.heading).toFixed(0);
            this.locationData.pitch = Cesium.Math.toDegrees(this.viewer.camera.pitch).toFixed(0);
            this.locationData.level = this.viewer.mars.level;

            var jd = Cesium.Math.toDegrees(cartographic.longitude);
            var wd = Cesium.Math.toDegrees(cartographic.latitude);

            switch (this.options.crs) {
                default:
                    //和地图一致的原坐标
                    var fixedLen = this.options.hasOwnProperty('toFixed') ? this.options.toFixed : 6;
                    this.locationData.x = jd.toFixed(fixedLen);
                    this.locationData.y = wd.toFixed(fixedLen);
                    break;
                case "degree":
                    //度分秒形式
                    this.locationData.x = _util.formatDegree(jd);
                    this.locationData.y = _util.formatDegree(wd);
                    break;
                case "project":
                    //投影坐标
                    var fixedLen = this.options.hasOwnProperty('toFixed') ? this.options.toFixed : 0;
                    var mkt = pointconvert.cartesian2mercator([cartesian.x, cartesian.y]);
                    this.locationData.x = mkt[0].toFixed(fixedLen);
                    this.locationData.y = mkt[1].toFixed(fixedLen);
                    break;

                case "wgs":
                    //标准wgs84格式坐标
                    var fixedLen = this.options.hasOwnProperty('toFixed') ? this.options.toFixed : 6;
                    var wgsPoint = point2wgs({ x: jd, y: wd }); //坐标转换为wgs 
                    this.locationData.x = wgsPoint.x.toFixed(fixedLen);
                    this.locationData.y = wgsPoint.y.toFixed(fixedLen);
                    break;
                case "wgs-degree":
                    //标准wgs84格式坐标
                    var wgsPoint = point2wgs({ x: jd, y: wd }); //坐标转换为wgs 
                    this.locationData.x = _util.formatDegree(wgsPoint.x);
                    this.locationData.y = _util.formatDegree(wgsPoint.y);
                    break;
            }

            var inhtml;
            if (typeof this.format === 'function') {
                //回调方法 
                inhtml = this.format(this.locationData);
            } else {
                inhtml = _util.template(this.format, this.locationData);
            }
            this._domContent.html(inhtml);
        }
    }, {
        key: 'updaeCamera',
        value: function updaeCamera() {
            if (!this._visible) return;

            this.locationData.height = this.viewer.camera.positionCartographic.height.toFixed(1);
            this.locationData.heading = Cesium.Math.toDegrees(this.viewer.camera.heading).toFixed(0);
            this.locationData.pitch = Cesium.Math.toDegrees(this.viewer.camera.pitch).toFixed(0);
            this.locationData.level = this.viewer.mars.level;

            if (this.locationData.x == null) return;

            var inhtml;
            if (typeof this.format === 'function') {
                //回调方法 
                inhtml = this.format(this.locationData);
            } else {
                inhtml = _util.template(this.format, this.locationData);
            }

            this._domContent.html(inhtml);
        }
    }, {
        key: 'css',
        value: function css(style) {
            this._dom.css(style);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            //相机移动结束事件
            this.viewer.scene.camera.moveEnd.removeEventListener(this.updaeCamera, this);
            this.viewer.mars.off(_MarsClass.eventType.mouseMove, this.mouseMoveHandler, this);

            if (this.options.fps) {
                this.viewer.scene.debugShowFramesPerSecond = false;
            }

            if (this.timeTik) {
                clearInterval(this.timeTik);
                this.timeTik = null;
            }

            this._dom.remove();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: 'show',
        get: function get() {
            return this._visible;
        },
        set: function set(value) {
            this._visible = value;

            if (value) this._dom.show();else this._dom.hide();
        }
    }]);

    return Location;
}();

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MouseZoomStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(8);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _util2 = __webpack_require__(1);

var _util = _interopRequireWildcard(_util2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//鼠标旋转、放大时的美化图标
var MouseZoomStyle = exports.MouseZoomStyle = function () {
    //========== 构造方法 ========== 
    function MouseZoomStyle(viewer, options) {
        var _this = this;

        _classCallCheck(this, MouseZoomStyle);

        this.viewer = viewer;
        this.options = options || {};

        var containerid = viewer._container.id + '-okay3d-mousezoom';
        (0, _zepto.zepto)("#" + viewer._container.id).append('<div id="' + containerid + '" class="okay3d-mousezoom"><div class="zoomimg"/></div>');
        this._dom = (0, _zepto.zepto)('#' + containerid);

        this.enable = Cesium.defaultValue(this.options.enable, true);

        var timetik = -1;
        var that = this;
        var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
        handler.setInputAction(function (evnet) {
            if (!_this._enable) return;
            _this._dom.addClass('okay3d-mousezoom-visible');
            clearTimeout(timetik);
            timetik = setTimeout(function () {
                that._dom.removeClass('okay3d-mousezoom-visible');
            }, 200);
        }, Cesium.ScreenSpaceEventType.WHEEL);

        handler.setInputAction(function (evnet) {
            if (!_this._enable) return;
            var position = point.getCurrentMousePosition(viewer.scene, evnet.position);
            if (!position) return;

            if (viewer.camera.positionCartographic.height > viewer.scene.screenSpaceCameraController.minimumCollisionTerrainHeight) return;

            handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            clearTimeout(timetik);
            _this._dom.css({
                top: evnet.position.y + 'px',
                left: evnet.position.x + 'px'
            });
            _this._dom.addClass('okay3d-mousezoom-visible');
        }, options.rightDrag ? Cesium.ScreenSpaceEventType.RIGHT_DOWN : Cesium.ScreenSpaceEventType.MIDDLE_DOWN);

        handler.setInputAction(function (evnet) {
            _this._dom.removeClass('okay3d-mousezoom-visible');
            handler.setInputAction(function (evnet) {
                that._dom.css({
                    top: evnet.endPosition.y + 'px',
                    left: evnet.endPosition.x + 'px'
                });
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
        }, options.rightDrag ? Cesium.ScreenSpaceEventType.RIGHT_UP : Cesium.ScreenSpaceEventType.MIDDLE_UP);

        this.handler = handler;
    }

    //========== 对外属性 ==========  

    //是否显示


    _createClass(MouseZoomStyle, [{
        key: 'destroy',


        //========== 方法 ==========  

        value: function destroy() {
            if (this.handler) {
                this.handler.destroy();
                delete this.handler;
            }
            this._dom.remove();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: 'enable',
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable = val;
            if (val) this._dom.show();else this._dom.hide();
        }
    }]);

    return MouseZoomStyle;
}();

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseWidget = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _zepto = __webpack_require__(8);

var _loader = __webpack_require__(73);

var _widgetManager = __webpack_require__(72);

var _ES5Class = __webpack_require__(134);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var _resources_cache = [];

var BaseWidget = exports.BaseWidget = _ES5Class.ES5Class.extend({
    viewer: null,
    options: {},
    config: {}, //配置的config信息 
    path: "", //当前widget目录相对路径 
    isActivate: false, //是否激活状态
    isCreate: false,
    initialize: function initialize(cfg, map) {
        this.viewer = map;
        this.config = cfg;
        this.path = cfg.path || '';
        this.init();
    },
    addCacheVersion: function addCacheVersion(_resource) {
        if (_resource == null) return _resource;

        var cacheVersion = (0, _widgetManager.getCacheVersion)();
        if (cacheVersion) {
            if (_resource.indexOf('?') == -1) _resource += "?time=" + cacheVersion;else if (_resource.indexOf('time=' + cacheVersion) == -1) _resource += "&time=" + cacheVersion;
        }
        return _resource;
    },
    //激活插件
    activateBase: function activateBase() {
        var that = this;

        if (this.isActivate) {
            //已激活状态时跳出 
            this.changeWidgetView(function (viewopt) {
                if (viewopt._dom) {
                    //将层置顶
                    (0, _zepto.zepto)(".layui-layer").each(function () {
                        (0, _zepto.zepto)(this).css("z-index", 19891000);
                    });
                    (0, _zepto.zepto)(viewopt._dom).css("z-index", 19891014);
                }
            });
            return;
        }

        this.beforeActivate();
        this.isActivate = true;
        //marslog.log('激活widget:' + this.config.uri);

        if (!this.isCreate) {
            //首次进行创建 
            if (this.options.resources && this.options.resources.length > 0) {
                var resources = [];

                for (var i = 0; i < this.options.resources.length; i++) {
                    var _resource = this.options.resources[i];
                    _resource = this._getUrl(_resource);

                    if (_resources_cache.indexOf(_resource) != -1) continue; //不加重复资源

                    resources.push(_resource);
                }
                _resources_cache = _resources_cache.concat(resources); //不加重复资源

                _loader.Loader.async(resources, function () {
                    var result = that.create(function () {
                        that._createWidgetView();
                        that.isCreate = true;
                    });
                    if (result) return;
                    if (that.config.createAtStart) {
                        that.config.createAtStart = false;
                        that.isActivate = false;
                        that.isCreate = true;
                        return;
                    }
                    that._createWidgetView();
                    that.isCreate = true;
                });
                return;
            } else {
                var result = this.create(function () {
                    that._createWidgetView();
                    this.isCreate = true;
                });
                if (result) return;
                if (that.config.createAtStart) {
                    that.config.createAtStart = false;
                    that.isActivate = false;
                    that.isCreate = true;
                    return;
                }
            }
            this.isCreate = true;
        }
        this._createWidgetView();

        return this;
    },
    //创建插件的view
    _createWidgetView: function _createWidgetView() {
        var viewopt = this.options.view;
        if (viewopt === undefined || viewopt === null) {
            this._startActivate();
        } else if ((0, _util.isArray)(viewopt)) {
            this._viewcreate_allcount = viewopt.length;
            this._viewcreate_okcount = 0;

            for (var i = 0; i < viewopt.length; i++) {
                this.createItemView(viewopt[i]);
            }
        } else {
            this._viewcreate_allcount = 1;
            this._viewcreate_okcount = 0;
            this.createItemView(viewopt);
        }
    },
    changeWidgetView: function changeWidgetView(callback) {
        var viewopt = this.options.view;
        if (viewopt === undefined || viewopt === null) {
            return false;
        } else if ((0, _util.isArray)(viewopt)) {
            var hascal = false;
            for (var i = 0; i < viewopt.length; i++) {
                hascal = hascal || callback(viewopt[i]);
            }
            return hascal;
        } else {
            return callback(viewopt);
        }
    },
    createItemView: function createItemView(viewopt) {
        switch (viewopt.type) {
            default:
            case "window":
                this._openWindow(viewopt);
                break;
            case "divwindow":
                this._openDivWindow(viewopt);
                break;
            case "append":
                var view_url = this._getUrl(viewopt.url);
                var that = this;
                that.getHtml(view_url, function (html) {
                    that._appendView(viewopt, html);
                });
                break;
            case "custom":
                //自定义 
                var view_url = this._getUrl(viewopt.url);

                var that = this;
                viewopt.open(view_url, function (html) {
                    that.winCreateOK(viewopt, html);

                    that._viewcreate_okcount++;
                    if (that._viewcreate_okcount >= that._viewcreate_allcount) {
                        that._startActivate(html);
                    }
                }, this);
                break;
        }
    },
    _viewcreate_allcount: 0,
    _viewcreate_okcount: 0,
    //==============layer弹窗================= 
    _openWindow: function _openWindow(viewopt) {
        var that = this;
        var view_url = this._getUrl(viewopt.url);

        var opts = {
            type: 2,
            content: [view_url, 'no'],
            success: function success(layero) {
                viewopt._layerOpening = false;
                viewopt._dom = layero;

                //得到iframe页的窗口对象，执行iframe页的方法：viewWindow.method();
                var viewWindow = window[layero.find('iframe')[0]['name']];

                //设置css
                if (that.config.css) (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).css(that.config.css);

                //隐藏弹窗
                if (that.config.hasOwnProperty("visible") && !that.config.visible) (0, _zepto.zepto)(layero).hide();

                layer.setTop(layero);
                that.winCreateOK(viewopt, viewWindow);

                that._viewcreate_okcount++;
                if (that._viewcreate_okcount >= that._viewcreate_allcount) that._startActivate(layero);

                //通知页面,页面需要定义initWidgetView方法
                if (viewWindow && viewWindow.initWidgetView) viewWindow.initWidgetView(that);else marslog.warn("" + view_url + "页面没有定义function initWidgetView(widget)方法，无法初始化widget页面!");
            }
        };
        if (viewopt._layerIdx > 0) {
            //debugger
        }

        viewopt._layerOpening = true;
        viewopt._layerIdx = layer.open(this._getWinOpt(viewopt, opts));
    },
    _openDivWindow: function _openDivWindow(viewopt) {
        var view_url = this._getUrl(viewopt.url);
        //div弹窗
        var that = this;
        this.getHtml(view_url, function (data) {
            var opts = {
                type: 1,
                content: data,
                success: function success(layero) {
                    viewopt._layerOpening = false;
                    viewopt._dom = layero;

                    //隐藏弹窗
                    if (that.config.hasOwnProperty("visible") && !that.config.visible) (0, _zepto.zepto)(layero).hide();

                    layer.setTop(layero);
                    that.winCreateOK(viewopt, layero);

                    that._viewcreate_okcount++;
                    if (that._viewcreate_okcount >= that._viewcreate_allcount) that._startActivate(layero);
                }
            };
            viewopt._layerOpening = true;
            viewopt._layerIdx = layer.open(that._getWinOpt(viewopt, opts));
        });
    },
    _getUrl: function _getUrl(url) {
        url = this.addCacheVersion(url);

        if (url.startsWith("/") || url.startsWith(".") || url.startsWith("http")) return url;else return this.path + url;
    },
    _getWinOpt: function _getWinOpt(viewopt, opts) {
        //优先使用cofig中配置，覆盖js中的定义 
        var def = (0, _widgetManager.getDefWindowOptions)();
        var windowOptions = _extends({}, def, viewopt.windowOptions, this.config.windowOptions);
        viewopt.windowOptions = windowOptions; //赋值 

        var that = this;
        var _size = this._getWinSize(windowOptions);

        var title = false;
        if (!windowOptions.noTitle) {
            title = this.config.name || ' ';
            if (this.config.icon) {
                title = '<i class="' + this.config.icon + '" ></i>&nbsp;' + title;
            }
        }

        //默认值
        var defOpts = {
            title: title,
            area: _size.area,
            offset: _size.offset,
            shade: 0,
            maxmin: false,
            beforeEnd: function beforeEnd() {
                that.beforeDisable();
            },
            end: function end() {
                // 销毁后触发的回调
                viewopt._layerIdx = -1;
                viewopt._dom = null;
                that.disableBase(true);
            },
            full: function full(dom) {
                //最大化后触发的回调
                that.winFull(dom);
            },
            min: function min(dom) {
                //最小化后触发的回调
                that.winMin(dom);
            },
            restore: function restore(dom) {
                //还原 后触发的回调
                that.winRestore(dom);
            }
        };
        return _extends({}, defOpts, windowOptions, opts);
    },
    //计算弹窗大小和位置
    _getWinSize: function _getWinSize(windowOptions) {
        //获取高宽 
        var _width = this.bfb2Number(windowOptions.width, document.documentElement.clientWidth, windowOptions);
        var _height = this.bfb2Number(windowOptions.height, document.documentElement.clientHeight, windowOptions);

        //计算位置offset
        var offset = '';
        var position = windowOptions.position;
        if (position) {
            if (typeof position == "string") {
                //t顶部,b底部,r右边缘,l左边缘,lt左上角,lb左下角,rt右上角,rb右下角
                offset = position;
            } else if ((typeof position === 'undefined' ? 'undefined' : _typeof(position)) == "object") {
                var _top;
                var _left;

                if (position.hasOwnProperty("top") && position.top != null) {
                    _top = this.bfb2Number(position.top, document.documentElement.clientHeight, windowOptions);
                }
                if (position.hasOwnProperty("bottom") && position.bottom != null) {
                    windowOptions._hasresize = true;

                    var _bottom = this.bfb2Number(position.bottom, document.documentElement.clientHeight, windowOptions);

                    if (_top != null) {
                        _height = document.documentElement.clientHeight - _top - _bottom;
                    } else {
                        _top = document.documentElement.clientHeight - _height - _bottom;
                    }
                }

                if (position.hasOwnProperty("left") && position.left != null) {
                    _left = this.bfb2Number(position.left, document.documentElement.clientWidth, windowOptions);
                }
                if (position.hasOwnProperty("right") && position.right != null) {
                    windowOptions._hasresize = true;
                    var _right = this.bfb2Number(position.right, document.documentElement.clientWidth, windowOptions);

                    if (_left != null) {
                        _width = document.documentElement.clientWidth - _left - _right;
                    } else {
                        _left = document.documentElement.clientWidth - _width - _right;
                    }
                }

                if (_top == null) _top = (document.documentElement.clientHeight - _height) / 2;
                if (_left == null) _left = (document.documentElement.clientWidth - _width) / 2;

                offset = [_top + 'px', _left + 'px'];
            }
        }

        //最大最小高度判断
        if (windowOptions.hasOwnProperty("minHeight") && _height < windowOptions.minHeight) {
            windowOptions._hasresize = true;
            _height = windowOptions.minHeight;
        }
        if (windowOptions.hasOwnProperty("maxHeight") && _height > windowOptions.maxHeight) {
            windowOptions._hasresize = true;
            _height = windowOptions.maxHeight;
        }

        //最大最小宽度判断
        if (windowOptions.hasOwnProperty("minHeight") && _width < windowOptions.minWidth) {
            windowOptions._hasresize = true;
            _width = windowOptions.minWidth;
        }
        if (windowOptions.hasOwnProperty("maxWidth") && _width > windowOptions.maxWidth) {
            windowOptions._hasresize = true;
            _width = windowOptions.maxWidth;
        }

        var area;
        if (_width && _height) area = [_width + 'px', _height + 'px'];else area = _width + 'px';

        return { area: area, offset: offset };
    },
    bfb2Number: function bfb2Number(str, allnum, windowOptions) {
        if (typeof str == 'string' && str.indexOf("%") != -1) {
            windowOptions._hasresize = true;

            return allnum * Number(str.replace("%", "")) / 100;
        }
        return str;
    },
    //==============直接添加到index上=================  
    _appendView: function _appendView(viewopt, html) {
        viewopt._dom = (0, _zepto.zepto)(html).appendTo(viewopt.parent || 'body');

        //设置css
        if (this.config.css) (0, _zepto.zepto)(viewopt._dom).css(this.config.css);

        this.winCreateOK(viewopt, html);

        this._viewcreate_okcount++;
        if (this._viewcreate_okcount >= this._viewcreate_allcount) this._startActivate(html);
    },

    //释放插件
    disableBase: function disableBase(nobefore) {
        if (!this.isActivate) return;

        if (!nobefore) this.beforeDisable();

        var has = this.changeWidgetView(function (viewopt) {
            if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
                if (viewopt._layerOpening) {
                    //窗口还在加载中
                    //marslog.log('释放widget窗口还在加载中:' + viewopt._layerIdx);
                }
                layer.close(viewopt._layerIdx);
                return true;
            } else {
                if (viewopt.type == "append" && viewopt._dom) {
                    viewopt._dom.remove();
                    viewopt._dom = null;
                }
                if (viewopt.type == "custom" && viewopt.close) {
                    viewopt.close();
                }
                return false;
            }
        });
        if (has) return;

        this.disable();
        this.isActivate = false;

        //还原配置为初始状态
        if (this.config.autoReset) {
            this.resetConfig();
        }

        //marslog.log('释放widget:' + this.config.uri);
    },
    //还原配置为初始状态
    resetConfig: function resetConfig() {
        if (this.config._firstConfigBak) {
            var _backData = this.config._firstConfigBak;
            for (var aa in _backData) {
                if (aa == "uri") continue;
                this.config[aa] = _backData[aa];
            }
        }
    },
    //设置view弹窗的显示和隐藏
    setViewVisible: function setViewVisible(visible) {
        this.changeWidgetView(function (viewopt) {
            if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
                if (visible) {
                    (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).show();
                } else {
                    (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).hide();
                }
            } else if (viewopt.type == "append" && viewopt._dom) {
                if (visible) (0, _zepto.zepto)(viewopt._dom).show();else (0, _zepto.zepto)(viewopt._dom).hide();
            }
        });
    },
    //设置view弹窗的css
    setViewCss: function setViewCss(style) {
        this.changeWidgetView(function (viewopt) {
            if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
                (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).css(style);
            } else if (viewopt.type == "append" && viewopt._dom) {
                (0, _zepto.zepto)(viewopt._dom).css(style);
            }
        });
    },
    //主窗体改变大小后触发
    indexResize: function indexResize() {
        if (!this.isActivate) return;

        var that = this;
        this.changeWidgetView(function (viewopt) {
            if (viewopt._layerIdx == null || viewopt._layerIdx == -1 || viewopt.windowOptions == null || !viewopt.windowOptions._hasresize) return;

            var _size = that._getWinSize(viewopt.windowOptions);

            var _style = {};
            if ((0, _util.isArray)(_size.area)) {
                if (_size.area[0]) _style.width = _size.area[0];
                if (_size.area[1]) _style.height = _size.area[1];
            }

            if ((0, _util.isArray)(_size.offset)) {
                if (_size.offset[1]) _style.top = _size.offset[0];
                if (_size.offset[1]) _style.left = _size.offset[1];
            }
            (0, _zepto.zepto)(viewopt._dom).attr("myTopLeft", true);
            layer.style(viewopt._layerIdx, _style);

            if (viewopt.type == "divwindow") layer.iframeAuto(viewopt._layerIdx);
        });
    },
    _startActivate: function _startActivate(layero) {
        this.activate(layero);
        if (this.config.success) {
            this.config.success(this);
        }
        if (!this.isActivate) {
            //窗口打开中没加载完成时，被释放
            this.disableBase();
        }
    },
    //子类继承后覆盖 
    init: function init() {},
    //子类继承后覆盖 
    create: function create(endfun) {},
    //子类继承后覆盖
    beforeActivate: function beforeActivate() {},
    activate: function activate(layero) {},

    //子类继承后覆盖
    beforeDisable: function beforeDisable() {},
    disable: function disable() {},

    //子类继承后覆盖 
    winCreateOK: function winCreateOK(opt, result) {},
    //窗口最大化后触发
    winFull: function winFull() {},
    //窗口最小化后触发
    winMin: function winMin() {},
    //窗口还原 后触发
    winRestore: function winRestore() {},

    //公共方法
    getHtml: function getHtml(url, callback) {
        _zepto.zepto.ajax({
            url: url,
            type: "GET",
            dataType: 'html',
            timeout: 0, //永不超时
            success: function success(data) {
                callback(data);
            }
        });
    }

});

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ES5Class = ES5Class;

//es5语法定义的class，新类可以:
// XXXClass.extend({
// 	initialize: function (options) {
//   },
// });


function ES5Class() {}

function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

ES5Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function NewClass() {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = Object.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		// checkDeprecatedMixinEvents(props.includes);
		extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = extend(Object.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) {
			return;
		}

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createMap = createMap;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(8);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _util2 = __webpack_require__(1);

var _util = _interopRequireWildcard(_util2);

var _ViewerEx = __webpack_require__(48);

var _GaodePOIGeocoder = __webpack_require__(136);

var _layer2 = __webpack_require__(23);

var _layer = _interopRequireWildcard(_layer2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function createMap(opt) {

    if (opt.url) {
        _zepto.zepto.ajax({
            type: "get",
            dataType: "json",
            url: opt.url,
            timeout: 0, //永不超时
            success: function success(config) {
                if (config.serverURL) opt.serverURL = config.serverURL;

                //map初始化 
                var viewer = initMap(config.map3d, opt);
                if (opt.success) opt.success(viewer, config, config); //第2个config为了兼容1.7以前版本
            },
            error: function error(XMLHttpRequest, textStatus, errorThrown) {
                marslog.warn(opt.url + "文件加载失败！");
                _util.alert(opt.url + "文件加载失败！");
            }
        });
        return null;
    } else {
        var viewer = initMap(opt.data, opt);
        if (opt.success) opt.success(viewer, opt.data);
        return viewer;
    }
}

function initMap(config, optsWB) {
    var id = optsWB.id;

    //数据优先级：optsWB > config > opts 

    //如果options未设置时的默认参数
    var opts = {
        animation: false, //是否创建动画小器件，左下角仪表   
        timeline: false, //是否显示时间线控件   
        fullscreenButton: true, //右下角全屏按钮
        vrButton: false, //右下角vr虚拟现实按钮

        geocoder: false, //是否显示地名查找控件   
        sceneModePicker: false, //是否显示投影方式控件  
        homeButton: true, //回到默认视域按钮
        navigationHelpButton: true, //是否显示帮助信息控件  
        navigationInstructionsInitiallyVisible: false, //在用户明确单击按钮之前是否自动显示

        infoBox: true, //是否显示点击要素之后显示的信息 
        selectionIndicator: false, //选择模型是是否显示绿色框, 
        shouldAnimate: true,
        showRenderLoopErrors: true, //是否显示错误弹窗信息

        baseLayerPicker: false, //地图底图
        contextmenu: true //右键菜单
    };

    //config中可以配置map所有options
    for (var key in config) {
        opts[key] = config[key];
    }
    //wboptions中可以配置map所有options覆盖

    for (var key in optsWB) {
        if (key === "id" || key === "success") continue;
        opts[key] = optsWB[key];
    }

    //一些默认值的修改【by 木遥】
    if (Cesium.Ion) Cesium.Ion.defaultAccessToken = opts.ionToken || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1NjM5MjMxOS1lMWVkLTQyNDQtYTM4Yi0wZjA4ZDMxYTlmNDMiLCJpZCI6MTQ4MiwiaWF0IjoxNTI4Njc3NDQyfQ.vVoSexHMqQhKK5loNCv6gCA5d5_z3wE2M0l_rWnIP_w';
    Cesium.AnimationViewModel.defaultTicks = opts.animationTicks || [0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0, 15.0, 30.0, 60.0, 120.0, 300.0, 600.0, 900.0, 1800.0, 3600.00];

    //自定义搜索栏Geocoder
    if (opts.geocoder === true) {
        opts.geocoder = new _GaodePOIGeocoder.GaodePOIGeocoder(opts.geocoderConfig);
    }

    //地形
    var terrainProvider;
    if (opts.terrain && opts.terrain.visible) {
        terrainProvider = getTerrainProvider(opts.terrain, opts.serverURL);
        opts.terrainProvider = terrainProvider;
    } else {
        opts.terrainProvider = _layer.getEllipsoidTerrain();
    }

    //地图底图图层预处理   
    var hasremoveimagery = false;
    if (opts.baseLayerPicker) {
        //有baseLayerPicker插件时
        if (!opts.imageryProviderViewModels && opts.basemaps && opts.basemaps.length > 0) {
            var imgOBJ = getImageryProviderArr(opts.basemaps);
            opts.imageryProviderViewModels = imgOBJ.imageryProviderViewModels;
            if (imgOBJ.index == -1) hasremoveimagery = true;else opts.selectedImageryProviderViewModel = imgOBJ.imageryProviderViewModels[imgOBJ.index];
        }

        if (!opts.terrainProviderViewModels) {
            opts.terrainProviderViewModels = getTerrainProviderViewModelsArr();
            opts.selectedTerrainProviderViewModel = opts.terrainProviderViewModels[1];
        }
    } else {
        //无baseLayerPicker插件时
        if (opts.imageryProvider == null) {
            //未配底图时
            hasremoveimagery = true;
            opts.imageryProvider = new Cesium.TileMapServiceImageryProvider({
                url: Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII')
            });
        }
    }

    //地球初始化
    var viewer = new Cesium.Viewer(id, opts);

    //地图底图图层 
    if (hasremoveimagery) {
        var imageryLayerCollection = viewer.imageryLayers;
        var length = imageryLayerCollection.length;
        for (var i = 0; i < length; i++) {
            var layer = imageryLayerCollection.get(0);
            imageryLayerCollection.remove(layer, true);
        }
    }
    if (opts.geocoder) {
        opts.geocoder.viewer = viewer;
        delete opts.geocoder;
    }

    delete opts.imageryProviderViewModels;
    delete opts.selectedImageryProviderViewModel;
    delete opts.terrainProviderViewModels;
    delete opts.selectedTerrainProviderViewModel;
    delete opts.terrainProvider;
    delete opts.imageryProvider;

    viewer.mars = new _ViewerEx.ViewerEx(viewer, opts); //欧科扩展的viewer支持

    viewer.mars.terrainProvider = terrainProvider;
    viewer.gisdata = { config: viewer.mars.config //兼容1.7以前的历史版本属性

    };return viewer;
};

//获取配置的地形 
function getTerrainProvider(cfg, serverURL) {
    if (cfg && cfg.url) {
        if (serverURL) {
            cfg.url = cfg.url.replace('$serverURL$', serverURL);
        }
        cfg.url = cfg.url.replace('$hostname$', location.hostname).replace('$host$', location.host);
    }

    return _layer.getTerrainProvider(cfg);
}

//获取自定义底图切换
function getImageryProviderArr(layersCfg) {
    var providerViewModels = [];
    var selectedIndex = -1;

    window._temp_createImageryProvider = _layer.createImageryProvider;

    for (var i = 0; i < layersCfg.length; i++) {
        var item = layersCfg[i];
        if (item.type == "group" && item.layers == null) continue;

        if (item.visible) selectedIndex = providerViewModels.length;

        var funstr = 'window._temp_mars_basemaps' + i + ' = function () {\
                        var item = ' + JSON.stringify(item) + ';\
                        if (item.type == "group") {\
                            var arrVec = [];\
                            for (var index = 0; index < item.layers.length; index++) {\
                                var temp = window._temp_createImageryProvider(item.layers[index]);\
                                if (temp == null) continue;\
                                arrVec.push(temp);\
                            }\
                            return arrVec;\
                        }\
                        else {\
                            return window._temp_createImageryProvider(item);\
                        } \
                    }';
        eval(funstr);

        var imgModel = new Cesium.ProviderViewModel({
            name: item.name || "未命名",
            tooltip: item.name || "未命名",
            iconUrl: item.icon || "",
            creationFunction: eval('window._temp_mars_basemaps' + i)
        });
        providerViewModels.push(imgModel);
    }

    return {
        imageryProviderViewModels: providerViewModels,
        index: selectedIndex
    };
}

function getTerrainProviderViewModelsArr() {
    return [new Cesium.ProviderViewModel({
        name: '无地形',
        iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/Ellipsoid.png'),
        tooltip: 'WGS84标准椭球，即 EPSG:4326',
        category: '',
        creationFunction: function creationFunction() {
            return _layer.getEllipsoidTerrain();
        }
    }), new Cesium.ProviderViewModel({
        name: 'MarsGIS 中国地形',
        iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/CesiumWorldTerrain.png'),
        tooltip: 'MarsGIS提供的高分辨率中国地形',
        category: '',
        creationFunction: function creationFunction() {
            return _layer.getTerrainProvider({
                url: "//data.marsgis.cn/terrain"
            });;
        }
    }), new Cesium.ProviderViewModel({
        name: 'Cesium Ion 全球地形',
        iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/CesiumWorldTerrain.png'),
        tooltip: 'Cesium官方Ion提供的高分辨率全球地形',
        category: '',
        creationFunction: function creationFunction() {
            return _layer.getTerrainProvider({
                type: 'ion'
            });;
        }
    }), new Cesium.ProviderViewModel({
        name: 'ArcGIS 全球地形',
        iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/CesiumWorldTerrain.png'),
        tooltip: 'arcgis官方提供的高分辨率全球地形',
        category: '',
        creationFunction: function creationFunction() {
            return _layer.getTerrainProvider({
                "type": "arcgis",
                "url": 'https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer'
            });;
        }
    })];
}

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GaodePOIGeocoder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _util = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//高德POI查询 类
var GaodePOIGeocoder = exports.GaodePOIGeocoder = function () {
    //========== 构造方法 ========== 
    function GaodePOIGeocoder(options) {
        _classCallCheck(this, GaodePOIGeocoder);

        options = options || {};
        this.citycode = options.citycode || '';
        //内置高德地图服务key，建议后期传入自己申请的
        this.gaodekey = options.key || ["ae29a37307840c7ae4a785ac905927e0", //2020-6-18
        "888a52a74c55ca47abe6c55ab3661d11", "0bc2903efcb3b67ebf1452d2f664a238", "0df8f6f984adc49fca5b7b1108664da2", "72f75689dff38a781055e68843474751"];
    }

    //========== 对外属性 ==========  
    // //裁剪距离 
    // get distance() {
    //     return this._distance || 0;
    // }
    // set distance(val) {
    //     this._distance = val; 
    // }

    //========== 方法 ========== 

    _createClass(GaodePOIGeocoder, [{
        key: 'getOneKey',
        value: function getOneKey() {
            var arr = this.gaodekey;
            var n = Math.floor(Math.random() * arr.length + 1) - 1;
            return arr[n];
        }
    }, {
        key: 'geocode',
        value: function geocode(query, geocodeType) {
            var that = this;

            var key = this.getOneKey();

            var resource = new Cesium.Resource({
                url: 'https://restapi.amap.com/v3/place/text',
                queryParameters: {
                    key: key,
                    city: this.citycode,
                    //citylimit: true,
                    keywords: query
                }
            });

            return resource.fetchJson().then(function (results) {
                if (results.status == 0) {
                    (0, _util.msg)("请求失败(" + results.infocode + ")：" + results.info);
                    return;
                }
                if (results.pois.length === 0) {
                    (0, _util.msg)("未查询到“" + query + "”相关数据！");
                    return;
                }

                var height = 3000;
                if (that.viewer.camera.positionCartographic.height < height) height = that.viewer.camera.positionCartographic.height;

                return results.pois.map(function (resultObject) {
                    var arrjwd = resultObject.location.split(",");
                    arrjwd = pointconvert.gcj2wgs(arrjwd); //纠偏
                    var lnglat = that.viewer.mars.point2map({ x: arrjwd[0], y: arrjwd[1] });

                    return {
                        displayName: resultObject.name,
                        destination: Cesium.Cartesian3.fromDegrees(lnglat.x, lnglat.y, height)
                    };
                });
            });
        }
    }]);

    return GaodePOIGeocoder;
}();

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FloodByEntity = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(21);

var polygonAttr = _interopRequireWildcard(_Attr);

var _tileset = __webpack_require__(27);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//淹没分析(平面)类
var FloodByEntity = exports.FloodByEntity = function (_MarsClass) {
    _inherits(FloodByEntity, _MarsClass);

    //========== 构造方法 ========== 
    function FloodByEntity(options, oldparam) {
        _classCallCheck(this, FloodByEntity);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (FloodByEntity.__proto__ || Object.getPrototypeOf(FloodByEntity)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.viewer = options.viewer;
        return _this;
    }

    //========== 对外属性 ==========  
    //高度


    _createClass(FloodByEntity, [{
        key: 'start',


        //========== 方法 ========== 


        //开发分析
        value: function start(entity, options) {
            var _this2 = this;

            this.stop();

            this.entity = entity;
            this.options = options;

            //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
            if (this.options.onChange) {
                this.off(_MarsClass2.eventType.change);
                this.on(_MarsClass2.eventType.change, function (e) {
                    _this2.options.onChange(e.height);
                });
            }
            if (this.options.onStop) {
                this.off(_MarsClass2.eventType.end);
                this.on(_MarsClass2.eventType.end, this.options.onStop);
            }
            //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

            this.extrudedHeight = options.height;
            this.entity.polygon.extrudedHeight = new Cesium.CallbackProperty(function (time) {
                return _this2.extrudedHeight;
            }, false);

            this.fire(_MarsClass2.eventType.start);

            //修改高度值
            var positions = polygonAttr.getPositions(this.entity);
            var _has3dtiles = Cesium.defaultValue(options.has3dtiles, Cesium.defined((0, _tileset.pick3DTileset)(this.viewer.scene, positions))); //是否在3ditiles上面
            if (!_has3dtiles) {
                this._last_depthTestAgainstTerrain = this.viewer.scene.globe.depthTestAgainstTerrain;
                this.viewer.scene.globe.depthTestAgainstTerrain = true;
            }

            positions = (0, _point.setPositionsHeight)(positions, options.height);
            this.entity.polygon.hierarchy = new Cesium.PolygonHierarchy(positions);

            this.timeIdx = setInterval(function () {
                if (_this2.extrudedHeight >= _this2.options.maxHeight) {
                    _this2.stop();
                    return;
                }
                var newHeight = _this2.extrudedHeight + _this2.options.speed;
                if (newHeight > _this2.options.maxHeight) {
                    _this2.extrudedHeight = _this2.options.maxHeight;
                } else {
                    _this2.extrudedHeight = newHeight;
                }

                _this2.fire(_MarsClass2.eventType.change, {
                    height: _this2.extrudedHeight
                });
            }, 100);
        }
        //停止分析

    }, {
        key: 'stop',
        value: function stop() {
            clearInterval(this.timeIdx);
            this.fire(_MarsClass2.eventType.end);
        }

        //清除分析

    }, {
        key: 'clear',
        value: function clear() {
            this.stop();
            if (this._last_depthTestAgainstTerrain !== null) this.viewer.scene.globe.depthTestAgainstTerrain = this._last_depthTestAgainstTerrain;
            this.entity = null;
        }

        //更新高度

    }, {
        key: 'updateHeight',
        value: function updateHeight(height) {
            this.extrudedHeight = height;

            this.fire(_MarsClass2.eventType.change, {
                height: this.extrudedHeight
            });
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.clear();
            _get(FloodByEntity.prototype.__proto__ || Object.getPrototypeOf(FloodByEntity.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'height',
        get: function get() {
            return this.extrudedHeight;
        },
        set: function set(val) {
            this.extrudedHeight = val;
        }
    }]);

    return FloodByEntity;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


FloodByEntity.event = {
    start: _MarsClass2.eventType.start,
    change: _MarsClass2.eventType.change,
    end: _MarsClass2.eventType.end
};

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FloodByTerrain = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//地形淹没（材质）分析 类
var FloodByTerrain = exports.FloodByTerrain = function (_MarsClass) {
    _inherits(FloodByTerrain, _MarsClass);

    //========== 构造方法 ========== 
    function FloodByTerrain(options, oldparam) {
        _classCallCheck(this, FloodByTerrain);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (FloodByTerrain.__proto__ || Object.getPrototypeOf(FloodByTerrain)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.viewer = options.viewer;
        _this.minHeight = options.minHeight;
        _this.maxHeight = options.maxHeight;

        //检查参数
        if (!Cesium.defined(_this.minHeight)) {
            marslog.warn("minHeight请传入有效数值！");
            return _possibleConstructorReturn(_this);
        }
        if (!Cesium.defined(_this.maxHeight)) {
            marslog.warn("maxHeight请传入有效数值！");
            return _possibleConstructorReturn(_this);
        }
        if (_this.minHeight > _this.maxHeight) {
            //互相交换数据
            var temp = _this.minHeight;
            _this.minHeight = _this.maxHeight;
            _this.maxHeight = temp;
        }

        _this.height = options.height;
        _this.floodVar = Cesium.defaultValue(options.floodVar, [0, 0, 0, 500]); //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
        _this.ym_pos_x = Cesium.defaultValue(options.ym_pos_x, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _this.ym_pos_y = Cesium.defaultValue(options.ym_pos_y, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _this.ym_pos_z = Cesium.defaultValue(options.ym_pos_z, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _this.rect_flood = Cesium.defaultValue(options.rect_flood, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]); //包围盒[minx,miny,minz,maxx,maxy,maxz,0.0,0.0,0.0]
        _this.ym_max_index = Cesium.defaultValue(options.ym_max_index, 0); //点选点的个数
        _this._globe = Cesium.defaultValue(options.globe, true); //是否全球淹没
        _this._speed = Cesium.defaultValue(options.speed, 1); //淹没速度
        _this._visibleOutArea = Cesium.defaultValue(options.visibleOutArea, true); //是否显示非淹没区域
        _this._boundingSwell = Cesium.defaultValue(options.boundingSwell, 20); //点集合的包围盒膨胀数值
        _this._show = Cesium.defaultValue(options.show, true);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        if (options.onChange) {
            _this.on(_MarsClass2.eventType.change, function (e) {
                options.onChange(e.height);
            });
        }
        if (options.onStop) {
            _this.on(_MarsClass2.eventType.end, options.onStop);
        }
        _this.cancelFloodSpeed = _this.stop; //别名
        _this.reFlood = _this.restart;
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码


        if (options.positions && options.positions.length > 0) _this.start(options.positions);
        return _this;
    }

    //========== 对外属性 ==========  
    //分析参数


    _createClass(FloodByTerrain, [{
        key: 'start',

        //========== 方法 ========== 


        //初始化
        value: function start(positions) {
            this._positions = positions || this._positions;
            if (!positions || positions.length == 0) return;

            this._prepareFlood(positions);
            this._setFloodVar();
            this._startFlood();
            this._activeFloodSpeed();
        }

        //激活淹没动画

    }, {
        key: '_activeFloodSpeed',
        value: function _activeFloodSpeed() {
            var that = this;
            if (!this.activeFlooding) {
                this.fire(_MarsClass2.eventType.start);
                this.activeFlooding = function () {
                    if (that.height) {
                        that.floodVar[1] = that.height();
                    } else {
                        that.floodVar[1] += that.speed / 50; //50帧每秒
                    }
                    if (that.floodVar[1] > that.floodVar[2]) {
                        that.floodVar[1] = that.floodVar[2];
                        that.stop();
                        // that.onStop&&that.onStop();
                        return;
                    }
                    if (that.floodVar[1] < that.floodVar[0]) {
                        that.floodVar[1] = that.floodVar[0];
                        that.stop();
                        // that.onStop&&that.onStop();
                        return;
                    }
                    that.floodAnalysis.floodVar[1] = that.floodVar[1];
                    that.fire(_MarsClass2.eventType.change, {
                        height: that.floodVar[1]
                    });
                };
                this.viewer.clock.onTick.addEventListener(this.activeFlooding);
            }
        }

        //暂停淹没动画

    }, {
        key: 'stop',
        value: function stop() {
            this.viewer.clock.onTick.removeEventListener(this.activeFlooding);
            this.activeFlooding = null;
            this.fire(_MarsClass2.eventType.end);
        }
        //重新淹没

    }, {
        key: 'restart',
        value: function restart() {
            this.floodVar[1] = this.floodVar[0];
            this._activeFloodSpeed();
        }

        //与处理顶点数组

    }, {
        key: '_prepareFlood',
        value: function _prepareFlood(arr) {
            this.ym_pos_arr = arr;
            var len = arr.length;
            if (len == 0) return;
            this.ym_max_index = len;
            var minX = 99999999;
            var minY = 99999999;
            var minZ = 99999999;
            var maxX = -99999999;
            var maxY = -99999999;
            var maxZ = -99999999;
            for (var i = 0; i < len; i++) {
                if (arr[i]) {
                    this.ym_pos_x[i] = arr[i].x;
                    this.ym_pos_y[i] = arr[i].y;
                    this.ym_pos_z[i] = arr[i].z;

                    if (arr[i].x > maxX) {
                        maxX = arr[i].x;
                    }
                    if (arr[i].x < minX) {
                        minX = arr[i].x;
                    }

                    if (arr[i].y > maxY) {
                        maxY = arr[i].y;
                    }
                    if (arr[i].y < minY) {
                        minY = arr[i].y;
                    }

                    if (arr[i].z > maxZ) {
                        maxZ = arr[i].z;
                    }
                    if (arr[i].z < minZ) {
                        minZ = arr[i].z;
                    }
                } else {
                    this.ym_pos_x[i] = 0.0;
                    this.ym_pos_y[i] = 0.0;
                    this.ym_pos_z[i] = 0.0;
                }
            }
            var chaNum = this.boundingSwell;
            this._base_rect = this.rect_flood = [minX - chaNum, minY - chaNum, minZ - chaNum, maxX + chaNum, maxY + chaNum, maxZ + chaNum, 0.0, 0.0, 0.0];
        }
        //设置淹没高度

    }, {
        key: '_setFloodVar',
        value: function _setFloodVar() {
            this.floodVar = [this.minHeight, this.minHeight, this.maxHeight, this.maxHeight - this.minHeight];
        }
        //开始淹没

    }, {
        key: '_startFlood',
        value: function _startFlood() {
            this.floodAnalysis.floodVar[0] = this.floodVar[0];
            this.floodAnalysis.floodVar[1] = this.floodVar[1];
            this.floodAnalysis.ym_pos_x = this.ym_pos_x;
            this.floodAnalysis.ym_pos_y = this.ym_pos_y;
            this.floodAnalysis.ym_pos_z = this.ym_pos_z;
            this.floodAnalysis.rect_flood = this.rect_flood;
            this.floodAnalysis.ym_pos_arr = this.ym_pos_arr;
            this.floodAnalysis.floodSpeed = this.speed;
            this.floodAnalysis.ym_max_index = this.ym_max_index;
            this.floodAnalysis.globe = this.globe = false;
            this.floodAnalysis.showElseArea = this.visibleOutArea;
            this.viewer.scene.globe.material = Cesium.Material.fromType('YanMo');
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.stop();
            this.viewer.scene.globe.material = null;
            this.viewer.scene.globe._surface.tileProvider.resetFloodAnalysis();
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.clear();
            _get(FloodByTerrain.prototype.__proto__ || Object.getPrototypeOf(FloodByTerrain.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'floodAnalysis',
        get: function get() {
            return this.viewer.scene.globe._surface.tileProvider.floodAnalysis;
        }
    }, {
        key: 'positions',
        get: function get() {
            return this._positions;
        },
        set: function set(val) {
            this._positions = val;
            this.start(val);
        }

        //显示非淹没区域

    }, {
        key: 'visibleOutArea',
        get: function get() {
            return this._visibleOutArea;
        },
        set: function set(val) {
            this._visibleOutArea = val;
            this.floodAnalysis.showElseArea = val;
        }

        //全球淹没

    }, {
        key: 'globe',
        get: function get() {
            return this._globe;
        },
        set: function set(val) {
            this._globe = val;
            this.floodAnalysis.globe = val;
        }

        //淹没速度

    }, {
        key: 'speed',
        get: function get() {
            return this._speed;
        },
        set: function set(val) {
            this._speed = Number(val);
        }
        //点集合的包围盒膨胀数值

    }, {
        key: 'boundingSwell',
        get: function get() {
            return this._boundingSwell;
        },
        set: function set(num) {
            var rect = this._base_rect;
            this._boundingSwell = Number(num);
            this.rect_flood = [rect[0] - this.boundingSwell, rect[1] - this.boundingSwell, rect[2] - this.boundingSwell, rect[3] - this.boundingSwell, rect[4] - this.boundingSwell, rect[5] - this.boundingSwell, 0, 0, 0];
            this.floodAnalysis.rect_flood = this.rect_flood;
        }

        //显示和隐藏

    }, {
        key: 'show',
        get: function get() {
            return this._show;
        },
        set: function set(val) {
            this._show = val;
            if (val) {
                this.viewer.scene.globe.material = Cesium.Material.fromType('YanMo');
            } else {
                this.viewer.scene.globe.material = null;
            }
        }
    }]);

    return FloodByTerrain;
}(_MarsClass2.MarsClass);
//[静态属性]本类中支持的事件类型常量


FloodByTerrain.event = {
    start: _MarsClass2.eventType.start,
    change: _MarsClass2.eventType.change,
    end: _MarsClass2.eventType.end
};

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Measure = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _Draw = __webpack_require__(6);

var _MeasureBase = __webpack_require__(26);

var _MeasureAngle = __webpack_require__(74);

var _MeasureArea = __webpack_require__(36);

var _MeasureAreaSurface = __webpack_require__(76);

var _MeasureHeight = __webpack_require__(77);

var _MeasureHeightTriangle = __webpack_require__(78);

var _MeasureLength = __webpack_require__(37);

var _MeasureLengthSection = __webpack_require__(79);

var _MeasureLengthSurface = __webpack_require__(80);

var _MeasurePoint = __webpack_require__(81);

var _MeasureVolume = __webpack_require__(82);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //提供测量长度、面积等 [绘制基于draw]

//量算类(统一入口)
var Measure = exports.Measure = function (_MarsClass) {
    _inherits(Measure, _MarsClass);

    function Measure(options, oldparam) {
        _classCallCheck(this, Measure);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (Measure.__proto__ || Object.getPrototypeOf(Measure)).call(this));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        _this.clearMeasure = _this.clear; //别名, 但不建议使用。
        _this.measureLength = _this.length;
        _this.measuerLength = _this.length;
        _this.measureSection = _this.section;
        _this.measureArea = _this.area;
        _this.measureHeight = _this.height;
        _this.measureAngle = _this.angle;
        _this.measurePoint = _this.point;
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.options = options;

        // 标绘对象
        _this.drawControl = new _Draw.Draw(options.viewer, _extends({
            hasEdit: false
        }, options));
        _this.options.draw = _this.drawControl;

        return _this;
    }

    _createClass(Measure, [{
        key: 'length',


        /*长度测量*/
        value: function length(opts) {
            this.stopDraw();
            if (opts && opts.terrain) {
                //兼容v2.2之前旧版本处理,贴地 
                return this.surfaceLength(opts);
            } else {
                if (!this._measureLength) {
                    this._measureLength = new _MeasureLength.MeasureLength(this.options, this);
                }
                this._measureLength.startDraw(opts);
                return this._measureLength;
            }
        }

        /*贴地 长度测量*/

    }, {
        key: 'surfaceLength',
        value: function surfaceLength(opts) {
            this.stopDraw();
            if (!this._measureLengthSurface) {
                this._measureLengthSurface = new _MeasureLengthSurface.MeasureLengthSurface(this.options, this);
            }
            this._measureLengthSurface.startDraw(opts);
            return this._measureLengthSurface;
        }

        /*剖面分析*/

    }, {
        key: 'section',
        value: function section(opts) {
            this.stopDraw();
            if (!this._measureLengthSection) {
                this._measureLengthSection = new _MeasureLengthSection.MeasureLengthSection(this.options, this);
            }
            this._measureLengthSection.startDraw(opts);
            return this._measureLengthSection;
        }

        /*面积测量*/

    }, {
        key: 'area',
        value: function area(opts) {
            this.stopDraw();
            if (opts && opts.terrain) {
                //兼容v2.2之前旧版本处理,贴地
                return this.surfaceeArea(opts);
            } else {
                if (!this._measureArea) {
                    this._measureArea = new _MeasureArea.MeasureArea(this.options, this);
                }
                this._measureArea.startDraw(opts);
                return this._measureArea;
            }
        }
    }, {
        key: 'surfaceeArea',


        /*贴地 面积测量*/
        value: function surfaceeArea(opts) {
            this.stopDraw();
            if (!this._measureAreaSurface) {
                this._measureAreaSurface = new _MeasureAreaSurface.MeasureAreaSurface(this.options, this);
            }
            this._measureAreaSurface.startDraw(opts);
            return this._measureAreaSurface;
        }

        /*体积测量（方量分析）*/

    }, {
        key: 'volume',
        value: function volume(opts) {
            this.stopDraw();
            if (!this._measureVolume) {
                this._measureVolume = new _MeasureVolume.MeasureVolume(this.options, this);
            }
            this._measureVolume.startDraw(opts);
            return this._measureVolume;
        }

        /*高度测量*/

    }, {
        key: 'height',
        value: function height(opts) {
            this.stopDraw();
            if (opts && opts.isSuper) {
                //兼容v2.2之前旧版本处理,三角测量
                return this.triangleHeight(opts);
            } else {
                if (!this._measureHeight) {
                    this._measureHeight = new _MeasureHeight.MeasureHeight(this.options, this);
                }
                this._measureHeight.startDraw(opts);
                return this._measureHeight;
            }
        }
    }, {
        key: 'triangleHeight',


        /*三角高度测量*/
        value: function triangleHeight(opts) {
            this.stopDraw();
            if (!this._measureHeightTriangle) {
                this._measureHeightTriangle = new _MeasureHeightTriangle.MeasureHeightTriangle(this.options, this);
            }
            this._measureHeightTriangle.startDraw(opts);
            return this._measureHeightTriangle;
        }
    }, {
        key: 'angle',


        /*角度测量*/
        value: function angle(opts) {
            this.stopDraw();
            if (!this._measureAngle) {
                this._measureAngle = new _MeasureAngle.MeasureAngle(this.options, this);
            }
            this._measureAngle.startDraw(opts);
            return this._measureAngle;
        }
    }, {
        key: 'point',


        /*坐标测量*/
        value: function point(opts) {
            this.stopDraw();
            if (!this._measurePoint) {
                this._measurePoint = new _MeasurePoint.MeasurePoint(this.options, this);
            }
            this._measurePoint.startDraw(opts);
            return this._measurePoint;
        }
    }, {
        key: 'stopDraw',


        //取消并停止绘制
        //如果上次未完成绘制就单击了新的，清除之前未完成的。
        value: function stopDraw() {
            if (this._measureAngle) this._measureAngle.stopDraw();
            if (this._measureArea) this._measureArea.stopDraw();
            if (this._measureAreaSurface) this._measureAreaSurface.stopDraw();
            if (this._measureHeight) this._measureHeight.stopDraw();
            if (this._measureHeightTriangle) this._measureHeightTriangle.stopDraw();
            if (this._measureLength) this._measureLength.stopDraw();
            if (this._measureLengthSection) this._measureLengthSection.stopDraw();
            if (this._measureLengthSurface) this._measureLengthSurface.stopDraw();
            if (this._measurePoint) this._measurePoint.stopDraw();
            if (this._measureVolume) this._measureVolume.stopDraw();
        }

        //外部控制，完成绘制，比如手机端无法双击结束 

    }, {
        key: 'endDraw',
        value: function endDraw() {
            if (this._measureAngle) this._measureAngle.endDraw();
            if (this._measureArea) this._measureArea.endDraw();
            if (this._measureAreaSurface) this._measureAreaSurface.endDraw();
            if (this._measureHeight) this._measureHeight.endDraw();
            if (this._measureHeightTriangle) this._measureHeightTriangle.endDraw();
            if (this._measureLength) this._measureLength.endDraw();
            if (this._measureLengthSection) this._measureLengthSection.endDraw();
            if (this._measureLengthSurface) this._measureLengthSurface.endDraw();
            if (this._measurePoint) this._measurePoint.endDraw();
            if (this._measureVolume) this._measureVolume.endDraw();
        }

        /*清除测量*/

    }, {
        key: 'clear',
        value: function clear() {
            if (this._measureAngle) this._measureAngle.clear();
            if (this._measureArea) this._measureArea.clear();
            if (this._measureAreaSurface) this._measureAreaSurface.clear();
            if (this._measureHeight) this._measureHeight.clear();
            if (this._measureHeightTriangle) this._measureHeightTriangle.clear();
            if (this._measureLength) this._measureLength.clear();
            if (this._measureLengthSection) this._measureLengthSection.clear();
            if (this._measureLengthSurface) this._measureLengthSurface.clear();
            if (this._measurePoint) this._measurePoint.clear();
            if (this._measureVolume) this._measureVolume.clear();
        }
    }, {
        key: 'updateUnit',


        /** 更新量测结果的单位 */
        value: function updateUnit(unit, oldparam) {
            //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
            if (oldparam) {
                unit = oldparam;
            }
            //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

            var arr = this.dataSource.entities.values;
            for (var i = 0, len = arr.length; i < len; i++) {
                var entity = arr[i];
                if (entity.label && entity.attribute && entity.showText) {
                    entity.showText(unit);
                }
            }
        }
    }, {
        key: 'formatArea',
        value: function formatArea(val, unit) {
            return util.formatArea(val, unit);
        }
    }, {
        key: 'formatLength',
        value: function formatLength(val, unit) {
            return util.formatLength(val, unit);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.stopDraw();
            this.clear();

            this.drawControl.destroy();
            _get(Measure.prototype.__proto__ || Object.getPrototypeOf(Measure.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'draw',
        get: function get() {
            return this.drawControl;
        }
    }, {
        key: 'dataSource',
        get: function get() {
            return this.drawControl.dataSource;
        }
    }]);

    return Measure;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


Measure.event = _MeasureBase.MeasureBase.event;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Skyline = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _Skyline = __webpack_require__(141);

var _Skyline2 = _interopRequireDefault(_Skyline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//天际线 类
var Skyline = exports.Skyline = function (_MarsClass) {
    _inherits(Skyline, _MarsClass);

    function Skyline(options, oldparam) {
        _classCallCheck(this, Skyline);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (Skyline.__proto__ || Object.getPrototypeOf(Skyline)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.viewer = options.viewer;
        _this.tjxWidth = Cesium.defaultValue(options.tjxWidth, 2); //天际线宽度
        _this.strokeType = Cesium.defaultValue(options.strokeType, new Cesium.Cartesian3(true, false, false)); //天际线，物体描边，全描边
        _this.tjxColor = Cesium.defaultValue(options.tjxColor, new Cesium.Color(1.0, 0.0, 0.0)); //边际线颜色
        _this.bjColor = Cesium.defaultValue(options.bjColor, new Cesium.Color(0.0, 0.0, 1.0)); //物体描边颜色
        _this.mbDis = Cesium.defaultValue(options.mbDis, 500); //物体描边距离

        var that = _this;
        _this.postProcess = new Cesium.PostProcessStage({
            fragmentShader: _Skyline2.default,
            uniforms: {
                height: function height() {
                    return that.viewer.camera.positionCartographic.height;
                },
                lineWidth: function lineWidth() {
                    return that.tjxWidth;
                },
                strokeType: function strokeType() {
                    return that.strokeType;
                },
                tjxColor: function tjxColor() {
                    return that.tjxColor;
                },
                bjColor: function bjColor() {
                    return that.bjColor;
                },
                cameraPos: function cameraPos() {
                    return that.viewer.scene.camera.position;
                },
                mbDis: function mbDis() {
                    return that.mbDis;
                }
            }
        });
        _this.postProcess.enabled = Cesium.defaultValue(options.enabled, true);
        _this.viewer.scene.postProcessStages.add(_this.postProcess);
        return _this;
    }

    //显示和隐藏


    _createClass(Skyline, [{
        key: "destroy",
        value: function destroy() {
            this.viewer.scene.postProcessStages.remove(this.postProcess);
            this.postProcess.destroy();
            delete this.postProcess;

            _get(Skyline.prototype.__proto__ || Object.getPrototypeOf(Skyline.prototype), "destroy", this).call(this);
        }
    }, {
        key: "enabled",
        get: function get() {
            return this.postProcess.enabled;
        },
        set: function set(val) {
            this.postProcess.enabled = val;
        }
    }]);

    return Skyline;
}(_MarsClass2.MarsClass);

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nuniform float lineWidth;\r\nuniform float height;\r\nuniform bvec3 strokeType;\r\nuniform vec3 tjxColor;\r\nuniform vec3 bjColor;\r\nuniform vec3 cameraPos;\r\nuniform float mbDis;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nbool isTJX(vec2 uv,float lw){\r\n    vec2 pixelSize = lw / czm_viewport.zw;\r\n    float dx0 = -pixelSize.x;\r\n    float dy0 = -pixelSize.y;\r\n    float dx1 = pixelSize.x;\r\n    float dy1 = pixelSize.y;\r\n\r\n    vec2 currUV = uv + vec2(dx0, dy0);\r\n    vec4 currDepth = texture2D(depthTexture, currUV);\r\n    float depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    return false;\r\n}\r\nvoid main(){\r\n\r\n\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    if(height>14102.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 normal = normalize(cross(dx,dy));\r\n\r\n    if(strokeType.y||strokeType.z){\r\n        vec4 wp = czm_inverseView * positionEC;\r\n        if(distance(wp.xyz,cameraPos)>mbDis){\r\n            gl_FragColor = color;\r\n        }else{\r\n            float dotNum = abs(dot(normal,normalize(positionEC.xyz)));\r\n            if(dotNum<0.05){\r\n                gl_FragColor = vec4(bjColor,1.0);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if(strokeType.x||strokeType.z){\r\n        bool tjx = isTJX(v_textureCoordinates,lineWidth);\r\n        if(tjx){\r\n            gl_FragColor = vec4(tjxColor,1.0);\r\n            return;\r\n        }\r\n    }\r\n    gl_FragColor = color;\r\n}"

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerrainClip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _CustomPlaneGeometry = __webpack_require__(83);

var _WellNoBottom = __webpack_require__(84);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//地形开挖 类 (基于地形)
var TerrainClip = exports.TerrainClip = function (_MarsClass) {
    _inherits(TerrainClip, _MarsClass);

    //========== 构造方法 ========== 
    function TerrainClip(options, oldparam) {
        _classCallCheck(this, TerrainClip);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (TerrainClip.__proto__ || Object.getPrototypeOf(TerrainClip)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码


        _this.viewer = options.viewer;

        if (!_this.viewer.scene.highDynamicRange) {
            _this.viewer.scene.highDynamicRange = true;
            _this._hasChangeHighDynamicRange = true;
        }

        _this.bottomImg = options.bottomImg;
        _this.wallImg = options.wallImg;

        _this.opacityImg = Cesium.defaultValue(options.opacity, 1.0);
        _this.splitNum = Cesium.defaultValue(options.splitNum, 30); //每两点之间插值个数
        _this.dig_pos_x = Cesium.defaultValue(options.dig_pos_x, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _this.dig_pos_y = Cesium.defaultValue(options.dig_pos_y, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _this.dig_pos_z = Cesium.defaultValue(options.dig_pos_z, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _this.rect_dig = Cesium.defaultValue(options.rect_dig, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]); //包围盒[minx,miny,minz,maxx,maxy,maxz,0.0,0.0,0.0]
        _this.excavateMinHeight = Cesium.defaultValue(options.excavateMinHeight, 9999); //最低挖掘海拔值
        _this.excavatePerPoint = Cesium.defaultValue(options.excavatePerPoint, false); //是否按插值点挖掘
        _this.dig_max_index = Cesium.defaultValue(options.dig_max_index, 0); //点选点的个数
        _this.defaultShowSelfOnly = Cesium.defaultValue(options.showSelfOnly, false); //是否只显示自己
        _this._height = Cesium.defaultValue(options.height, 0); //挖掘深度
        _this._show = Cesium.defaultValue(options.show, true);
        _this.defaultBoundingSwell = Cesium.defaultValue(options.boundingSwell, 20);
        _this._showWall = Cesium.defaultValue(options.wall, true); //是否显示挖掘的底部和wall

        if (options.positions && options.positions.length > 0) _this.setPositions(options.positions);
        return _this;
    }

    //========== 对外属性 ========== 
    //参数


    _createClass(TerrainClip, [{
        key: "setPositions",

        //========== 方法 ========== 

        //初始化没传顶点，后面设置顶点
        value: function setPositions(positions) {
            this._positions = positions;
            if (!positions || positions.length == 0) return;
            this._startExcavate(positions);
            this.viewer.scene.globe.material = Cesium.Material.fromType('WaJue');
            this.viewer.scene.globe.depthTestAgainstTerrain = true;
            this._effectExcavate();
        }

        //准备井数据

    }, {
        key: "_prepareWell",
        value: function _prepareWell(arr) {
            var splitNum = this.splitNum;
            var len = arr.length;
            if (len == 0) return;
            var targetHeight = this.excavateMinHeight - this.height;
            this.targetHeight = targetHeight;
            var no_height_top = [];
            var bottom_pos = [];
            var lerp_pos = [];
            for (var i = 0; i < len; i++) {
                var static_i = i == len - 1 ? 0 : i + 1;
                var currRad = Cesium.Cartographic.fromCartesian(arr[i]);
                var nextRad = Cesium.Cartographic.fromCartesian(arr[static_i]);
                var pos1 = [currRad.longitude, currRad.latitude];
                var pos2 = [nextRad.longitude, nextRad.latitude];
                // if (i == 0) {
                //     lerp_pos.push(new Cesium.Cartographic(pos1[0], pos1[1]));
                //     bottom_pos.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], targetHeight));
                //     no_height_top.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], 0));
                // }
                for (var j = 0; j < splitNum; j++) {
                    var curr_pos_lon = Cesium.Math.lerp(pos1[0], pos2[0], j / splitNum);
                    var curr_pos_lat = Cesium.Math.lerp(pos1[1], pos2[1], j / splitNum);
                    // if (!(i == len - 1 && j == splitNum)) {
                    lerp_pos.push(new Cesium.Cartographic(curr_pos_lon, curr_pos_lat));
                    bottom_pos.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, targetHeight));
                    no_height_top.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, 0));
                    // }
                }
            }
            this.wellData = {
                lerp_pos: lerp_pos,
                bottom_pos: bottom_pos,
                no_height_top: no_height_top
            };
        }
        //创建井

    }, {
        key: "_createWell",
        value: function _createWell(options) {
            var hasTerrain = Boolean(this.viewer.terrainProvider._layers);
            if (hasTerrain) {
                var self = this;
                this._createBottomSurface(options.bottom_pos);
                var promise = Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, options.lerp_pos);
                var maxHeight = -9999;
                Cesium.when(promise, function (updatedPositions) {
                    var len = updatedPositions.length;
                    var top_pos = [];
                    var top_heights = [];
                    for (var k = 0; k < len; k++) {
                        top_heights.push(updatedPositions[k].height);
                        if (updatedPositions[k].height > maxHeight) maxHeight = updatedPositions[k].height;
                        var top_car = Cesium.Cartesian3.fromRadians(updatedPositions[k].longitude, updatedPositions[k].latitude, updatedPositions[k].height);
                        top_pos.push(top_car);
                    }
                    self.maxHeight = maxHeight;
                    self.top_heights = top_heights;
                    self._createWellWall(options.bottom_pos, top_pos);
                    self.viewer.scene.primitives.add(self.wellWall);
                });
            } else {
                this._createBottomSurface(options.bottom_pos);
                this._createWellWall(options.bottom_pos, options.no_height_top);
                this.viewer.scene.primitives.add(this.wellWall);
            }
        }
        //创建井壁

    }, {
        key: "_createWellWall",
        value: function _createWellWall(bottom, top) {
            var geo = new _WellNoBottom.WellNoBottom({
                minimumArr: bottom,
                maximumArr: top
            });
            geo = geo.createGeometry(geo, this);
            var _material = new Cesium.Material({
                fabric: {
                    type: 'Image',
                    uniforms: {
                        image: this.wallImg,
                        color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this.opacityImg)
                    }
                }
            });
            var _appearance = new Cesium.MaterialAppearance({
                translucent: false,
                flat: true,
                material: _material
            });
            this.wellWall = new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                    geometry: geo,
                    attributes: {
                        color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.GREY)
                    },
                    id: 'PitWall'
                }),
                appearance: _appearance,
                asynchronous: false
            });
        }
        //创建井底

    }, {
        key: "_createBottomSurface",
        value: function _createBottomSurface(bottom_pos) {
            if (!bottom_pos.length) {
                return;
            }
            var geo = new _CustomPlaneGeometry.CustomPlaneGeometry({
                pos_arr: bottom_pos
            });
            geo = geo.createGeometry(geo);
            var _material = new Cesium.Material({
                fabric: {
                    type: 'Image',
                    uniforms: {
                        image: this.bottomImg,
                        color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this.opacityImg)
                    }
                }
            });
            var _appearance = new Cesium.MaterialAppearance({
                translucent: false,
                flat: true,
                material: _material
            });
            this.bottomSurface = new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                    geometry: geo
                }),
                appearance: _appearance,
                asynchronous: false
            });
        }
        //准备挖掘

    }, {
        key: "_prepareExcavate",
        value: function _prepareExcavate(arr) {
            var len = arr.length;
            if (len == 0) return;
            this.dig_max_index = len;

            var minX = 99999999;
            var minY = 99999999;
            var minZ = 99999999;
            var maxX = -99999999;
            var maxY = -99999999;
            var maxZ = -99999999;
            for (var i = 0; i < len; i++) {
                if (arr[i]) {
                    this.dig_pos_x[i] = arr[i].x;
                    this.dig_pos_y[i] = arr[i].y;
                    this.dig_pos_z[i] = arr[i].z;
                    var rad = Cesium.Cartographic.fromCartesian(arr[i]);
                    this.excavateMinHeight = this.excavateMinHeight > rad.height ? rad.height : this.excavateMinHeight;
                    if (arr[i].x > maxX) {
                        maxX = arr[i].x;
                    }
                    if (arr[i].x < minX) {
                        minX = arr[i].x;
                    }

                    if (arr[i].y > maxY) {
                        maxY = arr[i].y;
                    }
                    if (arr[i].y < minY) {
                        minY = arr[i].y;
                    }

                    if (arr[i].z > maxZ) {
                        maxZ = arr[i].z;
                    }
                    if (arr[i].z < minZ) {
                        minZ = arr[i].z;
                    }
                } else {
                    this.dig_pos_x[i] = 0.0;
                    this.dig_pos_y[i] = 0.0;
                    this.dig_pos_z[i] = 0.0;
                }
            }
            var chaNum = this.boundingSwell;
            this._base_rect = this.rect_dig = [minX - chaNum, minY - chaNum, minZ - chaNum, maxX + chaNum, maxY + chaNum, maxZ + chaNum, 0.0, 0.0, 0.0];
        }
        //开始挖掘

    }, {
        key: "_startExcavate",
        value: function _startExcavate(arr) {
            this.viewer.scene.globe.material = Cesium.Material.fromType('WaJue');
            this._prepareExcavate(arr);

            if (this._showWall) {
                this._prepareWell(arr);
                if (!this.wellData) return;
                this._createWell(this.wellData);
            }
        }
        //更新挖掘深度

    }, {
        key: "_updateExcavateDepth",
        value: function _updateExcavateDepth(depth) {
            if (depth == undefined || depth == null) return;
            this.bottomSurface && this.viewer.scene.primitives.remove(this.bottomSurface);
            this.wellWall && this.viewer.scene.primitives.remove(this.wellWall);
            var lerp_pos = this.wellData.lerp_pos;
            var bottom_pos = [];
            var len = lerp_pos.length;
            for (var i = 0; i < len; i++) {
                bottom_pos.push(Cesium.Cartesian3.fromRadians(lerp_pos[i].longitude, lerp_pos[i].latitude, this.excavateMinHeight - depth));
            }
            this.wellData.bottom_pos = bottom_pos;
            this._createWell(this.wellData);

            if (this.bottomSurface) this.viewer.scene.primitives.add(this.bottomSurface);

            if (this.wellWall) this.viewer.scene.primitives.add(this.wellWall);
        }
        //挖掘生效

    }, {
        key: "_effectExcavate",
        value: function _effectExcavate() {
            this.excavateAnalysis.dig_pos_x = this.dig_pos_x;
            this.excavateAnalysis.dig_pos_y = this.dig_pos_y;
            this.excavateAnalysis.dig_pos_z = this.dig_pos_z;
            this.excavateAnalysis.dig_max_index = this.dig_max_index;
            this.excavateAnalysis.showSelfOnly = this.showSelfOnly;
            this.excavateAnalysis.rect_dig = this.rect_dig;

            if (this.bottomSurface) this.viewer.scene.primitives.add(this.bottomSurface);
        }
    }, {
        key: "clear",
        value: function clear() {
            this.viewer.scene.globe.material = null;
            this.viewer.scene.globe._surface.tileProvider.resetExcavateAnalysis();

            if (this.bottomSurface) {
                this.viewer.scene.primitives.remove(this.bottomSurface);
                delete this.bottomSurface;
            }

            if (this.wellWall) {
                this.viewer.scene.primitives.remove(this.wellWall);
                delete this.wellWall;
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            if (this._hasChangeHighDynamicRange) {
                this.viewer.scene.highDynamicRange = false;
                this._hasChangeHighDynamicRange = false;
            }

            this.clear();
            _get(TerrainClip.prototype.__proto__ || Object.getPrototypeOf(TerrainClip.prototype), "destroy", this).call(this);
        }
    }, {
        key: "excavateAnalysis",
        get: function get() {
            return this.viewer.scene.globe._surface.tileProvider.excavateAnalysis;
        }

        //仅显示自己

    }, {
        key: "showSelfOnly",
        get: function get() {
            return this.defaultShowSelfOnly;
        },
        set: function set(val) {
            this.defaultShowSelfOnly = val;
            this.excavateAnalysis.showSelfOnly = val;
        }

        //挖掘深度

    }, {
        key: "height",
        get: function get() {
            return this._height;
        },
        set: function set(val) {
            this._height = val;

            if (this._showWall) {
                this._updateExcavateDepth(val);
            }
        }
        //显示和隐藏

    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(val) {
            this._show = val;
            if (val) {
                this.viewer.scene.globe.material = Cesium.Material.fromType('WaJue');

                if (this._showWall) {
                    this.wellWall.show = true;
                    this.bottomSurface.show = true;
                }
            } else {
                this.viewer.scene.globe.material = null;

                if (this._showWall) {
                    this.wellWall.show = false;
                    this.bottomSurface.show = false;
                }
            }
        }

        //点集合的包围盒膨胀数值

    }, {
        key: "boundingSwell",
        get: function get() {
            return this.defaultBoundingSwell;
        },
        set: function set(num) {
            var rect = this._base_rect;
            this.defaultBoundingSwell = Number(num);
            this.rect_dig = [rect[0] - this.boundingSwell, rect[1] - this.boundingSwell, rect[2] - this.boundingSwell, rect[3] + this.boundingSwell, rect[4] + this.boundingSwell, rect[5] + this.boundingSwell, 0, 0, 0];
            this.excavateAnalysis.rect_dig = this.rect_dig;
        }
    }, {
        key: "positions",
        get: function get() {
            return this._positions;
        },
        set: function set(val) {
            this._positions = val;
            this.setPositions(val);
        }
    }]);

    return TerrainClip;
}(_MarsClass2.MarsClass);

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerrainClipPlan = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _CustomPlaneGeometry = __webpack_require__(83);

var _WellNoBottom = __webpack_require__(84);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//地形开挖 类（平面 Plan原生）
var TerrainClipPlan = exports.TerrainClipPlan = function (_MarsClass) {
    _inherits(TerrainClipPlan, _MarsClass);

    //========== 构造方法 ========== 
    function TerrainClipPlan(options, oldparam) {
        _classCallCheck(this, TerrainClipPlan);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (TerrainClipPlan.__proto__ || Object.getPrototypeOf(TerrainClipPlan)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        _this.updateData = _this.setPositions;
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.options = options;
        _this.viewer = options.viewer;

        _this._height = _this.options.height || 0;
        _this._showWall = Cesium.defaultValue(options.wall, true); //是否显示挖掘的底部和wall
        _this.bottomImg = options.bottomImg;
        _this.wallImg = options.wallImg;
        _this.opacityImg = Cesium.defaultValue(options.opacity, 1.0);
        _this.splitNum = Cesium.defaultValue(options.splitNum, 50);

        if (options.positions && options.positions.length > 0) {
            _this.setPositions(options.positions);
        }
        return _this;
    }

    //========== 对外属性 ==========  
    //挖掘深度


    _createClass(TerrainClipPlan, [{
        key: "setPositions",

        //========== 方法 ========== 

        // 创建裁剪面
        value: function setPositions(points) {
            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            this.clear();

            if (!points || points.length < 3) {
                marslog.warn("挖地坐标数据存在问题！");
                return;
            }
            this._positions = points;

            var clippingPlanes = [];
            var pointsLength = points.length;

            var unionClippingRegions = Cesium.defaultValue(opts.unionClippingRegions, false); //true时外切

            //是否顺时针 
            var startAngle = (0, _util.getAngle)(points[0], points[1]);
            var endAngle = (0, _util.getAngle)(points[0], points[2]);
            var direction = startAngle < endAngle;
            if (unionClippingRegions) direction = !direction;

            this.excavateMinHeight = 9999;

            for (var i = 0; i < pointsLength; ++i) {
                var nextIndex = (i + 1) % pointsLength;
                var midpoint = Cesium.Cartesian3.midpoint(points[i], points[nextIndex], new Cesium.Cartesian3());

                var tempCarto = Cesium.Cartographic.fromCartesian(points[i]);
                var heightTerrain = this.viewer.scene.globe.getHeight(tempCarto) || tempCarto.height; //地形高度 
                if (heightTerrain < this.excavateMinHeight) {
                    this.excavateMinHeight = heightTerrain;
                }

                var up = Cesium.Cartesian3.normalize(midpoint, new Cesium.Cartesian3());
                var right;
                if (direction) {
                    //顺时针
                    right = Cesium.Cartesian3.subtract(points[i], midpoint, new Cesium.Cartesian3());
                } else {
                    right = Cesium.Cartesian3.subtract(points[nextIndex], midpoint, new Cesium.Cartesian3());
                }
                right = Cesium.Cartesian3.normalize(right, right);
                var normal = Cesium.Cartesian3.cross(right, up, new Cesium.Cartesian3());
                normal = Cesium.Cartesian3.normalize(normal, normal);
                var originCenteredPlane = new Cesium.Plane(normal, 0.0);
                var distance = Cesium.Plane.getPointDistance(originCenteredPlane, midpoint);
                clippingPlanes.push(new Cesium.ClippingPlane(normal, distance));
            }

            this.viewer.scene.globe.clippingPlanes = new Cesium.ClippingPlaneCollection({
                planes: clippingPlanes,
                edgeWidth: Cesium.defaultValue(opts.edgeWidth, 1.0),
                edgeColor: Cesium.defaultValue(opts.edgeColor, Cesium.Color.WHITE),
                enabled: true,
                unionClippingRegions: unionClippingRegions
            });

            if (this._showWall) {
                this._prepareWell(points);
                this._createWell(this.wellData);
            }
        }

        //准备井数据

    }, {
        key: "_prepareWell",
        value: function _prepareWell(arr) {
            var splitNum = this.splitNum;
            var len = arr.length;
            if (len == 0) return;
            var targetHeight = this.excavateMinHeight - this.height;
            this.targetHeight = targetHeight;
            var no_height_top = [];
            var bottom_pos = [];
            var lerp_pos = [];
            for (var i = 0; i < len; i++) {
                var static_i = i == len - 1 ? 0 : i + 1;
                var currRad = Cesium.Cartographic.fromCartesian(arr[i]);
                var nextRad = Cesium.Cartographic.fromCartesian(arr[static_i]);
                var pos1 = [currRad.longitude, currRad.latitude];
                var pos2 = [nextRad.longitude, nextRad.latitude];
                // if (i == 0) {
                //     lerp_pos.push(new Cesium.Cartographic(pos1[0], pos1[1]));
                //     bottom_pos.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], targetHeight));
                //     no_height_top.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], 0));
                // }
                for (var j = 0; j < splitNum; j++) {
                    var curr_pos_lon = Cesium.Math.lerp(pos1[0], pos2[0], j / splitNum);
                    var curr_pos_lat = Cesium.Math.lerp(pos1[1], pos2[1], j / splitNum);
                    // if (!(i == len - 1 && j == splitNum)) {
                    lerp_pos.push(new Cesium.Cartographic(curr_pos_lon, curr_pos_lat));
                    bottom_pos.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, targetHeight));
                    no_height_top.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, 0));
                    // }
                }
            }
            this.wellData = {
                lerp_pos: lerp_pos,
                bottom_pos: bottom_pos,
                no_height_top: no_height_top
            };
        }
        //创建井

    }, {
        key: "_createWell",
        value: function _createWell(options) {
            var hasTerrain = Boolean(this.viewer.terrainProvider._layers);
            if (hasTerrain) {
                var self = this;
                this._createBottomSurface(options.bottom_pos);
                var promise = Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, options.lerp_pos);
                var maxHeight = -9999;
                Cesium.when(promise, function (updatedPositions) {
                    var len = updatedPositions.length;
                    var top_pos = [];
                    var top_heights = [];
                    for (var k = 0; k < len; k++) {
                        top_heights.push(updatedPositions[k].height);
                        if (updatedPositions[k].height > maxHeight) maxHeight = updatedPositions[k].height;
                        var top_car = Cesium.Cartesian3.fromRadians(updatedPositions[k].longitude, updatedPositions[k].latitude, updatedPositions[k].height);
                        top_pos.push(top_car);
                    }
                    self.maxHeight = maxHeight;
                    self.top_heights = top_heights;
                    self._createWellWall(options.bottom_pos, top_pos);
                    self.viewer.scene.primitives.add(self.wellWall);
                });
            } else {
                this._createBottomSurface(options.bottom_pos);
                this._createWellWall(options.bottom_pos, options.no_height_top);
                this.viewer.scene.primitives.add(this.wellWall);
            }
        }
        //创建井壁

    }, {
        key: "_createWellWall",
        value: function _createWellWall(bottom, top) {
            var geo = new _WellNoBottom.WellNoBottom({
                minimumArr: bottom,
                maximumArr: top
            });
            geo = geo.createGeometry(geo, this);
            var _material = new Cesium.Material({
                fabric: {
                    type: 'Image',
                    uniforms: {
                        image: this.wallImg,
                        color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this.opacityImg)
                    }
                }
            });
            var _appearance = new Cesium.MaterialAppearance({
                translucent: false,
                flat: true,
                material: _material
            });
            this.wellWall = new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                    geometry: geo,
                    attributes: {
                        color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.GREY)
                    },
                    id: 'PitWall'
                }),
                appearance: _appearance,
                asynchronous: false
            });
            this.viewer.scene.primitives.add(this.wellWall);
        }
        //创建井底

    }, {
        key: "_createBottomSurface",
        value: function _createBottomSurface(bottom_pos) {
            if (!bottom_pos.length) {
                return;
            }
            var geo = new _CustomPlaneGeometry.CustomPlaneGeometry({
                pos_arr: bottom_pos
            });
            geo = geo.createGeometry(geo);
            var _material = new Cesium.Material({
                fabric: {
                    type: 'Image',
                    uniforms: {
                        image: this.bottomImg,
                        color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this.opacityImg)
                    }
                }
            });
            var _appearance = new Cesium.MaterialAppearance({
                translucent: false,
                flat: true,
                material: _material
            });
            this.bottomSurface = new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                    geometry: geo
                }),
                appearance: _appearance,
                asynchronous: false
            });
            this.viewer.scene.primitives.add(this.bottomSurface);
        }

        //切换挖掘显隐

    }, {
        key: "_switchExcavate",
        value: function _switchExcavate(val) {
            if (val) {
                if (this.wellWall) this.wellWall.show = true;
                if (this.bottomSurface) this.bottomSurface.show = true;
            } else {
                if (this.wellWall) this.wellWall.show = false;
                if (this.bottomSurface) this.bottomSurface.show = false;
            }
        }

        //更新挖掘深度

    }, {
        key: "_updateExcavateDepth",
        value: function _updateExcavateDepth(depth) {
            if (!this.wellData) return;

            this.bottomSurface && this.viewer.scene.primitives.remove(this.bottomSurface);
            this.wellWall && this.viewer.scene.primitives.remove(this.wellWall);

            var lerp_pos = this.wellData.lerp_pos;
            var bottom_pos = [];
            var len = lerp_pos.length;
            for (var i = 0; i < len; i++) {
                bottom_pos.push(Cesium.Cartesian3.fromRadians(lerp_pos[i].longitude, lerp_pos[i].latitude, this.excavateMinHeight - depth));
            }
            this.wellData.bottom_pos = bottom_pos;
            this._createWell(this.wellData);

            this.viewer.scene.primitives.add(this.bottomSurface);
            this.viewer.scene.primitives.add(this.wellWall);
        }

        //清除裁剪面

    }, {
        key: "clear",
        value: function clear() {
            if (this.viewer.scene.globe.clippingPlanes) {
                this.viewer.scene.globe.clippingPlanes.enabled = false;
                this.viewer.scene.globe.clippingPlanes.removeAll();
                if (!this.viewer.scene.globe.clippingPlanes.isDestroyed()) this.viewer.scene.globe.clippingPlanes.destroy();
            }
            this.viewer.scene.globe.clippingPlanes = undefined;

            if (this.bottomSurface) {
                this.viewer.scene.primitives.remove(this.bottomSurface);
                delete this.bottomSurface;
            }

            if (this.wellWall) {
                this.viewer.scene.primitives.remove(this.wellWall);
                delete this.wellWall;
            }
            delete this.wellData;
            this.viewer.scene.render();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.clear();
            _get(TerrainClipPlan.prototype.__proto__ || Object.getPrototypeOf(TerrainClipPlan.prototype), "destroy", this).call(this);
        }
    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(val) {
            this._show = val;

            if (this.viewer.scene.globe.clippingPlanes) this.viewer.scene.globe.clippingPlanes.enabled = val;

            if (this._showWall) {
                this._switchExcavate(val);
            }
        }

        //裁剪距离 

    }, {
        key: "height",
        get: function get() {
            return this._height;
        },
        set: function set(val) {
            this._height = val;

            if (this._showWall) {
                this._updateExcavateDepth(val);
            }
        }
    }, {
        key: "positions",
        get: function get() {
            return this._positions;
        },
        set: function set(val) {
            this._positions = val;
            this.setPositions(val);
        }
    }]);

    return TerrainClipPlan;
}(_MarsClass2.MarsClass);

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Underground = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//地下模式类
var Underground = exports.Underground = function (_MarsClass) {
    _inherits(Underground, _MarsClass);

    //========== 构造方法 ========== 
    function Underground(options, oldparam) {
        _classCallCheck(this, Underground);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (Underground.__proto__ || Object.getPrototypeOf(Underground)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.viewer = options.viewer;
        _this.depthTestOld = Cesium.clone(_this.viewer.scene.globe.depthTestAgainstTerrain);

        _this.viewer.scene.globe.translucency.frontFaceAlphaByDistance = new Cesium.NearFarScalar(100.0, 0.0, 900.0, 1.0);
        _this.viewer.scene.globe.translucency.backFaceAlpha = 0;

        _this.alpha = Cesium.defaultValue(options.alpha, 0.5);
        _this.enable = Cesium.defaultValue(options.enable, false);
        return _this;
    }

    //========== 对外属性 ==========  
    //显示和隐藏


    _createClass(Underground, [{
        key: "clear",
        value: function clear() {
            this.enable = false;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.clear();
            _get(Underground.prototype.__proto__ || Object.getPrototypeOf(Underground.prototype), "destroy", this).call(this);
        }
    }, {
        key: "alpha",
        get: function get() {
            return this._alpha;
        },
        set: function set(val) {
            this._alpha = Number(val);

            this.viewer.scene.globe.translucency.frontFaceAlphaByDistance.nearValue = this._alpha;
            this.viewer.scene.globe.translucency.frontFaceAlphaByDistance.farValue = this._alpha;
        }
    }, {
        key: "enable",
        get: function get() {
            return this.viewer.scene.globe.translucency.enabled;
        },
        set: function set(value) {
            this.viewer.scene.globe.depthTestAgainstTerrain = value ? true : this.depthTestOld;
            this.viewer.scene.screenSpaceCameraController.enableCollisionDetection = !value; //相机对地形的碰撞检测状态

            this.viewer.scene.globe.translucency.enabled = value;
        }
    }]);

    return Underground;
}(_MarsClass2.MarsClass);

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewShed3D = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _ViewShed3D = __webpack_require__(146);

var _ViewShed3D2 = _interopRequireDefault(_ViewShed3D);

var _RectangularSensorGraphics = __webpack_require__(85);

var _point = __webpack_require__(2);

var _matrix = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//   可视分析 类
var ViewShed3D = exports.ViewShed3D = function (_MarsClass) {
    _inherits(ViewShed3D, _MarsClass);

    //========== 构造方法 ========== 
    function ViewShed3D(options, oldparam) {
        _classCallCheck(this, ViewShed3D);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (ViewShed3D.__proto__ || Object.getPrototypeOf(ViewShed3D)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        if (Cesium.defined(options.debugFrustum)) options.showFrustum = options.debugFrustum;
        _this.debugFrustum = _this.showFrustum;
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.viewer = options.viewer;
        _this.viewer.terrainShadows = Cesium.ShadowMode.ENABLED;

        _this.cameraPosition = options.cameraPosition; //相机位置
        _this.viewPosition = options.viewPosition; //视点位置

        _this._horizontalAngle = Cesium.defaultValue(options.horizontalAngle, 120); //水平张角
        _this._verticalAngle = Cesium.defaultValue(options.verticalAngle, 90); //垂直张角
        _this._visibleAreaColor = Cesium.defaultValue(options.visibleAreaColor, new Cesium.Color(0, 1, 0)); //可视颜色
        _this._hiddenAreaColor = Cesium.defaultValue(options.hiddenAreaColor, new Cesium.Color(1, 0, 0)); //不可视颜色
        _this._alpha = Cesium.defaultValue(options.alpha, 0.5); //混合度
        _this._distance = Cesium.defaultValue(options.distance, 100); //距离  
        _this._maximumDistance = Cesium.defaultValue(options.maximumDistance, 5000.0);
        _this._offsetHeight = Cesium.defaultValue(options.offsetHeight, 1.5);
        _this._debugFrustum = Cesium.defaultValue(options.showFrustum, true); //视椎体显示
        _this._show = Cesium.defaultValue(options.show, true); //可视域显示


        _this._defaultColorTexture = new Cesium.Texture({ //默认材质
            context: _this.viewer.scene.context,
            source: {
                width: 1,
                height: 1,
                arrayBufferView: new Uint8Array([0, 0, 0, 0])
            },
            flipY: false
        });

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码  
        if (options.calback) {
            _this.on(_MarsClass2.eventType.end, function (e) {
                options.calback(e.distance, _this);
            });
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码  


        if (_this.cameraPosition && _this.viewPosition) {
            _this._addToScene();
        } else {
            _this._bindMourseEvent();
        }
        return _this;
    }

    //========== 对外属性 ========== 
    //水平张角


    _createClass(ViewShed3D, [{
        key: "setCursor",


        //========== 方法 ==========  
        value: function setCursor(val) {
            this.viewer._container.style.cursor = val ? 'crosshair' : '';
        }
        //激活绑定事件

    }, {
        key: "_bindMourseEvent",
        value: function _bindMourseEvent() {
            var that = this;
            var viewer = this.viewer;
            var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
            handler.setInputAction(function (movement) {
                var cartesian = (0, _point.getCurrentMousePosition)(viewer.scene, movement.position);
                if (!cartesian) return;

                if (!that.cameraPosition) {
                    //相机位置 
                    cartesian = (0, _point.addPositionsHeight)(cartesian, that._offsetHeight); //加人的身高等因素，略微抬高一些

                    that.cameraPosition = cartesian;
                } else if (that.cameraPosition && !that.viewPosition) {
                    var len = Cesium.Cartesian3.distance(that.cameraPosition, cartesian);
                    if (len > 5000) {
                        cartesian = (0, _matrix.getOnLinePointByLen)(that.cameraPosition, cartesian, 5000);
                    }
                    that.viewPosition = cartesian;

                    that._unbindMourseEvent();
                    that.setCursor(false);
                    that._addToScene();
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

            handler.setInputAction(function (movement) {
                var cartesian = (0, _point.getCurrentMousePosition)(viewer.scene, movement.endPosition);
                if (!cartesian) return;
                var cp = that.cameraPosition;
                if (cp) {
                    var len = Cesium.Cartesian3.distance(cp, cartesian);
                    if (len > 5000) {
                        cartesian = (0, _matrix.getOnLinePointByLen)(cp, cartesian, 5000);
                        that.frustumQuaternion = that.getFrustumQuaternion(cp, cartesian);
                        that.distance = 5000;
                    } else {
                        that.frustumQuaternion = that.getFrustumQuaternion(cp, cartesian);
                        that.distance = Number(len.toFixed(1));
                    }
                }
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            this._handler = handler;

            this.setCursor(true);
        }

        //解绑事件

    }, {
        key: "_unbindMourseEvent",
        value: function _unbindMourseEvent() {
            if (this._handler) {
                this._handler.destroy();
                delete this._handler;
            }
            this.setCursor(false);
        }

        //添加到场景里

    }, {
        key: "_addToScene",
        value: function _addToScene() {
            this.frustumQuaternion = this.getFrustumQuaternion(this.cameraPosition, this.viewPosition);
            this._createShadowMap(this.cameraPosition, this.viewPosition);
            this._addPostProcess();
            if (!this.radar) this.addRadar(this.cameraPosition, this.frustumQuaternion);
            this.viewer.scene.primitives.add(this);

            this.fire(_MarsClass2.eventType.end, {
                distance: this.distance,
                cameraPosition: this.cameraPosition,
                viewPosition: this.viewPosition
            });
        }

        //创建ShadowMap

    }, {
        key: "_createShadowMap",
        value: function _createShadowMap(cpos, viewPosition, fq) {
            var camera_pos = cpos;
            var lookat_pos = viewPosition;
            var scene = this.viewer.scene;
            var camera1 = new Cesium.Camera(scene);
            camera1.position = camera_pos;
            camera1.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
            camera1.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));

            var far = Number(Cesium.Cartesian3.distance(lookat_pos, camera_pos).toFixed(1));
            this.distance = far;

            camera1.frustum = new Cesium.PerspectiveFrustum({
                fov: Cesium.Math.toRadians(120),
                aspectRatio: scene.canvas.clientWidth / scene.canvas.clientHeight,
                near: 0.1,
                far: 5000
            });

            var isSpotLight = true;
            this.viewShadowMap = new Cesium.ShadowMap({
                lightCamera: camera1,
                enable: false,
                isPointLight: !isSpotLight,
                isSpotLight: isSpotLight,
                cascadesEnabled: false,
                context: scene.context,
                pointLightRadius: far,
                maximumDistance: this._maximumDistance
            });
        }

        //获取四元数

    }, {
        key: "getFrustumQuaternion",
        value: function getFrustumQuaternion(cpos, viewPosition) {
            //获取相机四元数，用来调整视椎体摆放
            var direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(viewPosition, cpos, new Cesium.Cartesian3()), new Cesium.Cartesian3());
            var up = Cesium.Cartesian3.normalize(cpos, new Cesium.Cartesian3());
            var camera = new Cesium.Camera(this.viewer.scene);
            camera.position = cpos;
            camera.direction = direction;
            camera.up = up;
            direction = camera.directionWC;
            up = camera.upWC;
            var right = camera.rightWC;
            var scratchRight = new Cesium.Cartesian3();
            var scratchRotation = new Cesium.Matrix3();
            var scratchOrientation = new Cesium.Quaternion();

            // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());
            right = Cesium.Cartesian3.negate(right, scratchRight);
            var rotation = scratchRotation;
            Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
            Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
            Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
            //计算视锥姿态
            var orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
            return orientation;
        }

        //添加后处理

    }, {
        key: "_addPostProcess",
        value: function _addPostProcess() {
            var that = this;
            var bias = that.viewShadowMap._isPointLight ? that.viewShadowMap._pointBias : that.viewShadowMap._primitiveBias;
            this.postProcess = new Cesium.PostProcessStage({
                fragmentShader: _ViewShed3D2.default,
                uniforms: {
                    czzj: function czzj() {
                        return that.verticalAngle;
                    },
                    dis: function dis() {
                        return that.distance;
                    },
                    spzj: function spzj() {
                        return that.horizontalAngle;
                    },
                    visibleColor: function visibleColor() {
                        return that.visibleAreaColor;
                    },
                    disVisibleColor: function disVisibleColor() {
                        return that.hiddenAreaColor;
                    },
                    mixNum: function mixNum() {
                        return that.alpha;
                    },
                    marsShadow: function marsShadow() {
                        return that.viewShadowMap._shadowMapTexture || that._defaultColorTexture;
                    },
                    _shadowMap_matrix: function _shadowMap_matrix() {
                        return that.viewShadowMap._shadowMapMatrix;
                    },
                    shadowMap_lightPositionEC: function shadowMap_lightPositionEC() {
                        return that.viewShadowMap._lightPositionEC;
                    },
                    shadowMap_lightPositionWC: function shadowMap_lightPositionWC() {
                        return that.viewShadowMap._lightCamera.position;
                    },
                    shadowMap_lightDirectionEC: function shadowMap_lightDirectionEC() {
                        return that.viewShadowMap._lightDirectionEC;
                    },
                    shadowMap_lightUp: function shadowMap_lightUp() {
                        return that.viewShadowMap._lightCamera.up;
                    },
                    shadowMap_lightDir: function shadowMap_lightDir() {
                        return that.viewShadowMap._lightCamera.direction;
                    },
                    shadowMap_lightRight: function shadowMap_lightRight() {
                        return that.viewShadowMap._lightCamera.right;
                    },
                    shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function shadowMap_texelSizeDepthBiasAndNormalShadingSmooth() {
                        var texelStepSize = new Cesium.Cartesian2();
                        texelStepSize.x = 1.0 / that.viewShadowMap._textureSize.x;
                        texelStepSize.y = 1.0 / that.viewShadowMap._textureSize.y;
                        return Cesium.Cartesian4.fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);
                    },
                    shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness() {
                        return Cesium.Cartesian4.fromElements(bias.normalOffsetScale, that.viewShadowMap._distance, that.viewShadowMap.maximumDistance, that.viewShadowMap._darkness, this.combinedUniforms2);
                    },
                    depthTexture1: function depthTexture1() {
                        return that.getSceneDepthTexture(that.viewer);
                        // return that._defaultDepth;
                    }
                }
            });
            this.show && this.viewer.scene.postProcessStages.add(this.postProcess);
        }
    }, {
        key: "getSceneDepthTexture",
        value: function getSceneDepthTexture(viewer) {
            var scene = viewer.scene;
            var environmentState = scene._environmentState;
            var view = scene._view;
            var useGlobeDepthFramebuffer = environmentState.useGlobeDepthFramebuffer;
            var globeFramebuffer = useGlobeDepthFramebuffer ? view.globeDepth.framebuffer : undefined;
            var sceneFramebuffer = view.sceneFramebuffer.getFramebuffer();
            var depthTexture = Cesium.defaultValue(globeFramebuffer, sceneFramebuffer).depthStencilTexture; //对的

            // var depthTexture = scene._view.pickDepths[0]._depthTexture;
            // var depthTexture = scene._view.pickDepths[0]._textureToCopy;
            // var depthTexture = scene._view.pickDepths[0]._copyDepthCommand._framebuffer._colorTextures[0];
            // var depthTexture = this.wyypost&&this.wyypost._depthTexture?this.wyypost._depthTexture:scene.context.uniformState.globeDepthTexture;
            // var depthTexture = scene.context.uniformState.globeDepthTexture;//对的
            return depthTexture;
        }

        //添加雷达

    }, {
        key: "addRadar",
        value: function addRadar(cpos, frustumQuaternion) {
            var position = cpos;
            var that = this;
            this.radar = this.viewer.entities.add({
                position: position,
                orientation: frustumQuaternion,
                show: this._debugFrustum && this.show,
                rectangularSensor: new _RectangularSensorGraphics.RectangularSensorGraphics({
                    radius: that.distance, //传感器的半径
                    xHalfAngle: Cesium.Math.toRadians(that.horizontalAngle / 2), //传感器水平半角
                    yHalfAngle: Cesium.Math.toRadians(that.verticalAngle / 2), //传感器垂直半角 
                    material: new Cesium.Color(0.0, 1.0, 1.0, 0.4), //目前用的统一材质
                    lineColor: new Cesium.Color(1.0, 1.0, 1.0, 1.0), //线的颜色
                    slice: 8,
                    showScanPlane: false, //是否显示扫描面 
                    showThroughEllipsoid: false, //此参数控制深度检测，为false启用深度检测，可以解决雷达一半在地球背面时显示的问题
                    showLateralSurfaces: false,
                    showDomeSurfaces: false
                })
            });
        }
        //重置雷达

    }, {
        key: "resetRadar",
        value: function resetRadar() {
            this.removeRadar();
            this.addRadar(this.cameraPosition, this.frustumQuaternion);
        }
        //删除雷达

    }, {
        key: "removeRadar",
        value: function removeRadar() {
            if (this.radar) {
                this.viewer.entities.remove(this.radar);
                delete this.radar;
            }
        }

        //更新

    }, {
        key: "update",
        value: function update(frameState) {
            this.viewShadowMap && frameState.shadowMaps.push(this.viewShadowMap);
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            this.viewer.terrainShadows = Cesium.ShadowMode.DISABLED;
            this._unbindMourseEvent();

            if (this.postProcess) {
                this.viewer.scene.postProcessStages.remove(this.postProcess);
                delete this.postProcess;
            }
            this.removeRadar();

            _get(ViewShed3D.prototype.__proto__ || Object.getPrototypeOf(ViewShed3D.prototype), "destroy", this).call(this);
        }
    }, {
        key: "horizontalAngle",
        get: function get() {
            return this._horizontalAngle;
        },
        set: function set(val) {
            this._horizontalAngle = val;
            this.resetRadar();
        }
        //垂直张角

    }, {
        key: "verticalAngle",
        get: function get() {
            return this._verticalAngle;
        },
        set: function set(val) {
            this._verticalAngle = val;
            this.resetRadar();
        }
        //可视距离

    }, {
        key: "distance",
        get: function get() {
            return this._distance;
        },
        set: function set(val) {
            this._distance = val;
            this.resetRadar();
        }
        //可视区域颜色

    }, {
        key: "visibleAreaColor",
        get: function get() {
            return this._visibleAreaColor;
        },
        set: function set(val) {
            this._visibleAreaColor = val;
        }
        //不可视区域颜色

    }, {
        key: "hiddenAreaColor",
        get: function get() {
            return this._hiddenAreaColor;
        },
        set: function set(val) {
            this._hiddenAreaColor = val;
        }
        //混合系数0-1

    }, {
        key: "alpha",
        get: function get() {
            return this._alpha;
        },
        set: function set(val) {
            this._alpha = val;
        }
        //显示和隐藏

    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(val) {
            this._show = val;
            if (val) {
                if (!this.postProcess) this._addPostProcess();
            } else {
                if (this.postProcess) {
                    this.viewer.scene.postProcessStages.remove(this.postProcess);
                    delete this.postProcess;
                }
            }
            if (this.radar) this.radar.show = this._debugFrustum && this.show;
        }
    }, {
        key: "showFrustum",
        get: function get() {
            return this._debugFrustum;
        },
        set: function set(val) {
            this._debugFrustum = val;
            if (this.radar) this.radar.show = val;
        }
    }]);

    return ViewShed3D;
}(_MarsClass2.MarsClass);

/***/ }),
/* 146 */
/***/ (function(module, exports) {

module.exports = "uniform float czzj;\r\nuniform float dis;\r\nuniform float spzj;\r\nuniform vec3 visibleColor;\r\nuniform vec3 disVisibleColor;\r\nuniform float mixNum;\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D marsShadow; \r\nuniform sampler2D depthTexture;\r\nuniform mat4 _shadowMap_matrix; \r\nuniform vec4 shadowMap_lightPositionEC; \r\nuniform vec3 shadowMap_lightPositionWC;\r\nuniform vec4 shadowMap_lightDirectionEC;\r\nuniform vec3 shadowMap_lightUp;\r\nuniform vec3 shadowMap_lightDir;\r\nuniform vec3 shadowMap_lightRight;\r\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \r\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\r\n    return texture2D(shadowMap, uv).r;\r\n}\r\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\r\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\r\n}\r\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\r\n    float depthBias = shadowParameters.depthBias;\r\n    float depth = shadowParameters.depth;\r\n    float nDotL = shadowParameters.nDotL;\r\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\r\n    float darkness = shadowParameters.darkness;\r\n    vec2 uv = shadowParameters.texCoords;\r\n    depth -= depthBias;\r\n    vec2 texelStepSize = shadowParameters.texelStepSize;\r\n    float radius = 1.0;\r\n    float dx0 = -texelStepSize.x * radius;\r\n    float dy0 = -texelStepSize.y * radius;\r\n    float dx1 = texelStepSize.x * radius;\r\n    float dy1 = texelStepSize.y * radius;\r\n    float visibility = \r\n    (\r\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\r\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\r\n    ) * (1.0 / 9.0)\r\n    ;\r\n    return visibility;\r\n}\r\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\r\n    vec3 v01 = point -planeOrigin;\r\n    float d = dot(planeNormal, v01) ;\r\n    return (point - planeNormal * d);\r\n}\r\nfloat ptm(vec3 pt){\r\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\r\n}\r\nvoid main() \r\n{ \r\n    const float PI = 3.141592653589793;\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n\r\n    // vec4 stcc = texture2D(marsShadow, v_textureCoordinates);\r\n    // gl_FragColor = currD;\r\n    // return;\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n    float depth = getDepth(currD);\r\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\r\n    // return;\r\n    // float depth = czm_unpackDepth(texture2D(depthTexture, v_textureCoordinates));\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 normalEC = vec3(1.0);\r\n    czm_shadowParameters shadowParameters; \r\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \r\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \r\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \r\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \r\n    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \r\n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \r\n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \r\n    vec4 shadowPosition = _shadowMap_matrix * positionEC; \r\n    shadowPosition /= shadowPosition.w; \r\n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \r\n    { \r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    //坐标与视点位置距离，大于最大距离则舍弃阴影效果\r\n    vec4 lw = vec4(shadowMap_lightPositionWC,1.0);\r\n    vec4 vw = czm_inverseView* vec4(positionEC.xyz, 1.0);\r\n    if(distance(lw.xyz,vw.xyz)>dis){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n\r\n    //水平夹角限制\r\n    vec3 ptOnSP = pointProjectOnPlane(shadowMap_lightUp,lw.xyz,vw.xyz);\r\n    directionEC = ptOnSP - lw.xyz;\r\n    float directionECMO = ptm(directionEC.xyz);\r\n    float shadowMap_lightDirMO = ptm(shadowMap_lightDir.xyz);\r\n    float cosJJ = dot(directionEC,shadowMap_lightDir)/(directionECMO*shadowMap_lightDirMO);\r\n    float degJJ = acos(cosJJ)*(180.0 / PI);\r\n    degJJ = abs(degJJ);\r\n    if(degJJ>spzj/2.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    //垂直夹角限制\r\n    vec3 ptOnCZ = pointProjectOnPlane(shadowMap_lightRight,lw.xyz,vw.xyz);\r\n    vec3 dirOnCZ = ptOnCZ - lw.xyz;\r\n    float dirOnCZMO = ptm(dirOnCZ);\r\n    float cosJJCZ = dot(dirOnCZ,shadowMap_lightDir)/(dirOnCZMO*shadowMap_lightDirMO);\r\n    float degJJCZ = acos(cosJJCZ)*(180.0 / PI);\r\n    degJJCZ = abs(degJJCZ);\r\n    if(degJJCZ>czzj/2.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    shadowParameters.texCoords = shadowPosition.xy; \r\n    shadowParameters.depth = shadowPosition.z; \r\n    shadowParameters.nDotL = nDotL; \r\n    float visibility = _czm_shadowVisibility(marsShadow, shadowParameters); \r\n    if(visibility==1.0){\r\n        gl_FragColor = mix(color,vec4(visibleColor,1.0),mixNum);\r\n    }else{\r\n        // if(abs(shadowPosition.z-0.0)<0.01){\r\n        //     return;\r\n        // }\r\n        gl_FragColor = mix(color,vec4(disVisibleColor,1.0),mixNum);\r\n    }\r\n} "

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Sightline = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _point = __webpack_require__(2);

var _polyline = __webpack_require__(22);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//通视分析 类
var Sightline = exports.Sightline = function (_MarsClass) {
    _inherits(Sightline, _MarsClass);

    function Sightline(options, oldparam) {
        _classCallCheck(this, Sightline);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (Sightline.__proto__ || Object.getPrototypeOf(Sightline)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码


        _this.viewer = options.viewer;

        _this.lines = [];
        _this._visibleColor = Cesium.defaultValue(options.visibleColor, new Cesium.Color(0, 1, 0, 1)); //可视区域
        _this._hiddenColor = Cesium.defaultValue(options.hiddenColor, new Cesium.Color(1, 0, 0, 1)); //不可视区域
        _this._depthFailColor = Cesium.defaultValue(options.depthFailColor, new Cesium.Color(1, 0, 0, 0.1));

        if (options.originPoint && options.targetPoint) {
            _this.add(options.originPoint, options.targetPoint);
        }

        return _this;
    }
    //========== 对外属性 ========== 

    //可视区域颜色


    _createClass(Sightline, [{
        key: 'add',


        //========== 方法 ==========  
        value: function add(origin, target, addHeight) {
            if (addHeight) {
                origin = (0, _point.addPositionsHeight)(origin, addHeight); //加人的身高
            }

            var currDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(target, origin, new Cesium.Cartesian3()), new Cesium.Cartesian3());
            var currRay = new Cesium.Ray(origin, currDir);
            var pickRes = this.viewer.scene.drillPickFromRay(currRay, 2, this.lines);

            if (Cesium.defined(pickRes) && pickRes.length > 0 && Cesium.defined(pickRes[0]) && Cesium.defined(pickRes[0].position)) {
                var position = pickRes[0].position;

                var distance = Cesium.Cartesian3.distance(origin, target);
                var distanceFx = Cesium.Cartesian3.distance(origin, position);
                if (distanceFx < distance) {
                    //存在正常分析结果
                    var arrEentity = this._showPolyline(origin, target, position);

                    var result = {
                        block: true, //存在遮挡
                        position: position,
                        entity: arrEentity
                    };
                    this.fire(_MarsClass2.eventType.end, result);
                    return result;
                }
            }

            var arrEentity = this._showPolyline(origin, target);
            var result = {
                block: false,
                entity: arrEentity
            };
            this.fire(_MarsClass2.eventType.end, result);
            return result;
        }
    }, {
        key: '_showPolyline',
        value: function _showPolyline(origin, target, position) {
            if (position) {
                //存在正常分析结果
                var entity1 = this.viewer.entities.add({
                    polyline: {
                        positions: [origin, position],
                        width: 2,
                        material: this._visibleColor,
                        depthFailMaterial: this._depthFailColor
                    }
                });
                this.lines.push(entity1);

                var entity2 = this.viewer.entities.add({
                    polyline: {
                        positions: [position, target],
                        width: 2,
                        material: this._hiddenColor,
                        depthFailMaterial: this._depthFailColor
                    }
                });
                this.lines.push(entity2);

                return [entity1, entity2];
            } else {
                //无正确分析结果时，直接返回
                var entity1 = this.viewer.entities.add({
                    polyline: {
                        positions: [origin, target],
                        width: 2,
                        material: this._visibleColor,
                        depthFailMaterial: this._depthFailColor
                    }
                });
                this.lines.push(entity1);

                return [entity1];
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            for (var i = 0, len = this.lines.length; i < len; i++) {
                this.viewer.entities.remove(this.lines[i]);
            }
            this.lines = [];
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.clear();
            _get(Sightline.prototype.__proto__ || Object.getPrototypeOf(Sightline.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'visibleColor',
        get: function get() {
            return this._visibleColor;
        },
        set: function set(val) {
            this._visibleColor = val;
        }
        //不可视区域颜色

    }, {
        key: 'hiddenColor',
        get: function get() {
            return this._hiddenColor;
        },
        set: function set(val) {
            this._hiddenColor = val;
        }

        //depthFailMaterial颜色，默认为不可视区域颜色

    }, {
        key: 'depthFailColor',
        get: function get() {
            return this._depthFailColor;
        },
        set: function set(val) {
            this._depthFailColor = val;
        }
    }]);

    return Sightline;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


Sightline.event = {
    end: _MarsClass2.eventType.end
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContourLine = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//等高线分析 类
var ContourLine = exports.ContourLine = function (_MarsClass) {
    _inherits(ContourLine, _MarsClass);

    //========== 构造方法 ========== 
    function ContourLine(options, oldparam) {
        _classCallCheck(this, ContourLine);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (ContourLine.__proto__ || Object.getPrototypeOf(ContourLine)).call(this, options));

        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.viewer = options.viewer;

        //地球材质相关 
        _this._contourShow = Cesium.defaultValue(options.show, true); //是否显示等高线
        _this._contourSpacing = Cesium.defaultValue(options.spacing, 100.0);
        _this._contourWidth = Cesium.defaultValue(options.width, 1.5);
        _this._contourColor = Cesium.defaultValue(options.color, Cesium.Color.RED.clone());

        //地表渲染效果类型:无nono, 高程 elevation, 坡度slope, 坡向aspect
        _this._shadingType = Cesium.defaultValue(options.shadingType, "none");
        _this.elevationRamp = [0.0, 0.045, 0.1, 0.15, 0.37, 0.54, 1.0];
        _this.slopeRamp = [0.0, 0.29, 0.5, Math.sqrt(2) / 2, 0.87, 0.91, 1.0];
        _this.aspectRamp = [0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0];
        _this.minHeight = -414.0; // approximate dead sea elevation
        _this.maxHeight = 8777.0; // approximate everest elevation


        //裁剪区域相关
        _this.floodVar = Cesium.defaultValue(options.floodVar, [0, 0, 0, 500]); //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
        _this.ym_pos_x = Cesium.defaultValue(options.ym_pos_x, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _this.ym_pos_y = Cesium.defaultValue(options.ym_pos_y, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _this.ym_pos_z = Cesium.defaultValue(options.ym_pos_z, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
        _this.rect_flood = Cesium.defaultValue(options.rect_flood, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]); //包围盒[minx,miny,minz,maxx,maxy,maxz,0.0,0.0,0.0] 
        _this._boundingSwell = Cesium.defaultValue(options.boundingSwell, 20); //点集合的包围盒膨胀数值
        _this._show = Cesium.defaultValue(options.show, true);

        if (options.positions && options.positions.length > 0) _this.setPositions(options.positions);
        return _this;
    }

    //========== 对外属性 ==========  
    //分析参数


    _createClass(ContourLine, [{
        key: "setPositions",

        //========== 方法 ========== 

        //初始化没传顶点，后面设置顶点
        value: function setPositions(positions) {
            this._positions = positions;

            if (!positions || positions.length == 0) return;

            this._prepareFlood(positions);
            this._setFloodVar();
            this._startFlood();

            this.updateMaterial();
        }

        //与处理顶点数组

    }, {
        key: "_prepareFlood",
        value: function _prepareFlood(arr) {
            this.ym_pos_arr = arr;
            var len = arr.length;
            if (len == 0) return;

            this.ym_max_index = len;
            var minX = arr[0].x;
            var minY = arr[0].y;
            var minZ = arr[0].z;
            var maxX = arr[0].x;
            var maxY = arr[0].y;
            var maxZ = arr[0].z;
            for (var i = 0; i < len; i++) {
                if (arr[i]) {
                    this.ym_pos_x[i] = arr[i].x;
                    this.ym_pos_y[i] = arr[i].y;
                    this.ym_pos_z[i] = arr[i].z;

                    if (arr[i].x > maxX) {
                        maxX = arr[i].x;
                    }
                    if (arr[i].x < minX) {
                        minX = arr[i].x;
                    }

                    if (arr[i].y > maxY) {
                        maxY = arr[i].y;
                    }
                    if (arr[i].y < minY) {
                        minY = arr[i].y;
                    }

                    if (arr[i].z > maxZ) {
                        maxZ = arr[i].z;
                    }
                    if (arr[i].z < minZ) {
                        minZ = arr[i].z;
                    }
                } else {
                    this.ym_pos_x[i] = 0.0;
                    this.ym_pos_y[i] = 0.0;
                    this.ym_pos_z[i] = 0.0;
                }
            }
            var chaNum = this._boundingSwell;
            this._base_rect = this.rect_flood = [minX - chaNum, minY - chaNum, minZ - chaNum, maxX + chaNum, maxY + chaNum, maxZ + chaNum, 0.0, 0.0, 0.0];
        }
        //设置高度

    }, {
        key: "_setFloodVar",
        value: function _setFloodVar() {
            this.floodVar = [this.minHeight, this.minHeight, this.maxHeight, this.maxHeight - this.minHeight];
        }
        //开始

    }, {
        key: "_startFlood",
        value: function _startFlood() {
            this.globeAnalysis.floodVar[0] = this.floodVar[0];
            this.globeAnalysis.floodVar[1] = this.floodVar[1];
            this.globeAnalysis.ym_pos_x = this.ym_pos_x;
            this.globeAnalysis.ym_pos_y = this.ym_pos_y;
            this.globeAnalysis.ym_pos_z = this.ym_pos_z;
            this.globeAnalysis.rect_flood = this.rect_flood;
            this.globeAnalysis.ym_pos_arr = this.ym_pos_arr;
            this.globeAnalysis.ym_max_index = this.ym_max_index;
            this.globeAnalysis.globe = false;
            this.globeAnalysis.showElseArea = true;
            this.viewer.scene.globe.material = Cesium.Material.fromType('ElevationContour');
        }

        //===================

    }, {
        key: "updateMaterial",
        value: function updateMaterial() {
            if (!this.positions || this.positions.length == 0) return;

            var material;
            var contourUniforms;
            var shadingUniforms;

            var _shadingType = this._shadingType;
            if (this._contourShow) {
                if (_shadingType === "elevation") {
                    material = this.getElevationContourMaterial();
                    shadingUniforms = material.materials.elevationRampMaterial.uniforms;
                    shadingUniforms.minimumHeight = this.minHeight;
                    shadingUniforms.maximumHeight = this.maxHeight;
                    contourUniforms = material.materials.contourMaterial.uniforms;
                } else if (_shadingType === "slope") {
                    material = this.getSlopeContourMaterial();
                    shadingUniforms = material.materials.slopeRampMaterial.uniforms;
                    contourUniforms = material.materials.contourMaterial.uniforms;
                } else if (_shadingType === "aspect") {
                    material = this.getAspectContourMaterial();
                    shadingUniforms = material.materials.aspectRampMaterial.uniforms;
                    contourUniforms = material.materials.contourMaterial.uniforms;
                } else {
                    material = Cesium.Material.fromType("ElevationContour");
                    contourUniforms = material.uniforms;
                }
                contourUniforms.width = this._contourWidth;
                contourUniforms.spacing = this._contourSpacing;
                contourUniforms.color = this._contourColor;
            } else if (_shadingType === "elevation") {
                material = Cesium.Material.fromType("ElevationRamp");
                shadingUniforms = material.uniforms;
                shadingUniforms.minimumHeight = this.minHeight;
                shadingUniforms.maximumHeight = this.maxHeight;
            } else if (_shadingType === "slope") {
                material = Cesium.Material.fromType("SlopeRamp");
                shadingUniforms = material.uniforms;
            } else if (_shadingType === "aspect") {
                material = Cesium.Material.fromType("AspectRamp");
                shadingUniforms = material.uniforms;
            }
            if (_shadingType !== "none") {
                shadingUniforms.image = this.getColorRamp(_shadingType);

                if (!this.viewer.scene.globe.enableLighting) {
                    this.viewer.scene.globe.enableLighting = true;
                    var now = new Date();
                    now.setHours(10);
                    this.viewer.clock.currentTime = Cesium.JulianDate.fromDate(new Date(now));
                    this.hasResetEnableLighting = true;
                }
            }
            this.contourUniforms = contourUniforms;
            this.viewer.scene.globe.material = material;
        }
    }, {
        key: "getColorRamp",
        value: function getColorRamp(_shadingType) {
            var ramp = document.createElement("canvas");
            ramp.width = 100;
            ramp.height = 1;
            var ctx = ramp.getContext("2d");

            var values;
            if (_shadingType === "elevation") {
                values = this.elevationRamp;
            } else if (_shadingType === "slope") {
                values = this.slopeRamp;
            } else if (_shadingType === "aspect") {
                values = this.aspectRamp;
            }

            var grd = ctx.createLinearGradient(0, 0, 100, 0);
            grd.addColorStop(values[0], "#000000"); //black
            grd.addColorStop(values[1], "#2747E0"); //blue
            grd.addColorStop(values[2], "#D33B7D"); //pink
            grd.addColorStop(values[3], "#D33038"); //red
            grd.addColorStop(values[4], "#FF9742"); //orange
            grd.addColorStop(values[5], "#ffd700"); //yellow
            grd.addColorStop(values[6], "#ffffff"); //white

            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 100, 1);

            return ramp;
        }
    }, {
        key: "getElevationContourMaterial",
        value: function getElevationContourMaterial() {
            // Creates a composite material with both elevation shading and contour lines
            return new Cesium.Material({
                fabric: {
                    type: "ElevationColorContour",
                    materials: {
                        contourMaterial: {
                            type: "ElevationContour"
                        },
                        elevationRampMaterial: {
                            type: "ElevationRamp"
                        }
                    },
                    components: {
                        diffuse: "contourMaterial.alpha == 0.0 ? elevationRampMaterial.diffuse : contourMaterial.diffuse",
                        alpha: "max(contourMaterial.alpha, elevationRampMaterial.alpha)"
                    }
                },
                translucent: false
            });
        }
    }, {
        key: "getSlopeContourMaterial",
        value: function getSlopeContourMaterial() {
            // Creates a composite material with both slope shading and contour lines
            return new Cesium.Material({
                fabric: {
                    type: "SlopeColorContour",
                    materials: {
                        contourMaterial: {
                            type: "ElevationContour"
                        },
                        slopeRampMaterial: {
                            type: "SlopeRamp"
                        }
                    },
                    components: {
                        diffuse: "contourMaterial.alpha == 0.0 ? slopeRampMaterial.diffuse : contourMaterial.diffuse",
                        alpha: "max(contourMaterial.alpha, slopeRampMaterial.alpha)"
                    }
                },
                translucent: false
            });
        }
    }, {
        key: "getAspectContourMaterial",
        value: function getAspectContourMaterial() {
            // Creates a composite material with both aspect shading and contour lines
            return new Cesium.Material({
                fabric: {
                    type: "AspectColorContour",
                    materials: {
                        contourMaterial: {
                            type: "ElevationContour"
                        },
                        aspectRampMaterial: {
                            type: "AspectRamp"
                        }
                    },
                    components: {
                        diffuse: "contourMaterial.alpha == 0.0 ? aspectRampMaterial.diffuse : contourMaterial.diffuse",
                        alpha: "max(contourMaterial.alpha, aspectRampMaterial.alpha)"
                    }
                },
                translucent: false
            });
        }
    }, {
        key: "clear",
        value: function clear() {
            this.positions = null;
            this.contourUniforms = null;
            this.viewer.scene.globe.material = null;
            this.viewer.scene.globe._surface.tileProvider.resetFloodAnalysis();

            if (this.hasResetEnableLighting) {
                this.viewer.scene.globe.enableLighting = false;
                this.viewer.clock.currentTime = Cesium.JulianDate.fromDate(new Date());
                delete this.hasResetEnableLighting;
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.clear();
            _get(ContourLine.prototype.__proto__ || Object.getPrototypeOf(ContourLine.prototype), "destroy", this).call(this);
        }
    }, {
        key: "globeAnalysis",
        get: function get() {
            return this.viewer.scene.globe._surface.tileProvider.floodAnalysis;
        }
    }, {
        key: "positions",
        get: function get() {
            return this._positions;
        },
        set: function set(val) {
            this._positions = val;
            this.setPositions(val);
        }

        //地表渲染效果类型:无nono, 高程 elevation, 坡度slope, 坡向aspect

    }, {
        key: "shadingType",
        get: function get() {
            return this._shadingType;
        },
        set: function set(val) {
            this._shadingType = val;
            this.updateMaterial();
        }

        //是否显示等高线  

    }, {
        key: "show",
        get: function get() {
            return this._contourShow;
        },
        set: function set(val) {
            this._contourShow = val;
            this.updateMaterial();
        }

        //等高线 线宽

    }, {
        key: "width",
        get: function get() {
            return this._contourWidth;
        },
        set: function set(val) {
            this._contourWidth = val;
            if (this.contourUniforms) this.contourUniforms.width = val;
        }
        //等高线 间隔

    }, {
        key: "spacing",
        get: function get() {
            return this._contourSpacing;
        },
        set: function set(val) {
            this._contourSpacing = val;
            if (this.contourUniforms) this.contourUniforms.spacing = val;
        }
        //等高线 颜色

    }, {
        key: "color",
        get: function get() {
            return this._contourColor;
        },
        set: function set(val) {
            this._contourColor = val;
            if (this.contourUniforms) this.contourUniforms.color = val;
        }
    }]);

    return ContourLine;
}(_MarsClass2.MarsClass);

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MixedOcclusion = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MixedOcclusion = __webpack_require__(150);

var _MixedOcclusion2 = _interopRequireDefault(_MixedOcclusion);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 建筑物混合遮挡 
// 原理：自己创建FBO，把收集到的所有瓦片绘制指令，都绘制到这个FBO里，开启深度检测，然后再贴屏
// 1.楼块不能遮挡道路、水系、绿地和标注等地图元素；
// 2.楼快之间，需要实现不透明的实际遮挡效果。
var MixedOcclusion = exports.MixedOcclusion = function () {
    //========== 构造方法 ==========     
    function MixedOcclusion(options, oldparam) {
        _classCallCheck(this, MixedOcclusion);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        if (oldparam) {
            oldparam.viewer = options;
            options = oldparam;
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        this.viewer = options.viewer;

        this._enabled = Cesium.defaultValue(options.enabled, true);
        this._alpha = Cesium.defaultValue(options.alpha, 0.5);

        this.init();
    }

    //========== 对外属性 ==========  
    //透明度


    _createClass(MixedOcclusion, [{
        key: "init",


        //========== 方法 ========== 

        value: function init() {
            var context = this.viewer.scene.context;
            var width = this.viewer.scene.drawingBufferWidth;
            var height = this.viewer.scene.drawingBufferHeight;

            this.width = width;
            this.height = height;

            this.colorTexture = new Cesium.Texture({
                context: context,
                width: width,
                height: height,
                pixelFormat: Cesium.PixelFormat.RGBA,
                pixelDatatype: Cesium.PixelDatatype.FLOAT,
                sampler: new Cesium.Sampler({
                    wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                    wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
                    minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                    magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
                })
            });

            this.depthStencilTexture = new Cesium.Texture({
                context: context,
                width: width,
                height: height,
                pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
                pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
            });

            Cesium.ExpandByMars.mixedOcclusion.tilesFbo = new Cesium.Framebuffer({
                context: context,
                colorTextures: [this.colorTexture],
                depthStencilTexture: this.depthStencilTexture,
                destroyAttachments: false
            });

            Cesium.ExpandByMars.mixedOcclusion.tilesFboClear = new Cesium.ClearCommand({
                color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
                framebuffer: Cesium.ExpandByMars.mixedOcclusion.tilesFbo,
                depth: 2.0,
                stencil: 2.0
            });

            this.viewer.scene._preUpdate.addEventListener(this._preUpdateHandler, this);
            this.setEnabled(this._enabled);
        }
    }, {
        key: "_preUpdateHandler",
        value: function _preUpdateHandler(e) {
            Cesium.ExpandByMars.mixedOcclusion.newFrame = true;

            var newWidth = this.viewer.scene.drawingBufferWidth;
            var newHeight = this.viewer.scene.drawingBufferHeight;
            if (newWidth != this.width || newHeight != this.height) {
                var context = this.viewer.scene.context;
                var width = newWidth;
                var height = newHeight;

                this.width = width;
                this.height = height;

                this.depthTexture && this.depthTexture.destroy();
                this.depthStencilTexture && this.depthStencilTexture.destroy();
                this.colorTexture && this.colorTexture.destroy();
                Cesium.ExpandByMars.mixedOcclusion.tilesFbo && Cesium.ExpandByMars.mixedOcclusion.tilesFbo.destroy();

                this.colorTexture = new Cesium.Texture({
                    context: context,
                    width: width,
                    height: height,
                    pixelFormat: Cesium.PixelFormat.RGBA,
                    pixelDatatype: Cesium.PixelDatatype.FLOAT,
                    sampler: new Cesium.Sampler({
                        wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                        wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
                        minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                        magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
                    })
                });

                this.depthStencilTexture = new Cesium.Texture({
                    context: context,
                    width: width,
                    height: height,
                    pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
                    pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
                });

                this.depthTexture = new Cesium.Texture({
                    context: context,
                    width: width,
                    height: height,
                    pixelFormat: Cesium.PixelFormat.RGBA,
                    pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
                    sampler: new Cesium.Sampler({
                        wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                        wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
                        minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                        magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
                    })
                });

                Cesium.ExpandByMars.mixedOcclusion.tilesFbo = new Cesium.Framebuffer({
                    context: context,
                    colorTextures: [this.colorTexture],
                    depthStencilTexture: this.depthStencilTexture,
                    destroyAttachments: false
                });
                Cesium.ExpandByMars.mixedOcclusion.tilesFboClear = new Cesium.ClearCommand({
                    color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
                    framebuffer: Cesium.ExpandByMars.mixedOcclusion.tilesFbo,
                    depth: 2.0,
                    stencil: 2.0
                });
            }
        }
    }, {
        key: "setEnabled",
        value: function setEnabled(val) {
            var that = this;

            Cesium.ExpandByMars.mixedOcclusion.enable = val;

            if (val) {
                this.postProcess = new Cesium.PostProcessStage({
                    fragmentShader: _MixedOcclusion2.default,
                    uniforms: {
                        mergeTexture: function mergeTexture() {
                            return Cesium.ExpandByMars.mixedOcclusion.tilesFbo._colorTextures[0];
                        },
                        alpha: function alpha() {
                            return that._alpha;
                        }
                    }
                });
                this.viewer.scene.postProcessStages.add(this.postProcess);
            } else {
                Cesium.ExpandByMars.mixedOcclusion.tilesFboClear.execute(this.viewer.scene.context);
                if (this.postProcess) this.viewer.scene.postProcessStages.remove(this.postProcess);
            }
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            this.setEnabled(false);
            this.viewer.scene._preUpdate.removeEventListener(this._preUpdateHandler, this);

            if (this.depthTexture) {
                this.depthTexture.destroy();
                delete this.depthTexture;
            }
            if (this.depthStencilTexture) {
                this.depthStencilTexture.destroy();
                delete this.depthStencilTexture;
            }
            if (this.colorTexture) {
                this.colorTexture.destroy();
                delete this.colorTexture;
            }

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "alpha",
        get: function get() {
            return this._alpha;
        },
        set: function set(val) {
            this._alpha = val;
        }

        //开启关闭

    }, {
        key: "enabled",
        get: function get() {
            return this._enabled;
        },
        set: function set(val) {
            this._enabled = val;
            this.setEnabled(val);
        }
    }]);

    return MixedOcclusion;
}();

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D colorTexture;\nuniform sampler2D mergeTexture; \nuniform float alpha;\nvarying vec2 v_textureCoordinates;\nvoid main(){\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 mergeColor =  texture2D(mergeTexture, v_textureCoordinates);\n    if(length(mergeColor.rgb)>0.01){\n        gl_FragColor = mix(color,mergeColor,alpha);\n    }else{\n        gl_FragColor = color;\n    }\n} "

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TilesEditor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//  移动位置、旋转 3dtiles
var TilesEditor = exports.TilesEditor = function (_MarsClass) {
    _inherits(TilesEditor, _MarsClass);

    //========== 构造方法 ========== 
    function TilesEditor(options) {
        _classCallCheck(this, TilesEditor);

        var _this = _possibleConstructorReturn(this, (TilesEditor.__proto__ || Object.getPrototypeOf(TilesEditor)).call(this, options));

        _this.options = options;

        _this.viewer = options.viewer;
        _this.scene = _this.viewer.scene;
        _this.position = options.position;

        _this.rotation_x = options.rotation_x || 0;
        _this.rotation_y = options.rotation_y || 0;
        _this.rotation_z = options.rotation_z || options.heading || 0;
        _this.range = options.range || 100;

        _this.dragging = false;
        _this.rotating = false;
        _this._enable = false;

        _this.billboards = _this.viewer.scene.primitives.add(new Cesium.BillboardCollection());
        _this.handler = new Cesium.ScreenSpaceEventHandler(_this.viewer.canvas);

        //用来平移位置的指示器
        _this.movep = _this.billboards.add({
            position: _this.position,
            color: Cesium.Color.fromCssColorString("#FFFF00"),
            image: options.moveImg,
            show: false,
            disableDepthTestDistance: Number.POSITIVE_INFINITY
        });
        //用来旋转的指示器
        _this.rotatep = _this.billboards.add({
            position: _this.position ? _this.rotationPos() : null,
            color: Cesium.Color.fromCssColorString("#FFFF00"),
            image: options.rotateImg,
            show: false,
            disableDepthTestDistance: Number.POSITIVE_INFINITY
        });

        return _this;
    }

    //========== 对外属性 ==========  
    //启用状态


    _createClass(TilesEditor, [{
        key: "update",


        //========== 方法 ========== 

        value: function update(opts) {
            for (var key in opts) {
                this[key] = opts[key];
            }

            this.movep.position = this.position;
            this.rotatep.position = this.rotationPos();
        }

        //获取当前矩阵

    }, {
        key: "modelMatrix",
        value: function modelMatrix(position) {
            var mat = Cesium.Transforms.eastNorthUpToFixedFrame(position || this.position);

            //旋转 
            var mx = Cesium.Matrix3.fromRotationX(this.rotation_x || 0);
            var my = Cesium.Matrix3.fromRotationY(this.rotation_y || 0);
            var mz = Cesium.Matrix3.fromRotationZ(this.rotation_z || this.heading || 0);
            var rotationX = Cesium.Matrix4.fromRotationTranslation(mx);
            var rotationY = Cesium.Matrix4.fromRotationTranslation(my);
            var rotationZ = Cesium.Matrix4.fromRotationTranslation(mz);

            //旋转、平移矩阵相乘
            Cesium.Matrix4.multiply(mat, rotationX, mat);
            Cesium.Matrix4.multiply(mat, rotationY, mat);
            Cesium.Matrix4.multiply(mat, rotationZ, mat);

            //比例变换
            if (this.scale > 0 && this.scale != 1) Cesium.Matrix4.multiplyByUniformScale(mat, this.scale, mat);

            //垂直轴变换
            if (this.axis && this.axis != "") {
                var rightaxis;
                switch (this.axis.toUpperCase()) {
                    case "Y_UP_TO_Z_UP":
                        rightaxis = Cesium.Axis.Y_UP_TO_Z_UP;
                        break;
                    case "Z_UP_TO_Y_UP":
                        rightaxis = Cesium.Axis.Z_UP_TO_Y_UP;
                        break;
                    case "X_UP_TO_Z_UP":
                        rightaxis = Cesium.Axis.X_UP_TO_Z_UP;
                        break;
                    case "Z_UP_TO_X_UP":
                        rightaxis = Cesium.Axis.Z_UP_TO_X_UP;
                        break;
                    case "X_UP_TO_Y_UP":
                        rightaxis = Cesium.Axis.X_UP_TO_Y_UP;
                        break;
                    case "Y_UP_TO_X_UP":
                        rightaxis = Cesium.Axis.Y_UP_TO_X_UP;
                        break;
                }
                if (rightaxis) mat = Cesium.Matrix4.multiplyTransformation(mat, rightaxis, mat);
            }
            return mat;
        }

        //依据位置和朝向计算 旋转的位置

    }, {
        key: "rotationPos",
        value: function rotationPos() {
            var rotpos = new Cesium.Cartesian3(this.range, 0.0, 0.0);
            //依据位置和朝向计算 旋转矩阵  
            var mat = Cesium.Matrix4.getMatrix3(this.modelMatrix(), new Cesium.Matrix3());

            rotpos = Cesium.Matrix3.multiplyByVector(mat, rotpos, rotpos);
            rotpos = Cesium.Cartesian3.add(this.position, rotpos, rotpos);
            return rotpos;
        }
    }, {
        key: "pickTerrain",
        value: function pickTerrain(wndpos) {
            var ray = this.viewer.camera.getPickRay(wndpos);
            var pos = this.viewer.scene.globe.pick(ray, this.viewer.scene);
            return pos;
        }
    }, {
        key: "handler_onLeafDown",
        value: function handler_onLeafDown(event) {
            var pickedObjects = this.scene.drillPick(event.position, 2);

            for (var i = 0; i < pickedObjects.length; i++) {
                var pickedObject = pickedObjects[i];

                if (Cesium.defined(pickedObject) && pickedObject.primitive === this.movep) {
                    this.dragging = true;
                    this.scene.screenSpaceCameraController.enableRotate = false;
                    break;
                } else if (Cesium.defined(pickedObject) && pickedObject.primitive === this.rotatep) {
                    this.rotating = true;
                    this.scene.screenSpaceCameraController.enableRotate = false;
                    break;
                }
            }
        }
    }, {
        key: "handler_onMouseMove",
        value: function handler_onMouseMove(event) {
            var position = this.pickTerrain(event.endPosition);
            if (!position) return;

            if (this.dragging) {
                this.position = position;
                this.movep.position = this.position;
                this.rotatep.position = this.rotationPos();

                this.fire(_MarsClass2.eventType.change, {
                    position: this.position
                });
            } else if (this.rotating) {
                this.rotatep.position = position;
                this.range = Cesium.Cartesian3.distance(this.position, position);

                //获取该位置的默认矩阵 
                var mat = Cesium.Transforms.eastNorthUpToFixedFrame(this.position);
                mat = Cesium.Matrix4.getMatrix3(mat, new Cesium.Matrix3());

                var xaxis = Cesium.Matrix3.getColumn(mat, 0, new Cesium.Cartesian3());
                var yaxis = Cesium.Matrix3.getColumn(mat, 1, new Cesium.Cartesian3());
                var zaxis = Cesium.Matrix3.getColumn(mat, 2, new Cesium.Cartesian3());
                //计算该位置 和  position 的 角度值
                var dir = Cesium.Cartesian3.subtract(position, this.position, new Cesium.Cartesian3());
                //z crosss (dirx cross z) 得到在 xy平面的向量
                dir = Cesium.Cartesian3.cross(dir, zaxis, dir);
                dir = Cesium.Cartesian3.cross(zaxis, dir, dir);
                dir = Cesium.Cartesian3.normalize(dir, dir);

                this.rotation_z = Cesium.Cartesian3.angleBetween(xaxis, dir);
                var ay = Cesium.Cartesian3.angleBetween(yaxis, dir);
                if (ay > Math.PI * 0.5) {
                    this.rotation_z = 2 * Math.PI - this.rotation_z;
                }

                this.fire(_MarsClass2.eventType.change, {
                    rotation_z: this.rotation_z
                });
            }
        }
    }, {
        key: "handler_onLeftUp",
        value: function handler_onLeftUp(event) {
            if (this.dragging || this.rotating) {
                this.rotating = this.dragging = false;
                this.scene.screenSpaceCameraController.enableRotate = true;
                //如果没有这句话 会导致billboards的某些没有刷新，无法再次点击
                this.billboards._createVertexArray = true;
            }
        }
    }, {
        key: "remove",
        value: function remove() {
            //从场景中移除
            if (this.billboards) {
                this.scene.primitives.remove(this.billboards);
                this.billboards = undefined;
            }
            this.enable = false;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.remove();
            this.handler.destroy();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable = val;
            if (val) {
                var self = this;
                this.handler.setInputAction(function (p) {
                    self.handler_onLeafDown(p);
                }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
                this.handler.setInputAction(function (p) {
                    self.handler_onMouseMove(p);
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                this.handler.setInputAction(function (p) {
                    self.handler_onLeftUp(p);
                }, Cesium.ScreenSpaceEventType.LEFT_UP);

                this.rotatep.show = true;
                this.movep.show = true;
            } else {
                this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
                this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);

                this.rotatep.show = false;
                this.movep.show = false;
            }
        }
    }, {
        key: "matrix",
        get: function get() {
            return this.modelMatrix();
        }
    }]);

    return TilesEditor;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


TilesEditor.event = {
    change: _MarsClass2.eventType.change
};

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TilesClip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TilesBase2 = __webpack_require__(46);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 模型裁剪 类
var TilesClip = exports.TilesClip = function (_TilesBase) {
    _inherits(TilesClip, _TilesBase);

    //========== 构造方法 ========== 
    function TilesClip(options) {
        _classCallCheck(this, TilesClip);

        var _this = _possibleConstructorReturn(this, (TilesClip.__proto__ || Object.getPrototypeOf(TilesClip)).call(this, options));

        _this._clipOutSide = Cesium.defaultValue(options.clipOutSide, false);

        if (_this.drawCommand) {
            _this.activeEdit();
        }
        return _this;
    }

    //========== 对外属性 ==========  

    _createClass(TilesClip, [{
        key: "activeEdit",
        value: function activeEdit() {
            this.tileset.marsEditor.fbo = this.fbo;
            this.tileset.marsEditor.polygonBounds = this.polygonBounds;
            this.tileset.marsEditor.IsYaPing[0] = true;
            this.tileset.marsEditor.IsYaPing[2] = true;
            this.tileset.marsEditor.editVar[0] = this.clipOutSide;
            this.addToScene();
        }
    }, {
        key: "clipOutSide",
        get: function get() {
            return this._clipOutSide;
        },
        set: function set(val) {
            this._clipOutSide = Boolean(val);
            this.tileset.marsEditor.editVar[0] = this.clipOutSide;
        }
    }]);

    return TilesClip;
}(_TilesBase2.TilesBase);

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = "uniform mat4 myPorjection;\r\nattribute vec3 position;\r\nvarying vec2 depth;\r\nvoid main()\r\n{\r\nvec4 pos = vec4(position.xyz,1.0);\r\ndepth = pos.zw;\r\npos.z = 0.0;\r\ngl_Position = czm_projection*pos;\r\n}"

/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n    precision highp float;\r\n#else\r\n    precision mediump float;\r\n#endif\r\n\r\n#define OES_texture_float_linear\r\n\r\nvarying vec2 depth;\r\n\r\nvec4 packDepth(float depth)\r\n{\r\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\r\n    enc = fract(enc);\r\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    return enc;\r\n}\r\n\r\nvoid main()\r\n{\r\n    float fDepth = (depth.x / 5000.0)/2.0 + 0.5;\r\n    gl_FragColor = packDepth(fDepth);\r\n}"

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TilesFlat = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TilesBase2 = __webpack_require__(46);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//默认压平至所选取的最低点高度，由flatHeight变量控制压平高度的变化
// 模型压平 类
var TilesFlat = exports.TilesFlat = function (_TilesBase) {
    _inherits(TilesFlat, _TilesBase);

    //========== 构造方法 ========== 
    function TilesFlat(options) {
        _classCallCheck(this, TilesFlat);

        var _this = _possibleConstructorReturn(this, (TilesFlat.__proto__ || Object.getPrototypeOf(TilesFlat)).call(this, options));

        _this._b3dmOffset = options.b3dmOffset || new Cesium.Cartesian2();
        _this._flatHeight = options.flatHeight || 0;

        if (_this.drawCommand) {
            _this.activeEdit();
        }
        return _this;
    }

    //========== 对外属性 ==========  

    //偏移量


    _createClass(TilesFlat, [{
        key: "activeEdit",
        value: function activeEdit() {
            this.tileset.marsEditor.fbo = this.fbo;
            this.tileset.marsEditor.polygonBounds = this.polygonBounds;
            this.tileset.marsEditor.IsYaPing[0] = true;
            this.tileset.marsEditor.IsYaPing[1] = true;
            this.tileset.marsEditor.heightVar[0] = this.minLocalPos.z;
            this.tileset.marsEditor.heightVar[1] = this.flatHeight;
            this.addToScene();
        }
    }, {
        key: "flatHeight",
        get: function get() {
            return this._flatHeight;
        },
        set: function set(val) {
            this._flatHeight = Number(val);
            this.tileset.marsEditor.heightVar[1] = this._flatHeight;
        }
    }]);

    return TilesFlat;
}(_TilesBase2.TilesBase);

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TilesFlood = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TilesBase2 = __webpack_require__(46);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 模型淹没 类
var TilesFlood = exports.TilesFlood = function (_TilesBase) {
    _inherits(TilesFlood, _TilesBase);

    //========== 构造方法 ========== 
    function TilesFlood(options) {
        _classCallCheck(this, TilesFlood);

        var _this = _possibleConstructorReturn(this, (TilesFlood.__proto__ || Object.getPrototypeOf(TilesFlood)).call(this, options));

        _this.floodColor = options.floodColor || [0.15, 0.7, 0.95, 0.5];
        _this.floodSpeed = options.floodSpeed || 5.5; //淹没速度，米/秒（默认刷新频率为55Hz）
        _this._floodAll = options.floodAll;
        _this.maxFloodDepth = options.maxFloodDepth || 200;
        _this.ableFlood = true;
        if (_this.drawCommand || _this._floodAll) {
            _this.activeEdit();
        }
        return _this;
    }

    //========== 对外属性 ==========  

    _createClass(TilesFlood, [{
        key: "bindSpeed",
        value: function bindSpeed() {
            var that = this;
            this.speedFun = function () {
                if (that.ableFlood) {
                    that.tileset.marsEditor.floodVar[1] += that.floodSpeed / 55;
                    if (that.tileset.marsEditor.floodVar[1] >= that.tileset.marsEditor.floodVar[2]) {
                        that.tileset.marsEditor.floodVar[1] = that.tileset.marsEditor.floodVar[2];
                    }
                }
            };
            this.viewer.clock.onTick.addEventListener(this.speedFun);
        }
    }, {
        key: "resetFlood",
        value: function resetFlood() {
            this.tileset.marsEditor.floodVar[1] = this.tileset.marsEditor.floodVar[0];
        }
    }, {
        key: "activeEdit",
        value: function activeEdit() {
            this.bindSpeed();
            this.tileset.marsEditor.fbo = this.fbo;
            this.tileset.marsEditor.polygonBounds = this.polygonBounds;
            this.tileset.marsEditor.IsYaPing[0] = true;
            this.tileset.marsEditor.IsYaPing[3] = true;
            this.tileset.marsEditor.floodVar = [this.minLocalPos.z, this.minLocalPos.z, this.minLocalPos.z + this.maxFloodDepth, 200];
            this.tileset.marsEditor.floodColor = this.floodColor;
            this.tileset.marsEditor.editVar[1] = this.floodAll || false;
            !this.floodAll && this.addToScene();
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            this.viewer.clock.onTick.removeEventListener(this.speedFun);
            _get(TilesFlood.prototype.__proto__ || Object.getPrototypeOf(TilesFlood.prototype), "destroy", this).call(this);
        }
    }, {
        key: "floodAll",
        get: function get() {
            return this._floodAll;
        },
        set: function set(val) {
            this._floodAll = Boolean(val);
            this.tileset.marsEditor.editVar[1] = this.floodAll;
        }
    }]);

    return TilesFlood;
}(_TilesBase2.TilesBase);

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GltfClipPlan = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(1);

var _TilesClipPlan2 = __webpack_require__(86);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//模型剖切(平面)类
var GltfClipPlan = exports.GltfClipPlan = function (_TilesClipPlan) {
    _inherits(GltfClipPlan, _TilesClipPlan);

    function GltfClipPlan() {
        _classCallCheck(this, GltfClipPlan);

        return _possibleConstructorReturn(this, (GltfClipPlan.__proto__ || Object.getPrototypeOf(GltfClipPlan)).apply(this, arguments));
    }

    _createClass(GltfClipPlan, [{
        key: "getInverseTransform",


        //========== 方法 ========== 

        value: function getInverseTransform() {
            if (!this._inverseTransform) {
                var transform = Cesium.Transforms.eastNorthUpToFixedFrame(this._tileset.position.getValue((0, _util.currentTime)()));
                this._inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
            }
            return this._inverseTransform;
        }
    }, {
        key: "setPlanes",
        value: function setPlanes(planes, opts) {
            opts = opts || {};

            this.clear();
            if (!planes) return;

            var clippingPlanes = new Cesium.ClippingPlaneCollection({
                planes: planes,
                edgeWidth: Cesium.defaultValue(opts.edgeWidth, 0.0),
                edgeColor: Cesium.defaultValue(opts.edgeColor, Cesium.Color.WHITE),
                unionClippingRegions: Cesium.defaultValue(opts.unionClippingRegions, false)
            });
            this.clippingPlanes = clippingPlanes;
            this._tileset.model.clippingPlanes = clippingPlanes;
        }

        //清除裁剪面

    }, {
        key: "clear",
        value: function clear() {
            if (this._tileset.model.clippingPlanes) {
                this._tileset.model.clippingPlanes.enabled = false;
                this._tileset.model.clippingPlanes = undefined;
            }

            if (this.clippingPlanes) {
                delete this.clippingPlanes;
            }
        }
    }, {
        key: "entity",

        //========== 对外属性 ========== 
        get: function get() {
            return this._tileset;
        },
        set: function set(val) {
            this._tileset = val;
            this._inverseTransform = null;
        }
    }]);

    return GltfClipPlan;
}(_TilesClipPlan2.TilesClipPlan);

/**
* 裁剪模型 类型 枚举
*@enum {Number}
*/


_TilesClipPlan2.TilesClipPlan.Type = {
    /** z水平面,水平切底部 */
    Z: 1,
    /** z水平面，水平切顶部 */
    ZR: 2,
    /** x垂直面,水平切底部 */
    X: 3,
    /** x垂直面,东西方向切 */
    XR: 4,
    /** y垂直面, 南北方向切 */
    Y: 5,
    /** y垂直面，南北方向切*/
    YR: 6
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FlyLine = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _point = __webpack_require__(2);

var _pointconvert = __webpack_require__(4);

var _polyline = __webpack_require__(22);

var _matrix = __webpack_require__(17);

var _index = __webpack_require__(20);

var drawAttr = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var matrix4 = new Cesium.Matrix4();

var matrix3Scratch = new Cesium.Matrix3();
var positionScratch = new Cesium.Cartesian3();
var orientationScratch = new Cesium.Quaternion();

//参数默认值
var defVal = {
    "model": { "show": false, "scale": 1, "minimumPixelSize": 50 },
    "label": { "show": false, "color": "#ffffff", "opacity": 1, "font_family": "楷体", "font_size": 20, "border": true, "border_color": "#000000", "border_width": 3, "background": false, "hasPixelOffset": true, "pixelOffsetX": 30, "pixelOffsetY": -30, "scaleByDistance": true, "scaleByDistance_far": 10000000, "scaleByDistance_farValue": 0.4, "scaleByDistance_near": 5000, "scaleByDistance_nearValue": 1 },
    "path": { "show": false, "lineType": "solid", "color": "#3388ff", "opacity": 0.5, "width": 1, "outline": false, "outlineColor": "#ffffff", "outlineWidth": 2 },
    "camera": { "type": "", "followedX": 50, "followedZ": 10 },
    "showGroundHeight": false
};

//飞行路线管理类

var FlyLine = exports.FlyLine = function (_MarsClass) {
    _inherits(FlyLine, _MarsClass);

    //========== 构造方法 ========== 
    function FlyLine(viewer, options) {
        _classCallCheck(this, FlyLine);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (FlyLine.__proto__ || Object.getPrototypeOf(FlyLine)).call(this, options));

        if (options.onStep) {
            _this.on(_MarsClass2.eventType.endItem, function (e) {
                options.onStep(e.index, e.counts);
            });
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        _this.viewer = viewer;

        _this.id = options.id || 0;
        _this.name = options.name || "";
        _this.points = options.points; //坐标
        _this.positions = (0, _pointconvert.lonlats2cartesians)(options.points);
        _this.speeds = options.speed;

        //未传入时的属性取默认值的
        for (var key in defVal) {
            var val = defVal[key];

            if (options.hasOwnProperty(key) && _typeof(options[key]) === 'object') {
                for (var key2 in val) {
                    if (!options[key].hasOwnProperty(key2)) options[key][key2] = val[key2];
                }
            } else {
                if (!Cesium.defined(options[key])) options[key] = val;
            }
        }
        _this.options = options; //属性

        //兼容v1版本shadow
        if ((0, _util.isObject)(_this.options.shadow) && _this.options.shadow.show) {
            _this.options.shadow = [_this.options.shadow];
        }

        _this._popup = options.popup;
        _this.offsetHeight = Cesium.defaultValue(_this.options.offsetHeight, 0);

        //参考系
        _this._fixedFrameTransform = Cesium.defaultValue(_this.options.fixedFrameTransform, Cesium.Transforms.eastNorthUpToFixedFrame);

        _this._isStart = false;

        _this._createLine();
        return _this;
    }

    //========== 对外属性 ==========  
    //提示框


    _createClass(FlyLine, [{
        key: "_createLine",


        //========== 方法 ==========  
        value: function _createLine() {
            var startTime; //飞行开始时间 
            if (this.options.startTime) startTime = Cesium.JulianDate.fromDate(new Date(this.options.startTime));else startTime = this.viewer.clock.currentTime;

            //=====================计算飞行时间及坐标====================
            var property = new Cesium.SampledPositionProperty();
            var stopTime; //飞行结束时间 

            var lonlats = this.points;
            if (lonlats.length < 2) {
                marslog.warn('路线无坐标数据，无法漫游！');
                return;
            }

            var speeds = this.speeds;
            var isSpeedArray = !(0, _util.isNumber)(speeds);
            if (lonlats.length == 2) {
                //2个点时，需要插值，否则穿地  
                var centerPt = [(lonlats[0][0] + lonlats[1][0]) / 2, (lonlats[0][1] + lonlats[1][1]) / 2, lonlats[0][2]];
                lonlats.splice(1, 0, centerPt);
                if (speeds && isSpeedArray) speeds.splice(1, 0, speeds[0]);
            }
            var defSpeed = 100; //无速度值时的 默认速度  单位：千米/小时
            var speedsNew = [];

            var alltimes = 0; //总时长,单位：秒
            var alllen = 0; //总长度,单位：米
            var stepLen = {}; //每一步的距离长度
            var stepTime = {}; //每一步的时长

            var lastPoint;
            var arrLinePoint = [];
            for (var i = 0, length = lonlats.length; i < length; i++) {
                var lonlat = lonlats[i];
                var item = Cesium.Cartesian3.fromDegrees(lonlat[0], lonlat[1], (lonlat[2] || 0) + this.offsetHeight);
                item.lonlat = lonlat;

                if (i == 0) {
                    //起点
                    var sTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());
                    item.time = sTime;
                    item.second = alltimes;
                    property.addSample(sTime, item);
                } else {
                    var speed = isSpeedArray ? speeds ? speeds[i - 1] : defSpeed : speeds || defSpeed;
                    speedsNew.push(speed);

                    speed = speed / 3.6; //速度：km/h换算m/s 

                    var len = Cesium.Cartesian3.distance(item, lastPoint);
                    var stime = len / speed;
                    if (stime < 0.01) stime = 0.01; //限定为最小值，防止速度值设置太大时，为0的错误

                    alltimes += stime;
                    alllen += len;

                    var sTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());
                    item.time = sTime;
                    item.second = alltimes;
                    property.addSample(sTime, item);

                    if (this.options.pauseTime) {
                        if (typeof this.options.pauseTime === 'function') {
                            alltimes += this.options.pauseTime(i, item);
                        } else {
                            alltimes += this.options.pauseTime;
                        }
                        var sTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());
                        property.addSample(sTime, (0, _matrix.getOnLinePointByLen)(lastPoint, item, 0.01, true));
                    }
                }
                lastPoint = item;
                arrLinePoint.push(item);

                stepLen[i] = alllen;
                stepTime[i] = alltimes;
            }
            this.speeds = speedsNew;

            this.arrLinePoint = arrLinePoint;
            stopTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());

            this.alltimes = alltimes;
            this.alllen = alllen;
            this.stepLen = stepLen;
            this.stepTime = stepTime;

            this.startTime = startTime;
            this.stopTime = stopTime;
            this.property = property;

            //插值，使折线边平滑 ,并且长距离下不穿地
            if (this.options.interpolation) {
                this.property.setInterpolationOptions({
                    interpolationDegree: this.options.interpolationDegree || 2,
                    interpolationAlgorithm: Cesium.LagrangePolynomialApproximation //HermitePolynomialApproximation
                });
            }
        }
    }, {
        key: "_createEntity",
        value: function _createEntity() {
            var that = this;
            if (this.entity) {
                this.viewer.entities.remove(this.entity);
                delete this.entity;
            }

            var velocityOrientation = new Cesium.VelocityOrientationProperty(this.property); //基于移动位置自动计算方位
            this.velocityOrientation = velocityOrientation;

            var entityAttr = {
                name: this.name,
                // availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
                //     start: this.startTime,
                //     stop: this.stopTime
                // })]),
                position: this.property,
                // position: new Cesium.CallbackProperty(function(time) {
                //     return that.position
                //   }, false),
                orientation: velocityOrientation,
                point: { //必须有对象，否则viewer.trackedEntity无法跟随(无model时使用)
                    show: !(this.options.model && this.options.model.show),
                    color: Cesium.Color.fromCssColorString('#ffffff').withAlpha(0.01),
                    pixelSize: 1
                }
            };

            if (this.options.label && this.options.label.show) {
                this.options.label.text = this.name;
                entityAttr.label = drawAttr.label.style2Entity(this.options.label);
            }
            if (this.options.billboard && this.options.billboard.show) {
                entityAttr.billboard = drawAttr.billboard.style2Entity(this.options.billboard);
            }
            if (this.options.point && this.options.point.show) {
                entityAttr.point = drawAttr.point.style2Entity(this.options.point);
            }
            if (this.options.model && this.options.model.show) {
                entityAttr.model = drawAttr.model.style2Entity(this.options.model);
            }
            if (this.options.path && this.options.path.show) {
                var pathAttr = drawAttr.polyline.style2Entity(this.options.path);
                if (!pathAttr.isAll) {
                    pathAttr.leadTime = 0; //只显示飞过的路线 
                    pathAttr.trailTime = this.alltimes * 10;
                }
                entityAttr.path = pathAttr;
            }
            if (this.options.circle && this.options.circle.show) {
                entityAttr.ellipse = drawAttr.circle.style2Entity(this.options.circle);
            }

            if (this._popup) entityAttr.popup = this._popup;

            this.entity = this.viewer.entities.add(entityAttr);
        }

        //计算贴地线

    }, {
        key: "clampToGround",
        value: function clampToGround(onEnd, opts) {
            opts = opts || {};

            //贴地线
            var lonlats = this.points;
            var speeds = this.speeds;
            var lonlatsNew = [];
            var speedsNew = [];

            //剖面的数据
            var alllen = 0;
            var arrLength = [];
            var arrHbgd = [];
            var arrFxgd = [];
            var arrPoint = [];

            var that = this;
            (0, _polyline.computeStepSurfaceLine)({
                viewer: this.viewer,
                positions: this.positions,
                has3dtiles: opts.has3dtiles,
                splitNum: opts.splitNum,
                offset: opts.offset,
                //计算每个分段后的回调方法
                endItem: function endItem(raisedPositions, noHeight, index) {
                    var speed = speeds[index];

                    if (noHeight) {
                        lonlatsNew.push(lonlats[index]);
                        speedsNew.push(speed);
                    } else {
                        for (var i = 0; i < raisedPositions.length; i++) {
                            var position = raisedPositions[i];
                            var carto = Cesium.Cartographic.fromCartesian(position);

                            lonlatsNew.push([Cesium.Math.toDegrees(carto.longitude), Cesium.Math.toDegrees(carto.latitude), carto.height]);
                            speedsNew.push(speed);
                        }
                    }

                    //剖面的数据 
                    var h1 = lonlats[index][2] || 0;
                    var h2 = lonlats[index + 1][2] || 0;
                    var hstep = (h2 - h1) / raisedPositions.length;

                    for (var i = 0; i < raisedPositions.length; i++) {
                        //已飞行长度
                        if (i != 0) {
                            alllen += Cesium.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
                        }
                        arrLength.push(Number(alllen.toFixed(1)));

                        //坐标
                        var point = (0, _point.formatPosition)(raisedPositions[i]);
                        arrPoint.push(point);

                        //海拔高度
                        var hbgd = noHeight ? 0 : point.z;
                        arrHbgd.push(hbgd);

                        //飞行高度
                        var fxgd = Number((h1 + hstep * i).toFixed(1));
                        arrFxgd.push(fxgd);
                    }
                },
                //计算全部完成的回调方法
                end: function end() {
                    that.points = lonlatsNew;
                    that.speeds = speedsNew;

                    //剖面的数据(记录下，提高效率，避免多次计算)
                    that.terrainHeight = {
                        arrLength: arrLength,
                        arrFxgd: arrFxgd,
                        arrHbgd: arrHbgd,
                        arrPoint: arrPoint
                    };

                    that._createLine();

                    if (onEnd) {
                        onEnd({
                            lonlats: lonlatsNew,
                            speeds: speedsNew
                        });
                    }
                }
            });
        }
    }, {
        key: "updateConfig",
        value: function updateConfig(params) {
            return this.updateStyle(params);
        }
    }, {
        key: "updateStyle",
        value: function updateStyle(params) {
            for (var i in params) {
                if (_typeof(params[i]) === 'object' && this.options[i]) {
                    for (var key2 in params[i]) {
                        this.options[i][key2] = params[i][key2];
                    }
                } else {
                    this.options[i] = params[i];
                }
            }
        }
    }, {
        key: "updateAngle",
        value: function updateAngle(isAuto, opts) {
            if (isAuto) {
                this.entity.orientation = this.velocityOrientation; //基于移动位置自动计算方位

                this._heading = null;
                this._pitch = null;
                this._roll = null;
            } else {
                opts = opts || {};

                var position = this.position; //当前点 
                var _orientation = this.orientation; //获取当前角度  
                if (!position || !_orientation) return null;

                var autoHpr = (0, _matrix.getHeadingPitchRollByOrientation)(position, _orientation, this.viewer.scene.globe.ellipsoid, this._fixedFrameTransform);

                //重新赋值新角度
                var heading = autoHpr.heading;
                var pitch = Cesium.Math.toRadians(Number(opts.pitch || 0.0));
                var roll = Cesium.Math.toRadians(Number(opts.roll || 0.0));

                this._heading = heading;
                this._pitch = pitch;
                this._roll = roll;

                this.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(position, new Cesium.HeadingPitchRoll(heading, pitch, roll), this.viewer.scene.globe.ellipsoid, this._fixedFrameTransform);
            }
        }
    }, {
        key: "start",
        value: function start(opts) {
            if (!Cesium.defined(this.arrLinePoint) || this.arrLinePoint.length == 0) {
                marslog.warn("没有坐标数据，飞行路线启动失败");
                return;
            }

            if (this._isStart) this.stop();
            this._isStart = true;

            this._createEntity();

            //=====================绑定clock timeline====================  
            if (Cesium.defined(this.options.multiplier)) {
                //飞行速度 
                this._bak_multiplier = this.viewer.clock.multiplier;
                this.viewer.clock.multiplier = this.options.multiplier;
            }

            this.viewer.clock.shouldAnimate = true;
            this.viewer.clock.currentTime = this.startTime.clone();

            if (this.options.clockRange || this.options.clockLoop) {
                //循环播放
                this._bak_clockRange = this.viewer.clock.clockRange;
                this._bak_startTime = this.viewer.clock.startTime;
                this._bak_stopTime = this.viewer.clock.stopTime;

                //Cesium.ClockRange.CLAMPED 到达终点后停止，Cesium.ClockRange.LOOP_STOP 到达终止时间后 循环从头播放    
                this.viewer.clock.clockRange = Cesium.defaultValue(this.options.clockRange, Cesium.ClockRange.LOOP_STOP);
                this.viewer.clock.startTime = this.startTime.clone();
                this.viewer.clock.stopTime = this.stopTime.clone();
            }

            if (this.viewer.timeline) this.viewer.timeline.zoomTo(this.startTime, this.stopTime);

            //加投影
            if (this.options.shadow && this.options.shadow.length > 0) {
                this.addArrShading();
            }

            this._flyok_point_index = 0; //优化查询效率，飞行过的点id      
            this.fire(_MarsClass2.eventType.endItem, {
                index: this._flyok_point_index,
                counts: this.arrLinePoint.length
            });
            this.fire(_MarsClass2.eventType.start);
            this.viewer.scene.preRender.addEventListener(this.preRender_eventHandler, this);
        }

        //实时监控事件

    }, {
        key: "preRender_eventHandler",
        value: function preRender_eventHandler(e) {
            if (!this._isStart || !this.viewer.clock.shouldAnimate || this.entity == null) return;

            if (Cesium.JulianDate.greaterThanOrEquals(this.viewer.clock.currentTime, this.stopTime)) {
                this._flyok_point_index = this.arrLinePoint.length - 1;

                //Cesium.ClockRange.CLAMPED 到达终点后停止，Cesium.ClockRange.LOOP_STOP 到达终止时间后 循环从头播放    

                if (!this._onStepTempBS) {
                    this.fire(_MarsClass2.eventType.endItem, {
                        index: this._flyok_point_index,
                        counts: this.arrLinePoint.length
                    });
                    this.fire(_MarsClass2.eventType.end);
                    this._onStepTempBS = true; //为了标识只回调一次
                }

                if (this.options.autoStop || this.viewer.clock.clockRange == Cesium.ClockRange.UNBOUNDED) this.stop();

                return;
            }

            //当前点
            var _position = this.position;
            if (Cesium.defined(_position)) {
                switch (this.options.camera.type) {//视角处理
                    default:
                        //无 
                        if (this.viewer.trackedEntity != undefined) {
                            this.viewer.trackedEntity = undefined;
                            this.flyTo(this.options.camera);
                        }
                        break;
                    case "gs":
                        //跟随视角
                        if (this.viewer.trackedEntity != this.entity) {
                            this.viewer.trackedEntity = this.entity;
                            this.flyTo(this.options.camera);
                        }
                        break;
                    case "dy":
                        //锁定第一视角
                        if (this.viewer.trackedEntity != this.entity) this.viewer.trackedEntity = this.entity;

                        var matrix = this.getModelMatrix();

                        var transformX = this.options.camera.followedX; //距离运动点的距离（后方） 
                        var transformZ = this.options.camera.followedZ; //距离运动点的高度（上方）
                        this.viewer.scene.camera.lookAtTransform(matrix, new Cesium.Cartesian3(-transformX, 0, transformZ));

                        break;
                    case "sd":
                        //锁定上帝视角 
                        if (this.viewer.trackedEntity != this.entity) this.viewer.trackedEntity = this.entity;

                        var matrix = this.getModelMatrix();

                        var transformZ = this.options.camera.followedZ; //距离运动点的高度（上方）
                        this.viewer.scene.camera.lookAtTransform(matrix, new Cesium.Cartesian3(-1, 0, transformZ));
                        break;
                }

                //实时监控
                this.realTime(_position);
            }
        }
        //获取已飞行完成的点的位置
        //JulianDate.compare(left, right), 如果left小于right，则为负值；如果left大于right，则为正值；如果left和right相等，则为零。

    }, {
        key: "getCurrIndex",
        value: function getCurrIndex() {
            var lineLength = this.arrLinePoint.length - 1;
            if (Cesium.JulianDate.compare(this.viewer.clock.currentTime, this.arrLinePoint[0].time) <= 0) {
                this._flyok_point_index = 0;
            }
            if (this._flyok_point_index < 0 || this._flyok_point_index >= lineLength) this._flyok_point_index = 0;

            for (var i = this._flyok_point_index; i <= lineLength; i++) {
                var item = this.arrLinePoint[i];
                if (Cesium.JulianDate.compare(this.viewer.clock.currentTime, item.time) <= 0) {
                    return i - 1;
                }
            }
            for (var i = 0; i <= lineLength; i++) {
                var item = this.arrLinePoint[i];
                if (Cesium.JulianDate.compare(this.viewer.clock.currentTime, item.time) <= 0) {
                    return i - 1;
                }
            }
            return lineLength;
        }
    }, {
        key: "realTime",
        value: function realTime(position) {
            var time = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.startTime); //已飞行时间
            var point = (0, _point.formatPosition)(position);

            var currIndex = this.getCurrIndex();

            var lineLength = this.arrLinePoint.length;
            if (currIndex < 0) currIndex = 0;
            if (currIndex >= lineLength) currIndex = lineLength - 1;

            var thislen = this.stepLen[currIndex];

            var lastPosition = this.arrLinePoint[currIndex];
            if (Cesium.defined(lastPosition)) thislen += Cesium.Cartesian3.distance(position, lastPosition);

            if (thislen >= this.alllen) {
                currIndex = lineLength - 1;
                thislen = this.alllen;
            }

            if (currIndex != this._flyok_point_index) {
                // marslog.log('已飞行过点：' + currIndex); 
                this.fire(_MarsClass2.eventType.endItem, {
                    index: currIndex,
                    counts: lineLength
                });
            }
            this._flyok_point_index = currIndex;

            this.timeinfo = {
                time: time, //已飞行时间
                len: thislen, //已飞行距离
                x: point.x,
                y: point.y,
                z: point.z
            };

            if (this.options.shadow && this.options.shadow.length > 0) {
                //投影 
                this.updateArrShading(position);
            }

            //求概略的 地面海拔 和 离地高度
            var carto = Cesium.Cartographic.fromCartesian(position);
            var heightTerrain = this.viewer.scene.globe.getHeight(carto); //地形高度
            if (heightTerrain != null && heightTerrain > 0) {
                this.timeinfo.hbgd = heightTerrain;
                this.timeinfo.ldgd = point.z - heightTerrain;
            }

            //求准确的 地面海拔 和 离地高度 (没有此需求时可以关闭，提高效率)
            if (this.options.showGroundHeight) {
                var that = this;
                (0, _polyline.computeSurfaceLine)({
                    viewer: that.viewer,
                    positions: [position, position],
                    callback: function callback(raisedPositions, noHeight) {
                        if (raisedPositions == null || raisedPositions.length == 0 || noHeight) {
                            return;
                        }

                        var hbgd = (0, _point.formatPosition)(raisedPositions[0]).z; //地面高程      
                        var ldgd = point.z - hbgd; //离地高度

                        that.timeinfo.hbgd = hbgd;
                        that.timeinfo.ldgd = ldgd;

                        if (that.entity.label) {
                            var fxgd_str = (0, _util.formatLength)(that.timeinfo.z);
                            var ldgd_str = (0, _util.formatLength)(that.timeinfo.ldgd);
                            that.entity.label.text = that.name + "\n" + "漫游高程：" + fxgd_str + "\n离地距离：" + ldgd_str;
                        }
                    }
                });
            }
        }

        //锁定视角计算

    }, {
        key: "getModelMatrix",
        value: function getModelMatrix() {
            var position = this.position;
            if (!Cesium.defined(position)) {
                return undefined;
            }
            var result;
            var orientation = this.orientation;
            if (!Cesium.defined(orientation)) {
                result = this._fixedFrameTransform(position, undefined, matrix4);
            } else {
                result = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, matrix3Scratch), position, matrix4);
            }
            return result;
        }

        //获取剖面数据

    }, {
        key: "getTerrainHeight",
        value: function getTerrainHeight(callback, opts) {
            if (this.terrainHeight) {
                callback(this.terrainHeight);
                return this.terrainHeight;
            } else {
                opts = opts || {};

                var lonlats = this.points;

                //剖面的数据
                var alllen = 0;
                var arrLength = [];
                var arrHbgd = [];
                var arrFxgd = [];
                var arrPoint = [];

                var that = this;
                (0, _polyline.computeStepSurfaceLine)({
                    viewer: this.viewer,
                    positions: this.positions,
                    has3dtiles: opts.has3dtiles,
                    splitNum: opts.splitNum,
                    offset: opts.offset,
                    //计算每个分段后的回调方法
                    endItem: function endItem(raisedPositions, noHeight, index) {
                        //剖面的数据 
                        var h1 = lonlats[index][2] || 0;
                        var h2 = lonlats[index + 1][2] || 0;
                        var hstep = (h2 - h1) / raisedPositions.length;

                        for (var i = 0; i < raisedPositions.length; i++) {
                            //已飞行长度
                            if (i != 0) {
                                alllen += Cesium.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
                            }
                            arrLength.push(Number(alllen.toFixed(1)));

                            //坐标
                            var point = (0, _point.formatPosition)(raisedPositions[i]);
                            arrPoint.push(point);

                            //海拔高度
                            var hbgd = noHeight ? 0 : point.z;
                            arrHbgd.push(hbgd);

                            //飞行高度
                            var fxgd = Number((h1 + hstep * i).toFixed(1));
                            arrFxgd.push(fxgd);
                        }
                    },
                    //计算全部完成的回调方法
                    end: function end() {
                        //剖面的数据(记录下，提高效率，避免多次计算)
                        that.terrainHeight = {
                            arrLength: arrLength,
                            arrFxgd: arrFxgd,
                            arrHbgd: arrHbgd,
                            arrPoint: arrPoint
                        };
                        callback(that.terrainHeight);
                    }
                });
            }
        }
    }, {
        key: "toGeoJSON",
        value: function toGeoJSON() {
            return this.options;
        }
    }, {
        key: "toCZML",
        value: function toCZML() {
            var attr = this.options;

            //时间
            var currentTime = this.startTime.toString();
            var stopTime = this.stopTime.toString();

            //路径位置点
            var cartographicDegrees = [];
            var arrLinePoint = this.arrLinePoint;
            for (var i = 0, length = arrLinePoint.length; i < length; i++) {
                var item = arrLinePoint[i];

                cartographicDegrees.push(item.second);
                cartographicDegrees = cartographicDegrees.concat(item.lonlat);
            }

            var czmlLine = {
                "id": this.name,
                "description": this.options.remark,
                "availability": currentTime + "/" + stopTime,
                "orientation": { //方向
                    "velocityReference": "#position"
                },
                "position": { //位置 
                    "epoch": currentTime,
                    "cartographicDegrees": cartographicDegrees,
                    "interpolationAlgorithm": "LAGRANGE", //插值时使用的插值算法,有效值为“LINEAR”，“LAGRANGE”和“HERMITE”。
                    "interpolationDegree": 2 //插值时使用的插值程度。
                }
            };

            if (this.options.label.show) {
                //是否显示注记
                czmlLine.label = {
                    "show": true,
                    "outlineWidth": 2,
                    "text": this.name,
                    "font": "12pt 微软雅黑 Console",
                    "outlineColor": { "rgba": [0, 0, 0, 255] },
                    "horizontalOrigin": "LEFT",
                    "fillColor": { "rgba": [213, 255, 0, 255] }
                };
            }
            if (this.options.path.show) {
                //是否显示路线
                czmlLine.path = { //路线
                    "show": true,
                    "material": { "solidColor": { "color": { "rgba": [255, 0, 0, 255] } } },
                    "width": 5,
                    "resolution": 1,
                    "leadTime": 0,
                    "trailTime": this.alltimes
                };
            }
            //漫游对象(模型)
            if (this.options.model.show) {
                //是否显示模型
                czmlLine.model = this.options.model;
            }

            var czml = [{
                "version": "1.0",
                "id": "document",
                "clock": {
                    "interval": currentTime + "/" + stopTime,
                    "currentTime": currentTime,
                    "multiplier": 1
                }
            }, czmlLine];
            return czml;
        }

        //视角定位[路线范围]

    }, {
        key: "centerAt",
        value: function centerAt(opts) {
            opts = opts || {};

            var rectangle = (0, _point.getRectangle)(this.positions);
            this.viewer.camera.flyTo({
                duration: Cesium.defaultValue(opts.duration, 0),
                destination: rectangle
            });
            return rectangle;
        }

        //视角定位[目标点] 

    }, {
        key: "flyTo",
        value: function flyTo(opts) {
            var _this2 = this;

            opts = opts || {};

            var viewer = this.viewer;
            var position = this.position;
            if (!position) return;

            if (this.viewer.scene.mode == Cesium.SceneMode.SCENE3D) {
                this.viewer.clock.shouldAnimate = false;
                setTimeout(function () {
                    var heading = Cesium.Math.toDegrees(_this2.hdr.heading) + Cesium.defaultValue(opts.heading, 0);

                    viewer.mars.centerPoint(position, {
                        radius: Cesium.defaultValue(opts.radius, Cesium.defaultValue(opts.distance, 500)), //距离目标点的距离
                        heading: heading,
                        pitch: Cesium.defaultValue(opts.pitch, -50),
                        duration: 0.1,
                        complete: function complete() {
                            viewer.clock.shouldAnimate = true;
                        }
                    });
                }, 500);
            } else {}
        }

        //暂停

    }, {
        key: "pause",
        value: function pause() {
            this.viewer.clock.shouldAnimate = false;
        }
        //继续

    }, {
        key: "proceed",
        value: function proceed() {
            this.viewer.clock.shouldAnimate = true;
        }

        //加投影等额外的entity对象  

    }, {
        key: "addArrShading",
        value: function addArrShading() {
            var arrEntity = [];

            var entity;
            for (var i = 0, len = this.options.shadow.length; i < len; i++) {
                var item = this.options.shadow[i];
                if (!item.show) continue;

                switch (item.type) {
                    case "wall":
                        entity = this.addWallShading(item);
                        break;
                    case "cylinder":
                        entity = this.addCylinderShading(item);
                        break;
                    case "circle":
                        entity = this.addCircleShading(item);
                        break;
                    case "polyline":
                    case "polyline-going":
                        entity = this.addPolylineShading(item);
                        break;
                    default:
                        marslog.warn("存在未标识type的无效shadow配置");
                        break;
                }
                if (entity) arrEntity.push(entity);
            }

            this.arrShowingEntity = arrEntity;
        }
    }, {
        key: "updateArrShading",
        value: function updateArrShading(position) {
            for (var i = 0, len = this.options.shadow.length; i < len; i++) {
                var item = this.options.shadow[i];
                if (!item.show) continue;
                // var entity = this.arrShowingEntity[i];

                switch (item.type) {
                    case "wall":
                        var flyOkPoints = this.arrLinePoint.slice(0, this._flyok_point_index + 1);
                        flyOkPoints.push(position);
                        this.updateWallShading(flyOkPoints);
                        break;
                    case "polyline":
                        var flyOkPoints = this.arrLinePoint.slice(0, this._flyok_point_index + 1);
                        flyOkPoints.push(position);
                        this._passed_positions = flyOkPoints;
                        break;
                    case "polyline-going":
                        var goingPoints = [position].concat(this.arrLinePoint.slice(this._flyok_point_index + 1));
                        this._going_positions = goingPoints;
                        break;

                }
            }
        }

        //垂直线立体投影

    }, {
        key: "addWallShading",
        value: function addWallShading(options) {
            this._wall_positions = [];
            this._wall_minimumHeights = [];
            this._wall_maximumHeights = [];

            options = _extends({ "color": "#00ff00", "outline": false, "opacity": 0.3 }, options);

            var that = this;
            var wallattr = drawAttr.wall.style2Entity(options);
            wallattr.minimumHeights = new Cesium.CallbackProperty(function (time) {
                return that._wall_minimumHeights;
            }, false);
            wallattr.maximumHeights = new Cesium.CallbackProperty(function (time) {
                return that._wall_maximumHeights;
            }, false);
            wallattr.positions = new Cesium.CallbackProperty(function (time) {
                return that._wall_positions;
            }, false);

            var wallEntity = this.viewer.entities.add({
                wall: wallattr
            });
            return wallEntity;
        }
    }, {
        key: "updateWallShading",
        value: function updateWallShading(positions) {
            var newposition = [];
            var minimumHeights = [];
            var maximumHeights = [];
            for (var i = 0; i < positions.length; i++) {
                var point = positions[i].clone();
                if (!point) continue;

                newposition.push(point);
                var carto = Cesium.Cartographic.fromCartesian(point);
                minimumHeights.push(0);
                maximumHeights.push(carto.height);
            }
            this._wall_positions = newposition;
            this._wall_minimumHeights = minimumHeights;
            this._wall_maximumHeights = maximumHeights;
        }

        //圆锥立体 投影

    }, {
        key: "addCylinderShading",
        value: function addCylinderShading(options) {
            var bottomRadiusNow = 100;
            var lengthNow = 100;

            var that = this;

            options = _extends({ "color": "#00ff00", "outline": false, "opacity": 0.3 }, options);

            var wallattr = drawAttr.wall.style2Entity(options); //主要是颜色值等属性
            wallattr.length = new Cesium.CallbackProperty(function (time) {
                return lengthNow;
            }, false);
            wallattr.topRadius = 0;
            wallattr.bottomRadius = new Cesium.CallbackProperty(function (time) {
                return bottomRadiusNow;
            }, false);
            wallattr.numberOfVerticalLines = 0;

            var cylinderEntity = this.viewer.entities.add({
                position: new Cesium.CallbackProperty(function (time) {
                    var position = that.position;
                    if (!position) return null;
                    var car = Cesium.Cartographic.fromCartesian(position);
                    var newPoint = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height / 2);

                    lengthNow = car.height;
                    bottomRadiusNow = lengthNow * 0.3; //地面圆半径

                    return newPoint;
                }, false),
                cylinder: wallattr
            });
            return cylinderEntity;
        }

        //扩散圆 投影

    }, {
        key: "addCircleShading",
        value: function addCircleShading(options) {
            var attr = drawAttr.circle.style2Entity(options);

            var entity = this.viewer.entities.add({
                // availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
                //     start: this.startTime,
                //     stop: this.stopTime
                // })]),
                position: this.property,
                ellipse: attr
            });
            return entity;
        }

        //polyline路线 投影

    }, {
        key: "addPolylineShading",
        value: function addPolylineShading(options) {
            var that = this;
            var attr = drawAttr.polyline.style2Entity(options);
            attr.positions = new Cesium.CallbackProperty(function (time) {
                if (options.type == "polyline-going") return that._going_positions;else return that._passed_positions;
            }, false);

            var entity = this.viewer.entities.add({
                polyline: attr
            });
            return entity;
        }

        //停止，结束漫游

    }, {
        key: "stop",
        value: function stop() {
            this.viewer.trackedEntity = undefined;
            this.viewer.scene.preRender.removeEventListener(this.preRender_eventHandler, this);

            if (this.entity) {
                this.viewer.entities.remove(this.entity);
                delete this.entity;
            }
            if (this.arrShowingEntity) {
                for (var i = 0, len = this.arrShowingEntity.length; i < len; i++) {
                    this.viewer.entities.remove(this.arrShowingEntity[i]);
                }
                delete this.arrShowingEntity;
            }

            if (this._bak_startTime) {
                this.viewer.clock.startTime = this._bak_startTime;
                delete this._bak_startTime;
            }
            if (this._bak_stopTime) {
                this.viewer.clock.stopTime = this._bak_stopTime;
                delete this._bak_stopTime;
            }
            if (this._bak_multiplier) {
                this.viewer.clock.multiplier = this._bak_multiplier;
                delete this._bak_multiplier;
            }
            if (this._bak_clockRange) {
                this.viewer.clock.clockRange = this._bak_clockRange;
                delete this._bak_clockRange;
            }

            this._flyok_point_index = 0;
            this._isStart = false;
            this.fire(_MarsClass2.eventType.end);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.stop();
            _get(FlyLine.prototype.__proto__ || Object.getPrototypeOf(FlyLine.prototype), "destroy", this).call(this);
        }
    }, {
        key: "popup",
        get: function get() {
            return this._popup;
        },
        set: function set(value) {
            this._popup = value;

            if (this.entity) this.entity.popup = value;
        }
        //当前信息

    }, {
        key: "info",
        get: function get() {
            return this.timeinfo;
        }

        //已经飞行过的点index

    }, {
        key: "indexForFlyOK",
        get: function get() {
            return this._flyok_point_index;
        }

        // 当前点

    }, {
        key: "position",
        get: function get() {
            var position = Cesium.Property.getValueOrUndefined(this.property, this.viewer.clock.currentTime, positionScratch);
            // if (!position) {
            //     return this.position_last
            // }
            // this.position_last = position;
            return position;
        }

        // 获取当前角度 

    }, {
        key: "orientation",
        get: function get() {
            var _orientation = Cesium.Property.getValueOrUndefined(this.velocityOrientation, this.viewer.clock.currentTime, orientationScratch);
            return _orientation;
        }

        // 获取当前hdr角度 

    }, {
        key: "hdr",
        get: function get() {
            var position = this.position; //当前点 
            var _orientation = this.orientation; //获取当前角度 
            if (!position || !_orientation) return null;

            var autoHpr = (0, _matrix.getHeadingPitchRollByOrientation)(position, _orientation, this.viewer.scene.globe.ellipsoid, this._fixedFrameTransform);
            return autoHpr;
        }

        // 获取当前矩阵

    }, {
        key: "matrix",
        get: function get() {
            return this.getModelMatrix();
        }
    }, {
        key: "heading",
        get: function get() {
            if (!Cesium.defined(this._heading)) {
                var hdr = this.hdr;
                if (hdr) return hdr.heading;else return null;
            }
            return this._heading;
        }
    }, {
        key: "pitch",
        get: function get() {
            if (!Cesium.defined(this._pitch)) {
                var hdr = this.hdr;
                if (hdr) return hdr.pitch;else return null;
            }
            return this._pitch;
        },
        set: function set(val) {
            this._pitch = val;
            this.updateAngle(false, { pitch: this._pitch, roll: this._roll });
        }
    }, {
        key: "roll",
        get: function get() {
            if (!Cesium.defined(this._roll)) {
                var hdr = this.hdr;
                if (hdr) return hdr.roll;else return null;
            }
            return this._roll;
        },
        set: function set(val) {
            this._roll = val;
            this.updateAngle(false, { pitch: this._pitch, roll: this._roll });
        }

        //求与卫星中心射线与地球相交点

    }, {
        key: "groundPosition",
        get: function get() {
            return (0, _matrix.getRayEarthPositionByMatrix)(this.matrix, true, this.viewer.scene.globe.ellipsoid);
        }
    }]);

    return FlyLine;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


FlyLine.event = {
    start: _MarsClass2.eventType.start,
    endItem: _MarsClass2.eventType.endItem,
    end: _MarsClass2.eventType.end
};

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FirstPersonRoam = exports.RoamType = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var scratchCurrentDirection = new Cesium.Cartesian3();
var scratchDeltaPosition = new Cesium.Cartesian3();
var scratchNextPosition = new Cesium.Cartesian3();
var scratchTerrainConsideredNextPosition = new Cesium.Cartesian3();
var scratchNextCartographic = new Cesium.Cartographic();

var RoamType = exports.RoamType = {
    DIRECTION_NONE: 0,
    DIRECTION_FORWARD: 1,
    DIRECTION_BACKWARD: 2,
    DIRECTION_LEFT: 3,
    DIRECTION_RIGHT: 4

    //第一人称贴地漫游 
};
var FirstPersonRoam = exports.FirstPersonRoam = function () {
    function FirstPersonRoam(options) {
        _classCallCheck(this, FirstPersonRoam);

        this.options = options;
        this.viewer = options.viewer;

        this._canvas = this.viewer.canvas;
        this._camera = this.viewer.camera;

        this.speed = Cesium.defaultValue(this.options.speed, 1.5); //速度
        this.rotateSpeed = Cesium.defaultValue(this.options.rotateSpeed, -5);
        this.height = Cesium.defaultValue(this.options.height, 10); //高度
        this.maxPitch = Cesium.defaultValue(this.options.maxPitch, 88); //最大pitch角度

        this.initEvent();
        this.enabled = Cesium.defaultValue(this.options.enabled, false);
    }
    //========== 对外属性 ==========  


    _createClass(FirstPersonRoam, [{
        key: "initEvent",


        //========== 方法 ==========  
        value: function initEvent() {
            this.handler = new Cesium.ScreenSpaceEventHandler(this._canvas);
            this.handler.setInputAction(this._onMouseLButtonClicked.bind(this), Cesium.ScreenSpaceEventType.LEFT_DOWN);
            this.handler.setInputAction(this._onMouseUp.bind(this), Cesium.ScreenSpaceEventType.LEFT_UP);
            this.handler.setInputAction(this._onMouseMove.bind(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            this.handler.setInputAction(this._onMouseLButtonDoubleClicked.bind(this), Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

            var canvas = this.viewer.canvas;
            canvas.setAttribute("tabindex", "0");
            canvas.onclick = function () {
                canvas.focus();
            };
            canvas.addEventListener("keydown", this._onKeyDown.bind(this));
            canvas.addEventListener("keyup", this._onKeyUp.bind(this));

            this.viewer.clock.onTick.addEventListener(this._onClockTick, this);
        }
    }, {
        key: "_onMouseLButtonClicked",
        value: function _onMouseLButtonClicked(movement) {
            if (!this._enabled) return;
            this._looking = true;
            this._mousePosition = this._startMousePosition = Cesium.Cartesian3.clone(movement.position);
        }
    }, {
        key: "_onMouseLButtonDoubleClicked",
        value: function _onMouseLButtonDoubleClicked(movement) {
            if (!this._enabled) return;
            this._looking = true;
            this._mousePosition = this._startMousePosition = Cesium.Cartesian3.clone(movement.position);
        }
    }, {
        key: "_onMouseUp",
        value: function _onMouseUp(position) {
            if (!this._enabled) return;
            this._looking = false;
        }
    }, {
        key: "_onMouseMove",
        value: function _onMouseMove(movement) {
            if (!this._enabled) return;
            this._mousePosition = movement.endPosition;
        }
    }, {
        key: "_onKeyDown",
        value: function _onKeyDown(event) {
            if (!this._enabled) return;

            var keyCode = event.keyCode;
            this._direction = RoamType.DIRECTION_NONE;

            switch (keyCode) {
                case "W".charCodeAt(0):
                    this._direction = RoamType.DIRECTION_FORWARD;
                    return;
                case "S".charCodeAt(0):
                    this._direction = RoamType.DIRECTION_BACKWARD;
                    return;
                case "D".charCodeAt(0):
                    this._direction = RoamType.DIRECTION_RIGHT;
                    return;
                case "A".charCodeAt(0):
                    this._direction = RoamType.DIRECTION_LEFT;
                    return;
                default:
                    return;
            }
        }

        //开始自动漫游

    }, {
        key: "startMoveForward",
        value: function startMoveForward() {
            if (!this._enabled) this.start();
            this._direction = RoamType.DIRECTION_FORWARD;
        }
    }, {
        key: "stopMoveForward",
        value: function stopMoveForward() {
            this._direction = RoamType.DIRECTION_NONE;
        }
    }, {
        key: "_onKeyUp",
        value: function _onKeyUp() {
            this._direction = RoamType.DIRECTION_NONE;
        }
    }, {
        key: "_onClockTick",
        value: function _onClockTick(clock) {
            if (!this._enabled) return;

            var dt = clock._clockStep;

            if (this._looking) this._changeHeadingPitch(dt);

            if (this._direction === RoamType.DIRECTION_NONE) return;

            var distance = this.speed * dt;

            if (this._direction === RoamType.DIRECTION_FORWARD) Cesium.Cartesian3.multiplyByScalar(this._camera.direction, 1, scratchCurrentDirection);else if (this._direction === RoamType.DIRECTION_BACKWARD) Cesium.Cartesian3.multiplyByScalar(this._camera.direction, -1, scratchCurrentDirection);else if (this._direction === RoamType.DIRECTION_LEFT) Cesium.Cartesian3.multiplyByScalar(this._camera.right, -1, scratchCurrentDirection);else if (this._direction === RoamType.DIRECTION_RIGHT) Cesium.Cartesian3.multiplyByScalar(this._camera.right, 1, scratchCurrentDirection);

            Cesium.Cartesian3.multiplyByScalar(scratchCurrentDirection, distance, scratchDeltaPosition);

            var currentCameraPosition = this._camera.position;

            Cesium.Cartesian3.add(currentCameraPosition, scratchDeltaPosition, scratchNextPosition);

            // consider terrain height

            var globe = this.viewer.scene.globe;
            var ellipsoid = globe.ellipsoid;

            // get height for next update position
            ellipsoid.cartesianToCartographic(scratchNextPosition, scratchNextCartographic);

            var height = globe.getHeight(scratchNextCartographic);

            if (height === undefined) {
                // console.warn('height is undefined!');
                return;
            }

            if (height < 0) {
                // console.warn(`height is negative!`);
            }

            scratchNextCartographic.height = height + this.height;

            ellipsoid.cartographicToCartesian(scratchNextCartographic, scratchTerrainConsideredNextPosition);

            this._camera.setView({
                destination: scratchTerrainConsideredNextPosition,
                orientation: new Cesium.HeadingPitchRoll(this._camera.heading, this._camera.pitch, this._camera.roll),
                endTransform: Cesium.Matrix4.IDENTITY
            });
        }
    }, {
        key: "_changeHeadingPitch",
        value: function _changeHeadingPitch(dt) {
            var width = this._canvas.clientWidth;
            var height = this._canvas.clientHeight;

            // Coordinate (0.0, 0.0) will be where the mouse was clicked.
            var deltaX = (this._mousePosition.x - this._startMousePosition.x) / width;
            var deltaY = -(this._mousePosition.y - this._startMousePosition.y) / height;

            var currentHeadingInDegree = Cesium.Math.toDegrees(this._camera.heading);
            var deltaHeadingInDegree = deltaX * this.rotateSpeed;
            var newHeadingInDegree = currentHeadingInDegree + deltaHeadingInDegree;

            var currentPitchInDegree = Cesium.Math.toDegrees(this._camera.pitch);
            var deltaPitchInDegree = deltaY * this.rotateSpeed;
            var newPitchInDegree = currentPitchInDegree + deltaPitchInDegree;

            // console.log("rotationSpeed: " + this.rotateSpeed + " deltaY: " + deltaY + " deltaPitchInDegree" + deltaPitchInDegree);

            if (newPitchInDegree > this.maxPitch * 2 && newPitchInDegree < 360 - this.maxPitch) {
                newPitchInDegree = 360 - this.maxPitch;
            } else {
                if (newPitchInDegree > this.maxPitch && newPitchInDegree < 360 - this.maxPitch) {
                    newPitchInDegree = this.maxPitch;
                }
            }

            this._camera.setView({
                orientation: {
                    heading: Cesium.Math.toRadians(newHeadingInDegree),
                    pitch: Cesium.Math.toRadians(newPitchInDegree),
                    roll: this._camera.roll
                }
            });
        }
    }, {
        key: "enableScreenSpaceCameraController",
        value: function enableScreenSpaceCameraController(enabled) {
            var scene = this.viewer.scene;
            scene.screenSpaceCameraController.enableRotate = enabled;
            scene.screenSpaceCameraController.enableTranslate = enabled;
            scene.screenSpaceCameraController.enableZoom = enabled;
            scene.screenSpaceCameraController.enableTilt = enabled;
            scene.screenSpaceCameraController.enableLook = enabled;
        }
    }, {
        key: "start",
        value: function start() {
            this._enabled = true;
            this.enableScreenSpaceCameraController(false);

            var currentCameraPosition = this._camera.position;
            var cartographic = new Cesium.Cartographic();
            var globe = this.viewer.scene.globe;

            globe.ellipsoid.cartesianToCartographic(currentCameraPosition, cartographic);

            var height = globe.getHeight(cartographic);

            if (height === undefined) return false;

            if (height < 0) {
                // console.warn(`height is negative`);
            }

            cartographic.height = height + this.height;

            var newCameraPosition = new Cesium.Cartesian3();

            globe.ellipsoid.cartographicToCartesian(cartographic, newCameraPosition);

            var currentCameraHeading = this._camera.heading;
            this._heading = currentCameraHeading;
            this._camera.flyTo({
                destination: newCameraPosition,
                orientation: {
                    heading: currentCameraHeading,
                    pitch: Cesium.Math.toRadians(0),
                    roll: 0.0
                }
            });

            return true;
        }
    }, {
        key: "stop",
        value: function stop() {
            this._enabled = false;
            this.enableScreenSpaceCameraController(true);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.stop();

            if (this.handler) {
                this.handler.destroy();
                delete this.handler;
            }

            var canvas = this.viewer.canvas;
            canvas.removeEventListener("keydown", this._onKeyDown, this);
            canvas.removeEventListener("keyup", this._onKeyUp, this);
            this.viewer.clock.onTick.removeEventListener(this._onClockTick, this);

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "enable",
        get: function get() {
            return this._enabled;
        },
        set: function set(value) {
            this._enabled = value;

            if (this._enabled) {
                this.start();
            } else {
                this.stop();
            }
        }
    }]);

    return FirstPersonRoam;
}();

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _AttackArrow = __webpack_require__(161);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头
var drawtype = 'attackArrow';

var attackArrow = new _AttackArrow.AttackArrow();

//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    //========== 构造方法 ========== 
    function EditEx(entity, viewer) {
        _classCallCheck(this, EditEx);

        var _this = _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).call(this, entity, viewer));

        _this._hasMidPoint = true; //是否可以加点
        _this.hasClosure = false; //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
        return _this;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(EditEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return attackArrow.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 3; //至少需要点的个数 
        _this2._maxPointNum = 999; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return attackArrow.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AttackArrow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _ArrowParent2 = __webpack_require__(38);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头
var AttackArrow = exports.AttackArrow = function (_ArrowParent) {
    _inherits(AttackArrow, _ArrowParent);

    function AttackArrow(opt) {
        _classCallCheck(this, AttackArrow);

        var _this = _possibleConstructorReturn(this, (AttackArrow.__proto__ || Object.getPrototypeOf(AttackArrow)).call(this));

        if (!opt) opt = {};
        //影响因素
        _this.headHeightFactor = opt.headHeightFactor || 0.18;
        _this.headWidthFactor = opt.headWidthFactor || 0.3;
        _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
        _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
        _this.headTailFactor = opt.headTailFactor || 0.8;
        _this.positions = null;
        _this.plotUtil = _PlotUtil.plotUtil;
        return _this;
    }

    _createClass(AttackArrow, [{
        key: 'startCompute',
        value: function startCompute(positions) {
            if (!positions) return;
            this.positions = positions;
            var pnts = pointconvert.cartesians2mercators(positions);

            var _ref = [pnts[0], pnts[1]],
                tailLeft = _ref[0],
                tailRight = _ref[1];

            if (this.plotUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
                tailLeft = pnts[1];
                tailRight = pnts[0];
            }
            var midTail = this.plotUtil.Mid(tailLeft, tailRight);
            var bonePnts = [midTail].concat(pnts.slice(2));
            var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
            var _ref2 = [headPnts[0], headPnts[4]],
                neckLeft = _ref2[0],
                neckRight = _ref2[1];

            var tailWidthFactor = this.plotUtil.MathDistance(tailLeft, tailRight) / this.plotUtil.getBaseLength(bonePnts);
            var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, tailWidthFactor);
            var count = bodyPnts.length;
            var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
            leftPnts.push(neckLeft);
            var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
            rightPnts.push(neckRight);
            leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
            rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
            var pList = leftPnts.concat(headPnts, rightPnts.reverse());

            var returnArr = pointconvert.mercators2cartesians(pList);
            return returnArr;
        }
    }]);

    return AttackArrow;
}(_ArrowParent2.ArrowParent);

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _AttackArrowPW = __webpack_require__(163);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头(平尾)
var drawtype = 'attackArrowPW';
var attackArrow = new _AttackArrowPW.AttackArrowPW();

//编辑

//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    //========== 构造方法 ========== 
    function EditEx(entity, viewer) {
        _classCallCheck(this, EditEx);

        var _this = _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).call(this, entity, viewer));

        _this._hasMidPoint = true; //是否可以加点
        _this.hasClosure = false; //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
        return _this;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(EditEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return attackArrow.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 3; //至少需要点的个数 
        _this2._maxPointNum = 999; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return attackArrow.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AttackArrowPW = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _ArrowParent2 = __webpack_require__(38);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头（燕尾）
var AttackArrowPW = exports.AttackArrowPW = function (_ArrowParent) {
    _inherits(AttackArrowPW, _ArrowParent);

    function AttackArrowPW(opt) {
        _classCallCheck(this, AttackArrowPW);

        var _this = _possibleConstructorReturn(this, (AttackArrowPW.__proto__ || Object.getPrototypeOf(AttackArrowPW)).call(this));

        if (!opt) opt = {};
        //影响因素
        _this.headHeightFactor = opt.headHeightFactor || 0.18;
        _this.headWidthFactor = opt.headWidthFactor || 0.3;
        _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
        _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
        _this.tailWidthFactor = opt.tailWidthFactor || 0.1;

        _this.positions = null;
        _this.plotUtil = _PlotUtil.plotUtil;
        return _this;
    }

    _createClass(AttackArrowPW, [{
        key: 'startCompute',
        value: function startCompute(positions) {
            if (!positions) return;
            this.positions = positions;

            var pnts = pointconvert.cartesians2mercators(positions);

            var tailPnts = this.getTailPoints(pnts);
            var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[1]);
            var neckLeft = headPnts[0];
            var neckRight = headPnts[4];
            var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
            var _count = bodyPnts.length;
            var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
            leftPnts.push(neckLeft);
            var rightPnts = [tailPnts[1]].concat(bodyPnts.slice(_count / 2, _count));
            rightPnts.push(neckRight);
            leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
            rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
            var pList = leftPnts.concat(headPnts, rightPnts.reverse());

            var returnArr = pointconvert.mercators2cartesians(pList);
            return returnArr;
        }
    }, {
        key: 'getTailPoints',
        value: function getTailPoints(points) {
            var allLen = this.plotUtil.getBaseLength(points);
            var tailWidth = allLen * this.tailWidthFactor;
            var tailLeft = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
            var tailRight = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
            return [tailLeft, tailRight];
        }
    }]);

    return AttackArrowPW;
}(_ArrowParent2.ArrowParent);

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _AttackArrowYW = __webpack_require__(165);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头
var drawtype = 'attackArrowYW';
var attackArrow = new _AttackArrowYW.AttackArrowYW();

//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    //========== 构造方法 ========== 
    function EditEx(entity, viewer) {
        _classCallCheck(this, EditEx);

        var _this = _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).call(this, entity, viewer));

        _this._hasMidPoint = true; //是否可以加点
        _this.hasClosure = false; //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
        return _this;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(EditEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return attackArrow.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 3; //至少需要点的个数 
        _this2._maxPointNum = 999; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return attackArrow.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);
//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AttackArrowYW = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _ArrowParent2 = __webpack_require__(38);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头（燕尾）
var AttackArrowYW = exports.AttackArrowYW = function (_ArrowParent) {
    _inherits(AttackArrowYW, _ArrowParent);

    function AttackArrowYW(opt) {
        _classCallCheck(this, AttackArrowYW);

        var _this = _possibleConstructorReturn(this, (AttackArrowYW.__proto__ || Object.getPrototypeOf(AttackArrowYW)).call(this));

        if (!opt) opt = {};
        //影响因素
        _this.headHeightFactor = opt.headHeightFactor || 0.18;
        _this.headWidthFactor = opt.headWidthFactor || 0.3;
        _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
        _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
        _this.tailWidthFactor = opt.tailWidthFactor || 0.1;
        _this.headTailFactor = opt.headTailFactor || 0.8;
        _this.swallowTailFactor = opt.swallowTailFactor || 1;
        _this.positions = null;
        _this.plotUtil = _PlotUtil.plotUtil;
        return _this;
    }

    _createClass(AttackArrowYW, [{
        key: 'startCompute',
        value: function startCompute(positions) {
            if (!positions) return;
            this.positions = positions;

            var pnts = pointconvert.cartesians2mercators(positions);

            var _ref = [pnts[0], pnts[1]],
                tailLeft = _ref[0],
                tailRight = _ref[1];

            if (this.plotUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
                tailLeft = pnts[1];
                tailRight = pnts[0];
            }
            var midTail = this.plotUtil.Mid(tailLeft, tailRight);
            var bonePnts = [midTail].concat(pnts.slice(2));
            var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
            var _ref2 = [headPnts[0], headPnts[4]],
                neckLeft = _ref2[0],
                neckRight = _ref2[1];

            var tailWidth = this.plotUtil.MathDistance(tailLeft, tailRight);
            var allLen = this.plotUtil.getBaseLength(bonePnts);
            var len = allLen * this.tailWidthFactor * this.swallowTailFactor;
            var swallowTailPnt = this.plotUtil.getThirdPoint(bonePnts[1], bonePnts[0], 0, len, true);
            var factor = tailWidth / allLen;
            var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, factor);
            var count = bodyPnts.length;
            var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
            leftPnts.push(neckLeft);
            var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
            rightPnts.push(neckRight);
            leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
            rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
            var pList = leftPnts.concat(headPnts, rightPnts.reverse(), [swallowTailPnt, leftPnts[0]]);

            var returnArr = pointconvert.mercators2cartesians(pList);
            return returnArr;
        }
    }]);

    return AttackArrowYW;
}(_ArrowParent2.ArrowParent);

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _CloseCurve = __webpack_require__(167);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//闭合曲面(3个点)
var drawtype = 'closeVurve';
var closeCurve = new _CloseCurve.CloseCurve();
//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    //========== 构造方法 ========== 
    function EditEx(entity, viewer) {
        _classCallCheck(this, EditEx);

        var _this = _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).call(this, entity, viewer));

        _this._hasMidPoint = true; //是否可以加点 
        return _this;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(EditEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return closeCurve.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 3; //至少需要点的个数 
        _this2._maxPointNum = 999; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return closeCurve.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CloseCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//闭合曲面
var CloseCurve = exports.CloseCurve = function () {
    function CloseCurve(opt) {
        _classCallCheck(this, CloseCurve);

        if (!opt) opt = {};
        //影响因素
        this.positions = null;
        this.plotUtil = _PlotUtil.plotUtil;
    }

    _createClass(CloseCurve, [{
        key: 'startCompute',
        value: function startCompute(positions) {
            var pnts = pointconvert.cartesians2mercators(positions);
            pnts.push(pnts[0], pnts[1]);

            var normals = [];
            var pList = [];
            for (var i = 0; i < pnts.length - 2; i++) {
                var normalPoints = this.plotUtil.getBisectorNormals(0.3, pnts[i], pnts[i + 1], pnts[i + 2]);
                normals = normals.concat(normalPoints);
            }
            var count = normals.length;
            normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
            for (var _i = 0; _i < pnts.length - 2; _i++) {
                var pnt1 = pnts[_i];
                var pnt2 = pnts[_i + 1];
                pList.push(pnt1);
                for (var t = 0; t <= 100; t++) {
                    var pnt = this.plotUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);
                    pList.push(pnt);
                }
                pList.push(pnt2);
            }

            var returnArr = pointconvert.mercators2cartesians(pList);
            return returnArr;
        }
    }]);

    return CloseCurve;
}();

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _DoubleArrow = __webpack_require__(169);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//双箭头（钳击）
var drawtype = 'doubleArrow';
var doubleArrow = new _DoubleArrow.DoubleArrow();
//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    function EditEx() {
        _classCallCheck(this, EditEx);

        return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
    }

    _createClass(EditEx, [{
        key: 'getShowPositions',

        //根据标绘绘制的点，生成显示的边界点
        value: function getShowPositions(positions) {
            return doubleArrow.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 3; //至少需要点的个数 
        _this2._maxPointNum = 5; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return doubleArrow.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DoubleArrow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//计算钳击箭头坐标
var DoubleArrow = exports.DoubleArrow = function () {
    function DoubleArrow(opt) {
        _classCallCheck(this, DoubleArrow);

        if (!opt) opt = {};
        //影响因素
        this.headHeightFactor = opt.headHeightFactor || 0.25;
        this.headWidthFactor = opt.headWidthFactor || 0.3;
        this.neckHeightFactor = opt.neckHeightFactor || 0.85;
        this.neckWidthFactor = opt.neckWidthFactor || 0.15;
        this.positions = null;
        this.plotUtil = _PlotUtil.plotUtil;
    }

    _createClass(DoubleArrow, [{
        key: 'startCompute',
        value: function startCompute(positions) {
            if (!positions) return;
            this.positions = positions;

            var pnts = pointconvert.cartesians2mercators(positions);

            var _ref = [pnts[0], pnts[1], pnts[2]];
            var pnt1 = _ref[0];
            var pnt2 = _ref[1];
            var pnt3 = _ref[2];
            var count = this.positions.length;
            var tempPoint4;
            var connPoint;
            if (count === 3) {
                tempPoint4 = this.getTempPoint4(pnt1, pnt2, pnt3);
                connPoint = this.plotUtil.Mid(pnt1, pnt2);
            } else if (count === 4) {
                tempPoint4 = pnts[3];
                connPoint = this.plotUtil.Mid(pnt1, pnt2);
            } else {
                tempPoint4 = pnts[3];
                connPoint = pnts[4];
            }
            var leftArrowPnts = undefined,
                rightArrowPnts = undefined;

            if (this.plotUtil.isClockWise(pnt1, pnt2, pnt3)) {
                leftArrowPnts = this.getArrowPoints(pnt1, connPoint, tempPoint4, false);
                rightArrowPnts = this.getArrowPoints(connPoint, pnt2, pnt3, true);
            } else {
                leftArrowPnts = this.getArrowPoints(pnt2, connPoint, pnt3, false);
                rightArrowPnts = this.getArrowPoints(connPoint, pnt1, tempPoint4, true);
            }
            var m = leftArrowPnts.length;
            var t = (m - 5) / 2;
            var llBodyPnts = leftArrowPnts.slice(0, t);
            var lArrowPnts = leftArrowPnts.slice(t, t + 5);
            var lrBodyPnts = leftArrowPnts.slice(t + 5, m);
            var rlBodyPnts = rightArrowPnts.slice(0, t);
            var rArrowPnts = rightArrowPnts.slice(t, t + 5);
            var rrBodyPnts = rightArrowPnts.slice(t + 5, m);
            rlBodyPnts = this.plotUtil.getBezierPoints(rlBodyPnts);
            var bodyPnts = this.plotUtil.getBezierPoints(rrBodyPnts.concat(llBodyPnts.slice(1)));
            lrBodyPnts = this.plotUtil.getBezierPoints(lrBodyPnts);
            var newPnts = rlBodyPnts.concat(rArrowPnts, bodyPnts, lArrowPnts, lrBodyPnts);

            var returnArr = pointconvert.mercators2cartesians(newPnts);
            return returnArr;
        }
    }, {
        key: 'getTempPoint4',
        value: function getTempPoint4(linePnt1, linePnt2, point) {
            var midPnt = this.plotUtil.Mid(linePnt1, linePnt2);
            var len = this.plotUtil.MathDistance(midPnt, point);
            var angle = this.plotUtil.getAngleOfThreePoints(linePnt1, midPnt, point);
            var symPnt = undefined,
                distance1 = undefined,
                distance2 = undefined,
                mid = undefined;

            if (angle < Math.PI / 2) {
                distance1 = len * Math.sin(angle);
                distance2 = len * Math.cos(angle);
                mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
                symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
            } else if (angle >= Math.PI / 2 && angle < Math.PI) {
                distance1 = len * Math.sin(Math.PI - angle);
                distance2 = len * Math.cos(Math.PI - angle);
                mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
                symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
            } else if (angle >= Math.PI && angle < Math.PI * 1.5) {
                distance1 = len * Math.sin(angle - Math.PI);
                distance2 = len * Math.cos(angle - Math.PI);
                mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
                symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
            } else {
                distance1 = len * Math.sin(Math.PI * 2 - angle);
                distance2 = len * Math.cos(Math.PI * 2 - angle);
                mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
                symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
            }
            return symPnt;
        }
    }, {
        key: 'getArrowPoints',
        value: function getArrowPoints(pnt1, pnt2, pnt3, clockWise) {
            var midPnt = this.plotUtil.Mid(pnt1, pnt2);
            var len = this.plotUtil.MathDistance(midPnt, pnt3);
            var midPnt1 = this.plotUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.3, true);
            var midPnt2 = this.plotUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.5, true);
            midPnt1 = this.plotUtil.getThirdPoint(midPnt, midPnt1, Math.PI / 2, len / 5, clockWise);
            midPnt2 = this.plotUtil.getThirdPoint(midPnt, midPnt2, Math.PI / 2, len / 4, clockWise);
            var points = [midPnt, midPnt1, midPnt2, pnt3];
            var arrowPnts = this.getArrowHeadPoints(points);
            if (arrowPnts && Array.isArray(arrowPnts) && arrowPnts.length > 0) {
                var _ref2 = [arrowPnts[0], arrowPnts[4]],
                    neckLeftPoint = _ref2[0],
                    neckRightPoint = _ref2[1];

                var tailWidthFactor = this.plotUtil.MathDistance(pnt1, pnt2) / this.plotUtil.getBaseLength(points) / 2;
                var bodyPnts = this.getArrowBodyPoints(points, neckLeftPoint, neckRightPoint, tailWidthFactor);
                if (bodyPnts) {
                    var n = bodyPnts.length;
                    var lPoints = bodyPnts.slice(0, n / 2);
                    var rPoints = bodyPnts.slice(n / 2, n);
                    lPoints.push(neckLeftPoint);
                    rPoints.push(neckRightPoint);
                    lPoints = lPoints.reverse();
                    lPoints.push(pnt2);
                    rPoints = rPoints.reverse();
                    rPoints.push(pnt1);
                    return lPoints.reverse().concat(arrowPnts, rPoints);
                }
            } else {
                throw new Error('插值出错');
            }
        }
    }, {
        key: 'getArrowHeadPoints',
        value: function getArrowHeadPoints(points) {
            var len = this.plotUtil.getBaseLength(points);
            var headHeight = len * this.headHeightFactor;
            var headPnt = points[points.length - 1];
            var headWidth = headHeight * this.headWidthFactor;
            var neckWidth = headHeight * this.neckWidthFactor;
            var neckHeight = headHeight * this.neckHeightFactor;
            var headEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
            var neckEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
            var headLeft = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
            var headRight = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
            var neckLeft = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
            var neckRight = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
            return [neckLeft, headLeft, headPnt, headRight, neckRight];
        }
    }, {
        key: 'getArrowBodyPoints',
        value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
            var allLen = this.plotUtil.wholeDistance(points);
            var len = this.plotUtil.getBaseLength(points);
            var tailWidth = len * tailWidthFactor;
            var neckWidth = this.plotUtil.MathDistance(neckLeft, neckRight);
            var widthDif = (tailWidth - neckWidth) / 2;
            var tempLen = 0,
                leftBodyPnts = [],
                rightBodyPnts = [];

            for (var i = 1; i < points.length - 1; i++) {
                var angle = this.plotUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
                tempLen += this.plotUtil.MathDistance(points[i - 1], points[i]);
                var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
                var left = this.plotUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
                var right = this.plotUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
                leftBodyPnts.push(left);
                rightBodyPnts.push(right);
            }
            return leftBodyPnts.concat(rightBodyPnts);
        }
    }]);

    return DoubleArrow;
}();

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _FineArrow = __webpack_require__(171);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//直箭头(2个点)
var drawtype = 'fineArrow';
var fineArrow = new _FineArrow.FineArrow();
//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    function EditEx() {
        _classCallCheck(this, EditEx);

        return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
    }

    _createClass(EditEx, [{
        key: 'getShowPositions',

        //根据标绘绘制的点，生成显示的边界点
        value: function getShowPositions(positions) {
            return fineArrow.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 2; //至少需要点的个数 
        _this2._maxPointNum = 2; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return fineArrow.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FineArrow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//计算粗单尖直箭头坐标
var FineArrow = exports.FineArrow = function () {
    function FineArrow(opt) {
        _classCallCheck(this, FineArrow);

        if (!opt) opt = {};
        //影响因素
        this.headAngle = opt.headAngle || Math.PI / 8.5;
        this.neckAngle = opt.neckAngle || Math.PI / 13;
        this.tailWidthFactor = opt.tailWidthFactor || 0.1;
        this.neckWidthFactor = opt.neckWidthFactor || 0.2;
        this.headWidthFactor = opt.headWidthFactor || 0.25;
        this.neckHeightFactor = opt.neckHeightFactor || 0.85;
        this.positions = null;
        this.plotUtil = _PlotUtil.plotUtil;
    }

    _createClass(FineArrow, [{
        key: 'startCompute',
        value: function startCompute(positions) {
            if (!positions) return;
            this.positions = positions;

            var pnts = pointconvert.cartesians2mercators(positions);

            var _ref = [pnts[0], pnts[1]],
                pnt1 = _ref[0],
                pnt2 = _ref[1];
            var len = this.plotUtil.getBaseLength(pnts);
            var tailWidth = len * this.tailWidthFactor;
            var neckWidth = len * this.neckWidthFactor;
            var headWidth = len * this.headWidthFactor;
            var tailLeft = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
            var tailRight = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
            var headLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
            var headRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
            var neckLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
            var neckRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
            var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];

            var returnArr = pointconvert.mercators2cartesians(pList);
            return returnArr;
        }
    }]);

    return FineArrow;
}();

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _FineArrowYW = __webpack_require__(173);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//直箭头(2个点)
var drawtype = 'fineArrowYW';
var fineArrowYW = new _FineArrowYW.FineArrowYW();
//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    function EditEx() {
        _classCallCheck(this, EditEx);

        return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
    }

    _createClass(EditEx, [{
        key: 'getShowPositions',

        //根据标绘绘制的点，生成显示的边界点
        value: function getShowPositions(positions) {
            return fineArrowYW.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制 


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 2; //至少需要点的个数 
        _this2._maxPointNum = 2; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return fineArrowYW.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FineArrowYW = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _ArrowParent2 = __webpack_require__(38);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//计算粗单尖直箭头(带燕尾)坐标
var FineArrowYW = exports.FineArrowYW = function (_ArrowParent) {
    _inherits(FineArrowYW, _ArrowParent);

    function FineArrowYW(opt) {
        _classCallCheck(this, FineArrowYW);

        var _this = _possibleConstructorReturn(this, (FineArrowYW.__proto__ || Object.getPrototypeOf(FineArrowYW)).call(this, opt));

        if (!opt) opt = {};
        //影响因素
        _this.headHeightFactor = opt.headHeightFactor || 0.18;
        _this.headWidthFactor = opt.headWidthFactor || 0.3;
        _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
        _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
        _this.tailWidthFactor = opt.tailWidthFactor || 0.1;
        _this.swallowTailFactor = opt.swallowTailFactor || 1;
        _this.positions = null;
        _this.plotUtil = _PlotUtil.plotUtil;
        return _this;
    }

    _createClass(FineArrowYW, [{
        key: 'startCompute',
        value: function startCompute(positions) {
            if (!positions) return;
            this.positions = positions;

            var pnts = pointconvert.cartesians2mercators(positions);

            var tailPnts = this.getTailPoints(pnts);
            var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[2]);
            var neckLeft = headPnts[0];
            var neckRight = headPnts[4];
            var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
            var _count = bodyPnts.length;
            var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
            leftPnts.push(neckLeft);
            var rightPnts = [tailPnts[2]].concat(bodyPnts.slice(_count / 2, _count));
            rightPnts.push(neckRight);
            leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
            rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
            var pList = leftPnts.concat(headPnts, rightPnts.reverse(), [tailPnts[1], leftPnts[0]]);

            var returnArr = pointconvert.mercators2cartesians(pList);
            return returnArr;
        }
    }, {
        key: 'getTailPoints',
        value: function getTailPoints(points) {
            var allLen = this.plotUtil.getBaseLength(points);
            var tailWidth = allLen * this.tailWidthFactor;
            var tailLeft = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
            var tailRight = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
            var len = tailWidth * this.swallowTailFactor;
            var swallowTailPnt = this.plotUtil.getThirdPoint(points[1], points[0], 0, len, true);
            return [tailLeft, swallowTailPnt, tailRight];
        }
    }]);

    return FineArrowYW;
}(_ArrowParent2.ArrowParent);

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _GatheringPlace = __webpack_require__(175);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//集结地(3个点)
var drawtype = 'gatheringPlace';
var gatheringPlace = new _GatheringPlace.GatheringPlace();

//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    function EditEx() {
        _classCallCheck(this, EditEx);

        return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
    }

    _createClass(EditEx, [{
        key: 'getShowPositions',

        //根据标绘绘制的点，生成显示的边界点
        value: function getShowPositions(positions) {
            return gatheringPlace.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制

var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 3; //至少需要点的个数 
        _this2._maxPointNum = 3; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return gatheringPlace.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GatheringPlace = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//集结地
var GatheringPlace = exports.GatheringPlace = function () {
  function GatheringPlace(opt) {
    _classCallCheck(this, GatheringPlace);

    if (!opt) opt = {};
    //影响因素
    this.positions = null;
    this.plotUtil = _PlotUtil.plotUtil;
  }

  _createClass(GatheringPlace, [{
    key: 'startCompute',
    value: function startCompute(positions) {
      var pnts = pointconvert.cartesians2mercators(positions);

      var mid = this.plotUtil.Mid(pnts[0], pnts[2]);
      pnts.push(mid, pnts[0], pnts[1]);
      var normals = [],
          pnt1 = undefined,
          pnt2 = undefined,
          pnt3 = undefined,
          pList = [];
      for (var i = 0; i < pnts.length - 2; i++) {
        pnt1 = pnts[i];
        pnt2 = pnts[i + 1];
        pnt3 = pnts[i + 2];
        var normalPoints = this.plotUtil.getBisectorNormals(0.4, pnt1, pnt2, pnt3);
        normals = normals.concat(normalPoints);
      }
      var count = normals.length;
      normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
      for (var _i = 0; _i < pnts.length - 2; _i++) {
        pnt1 = pnts[_i];
        pnt2 = pnts[_i + 1];
        pList.push(pnt1);
        for (var t = 0; t <= 100; t++) {
          var _pnt = this.plotUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);
          pList.push(_pnt);
        }
        pList.push(pnt2);
      }

      var returnArr = pointconvert.mercators2cartesians(pList);
      return returnArr;
    }
  }]);

  return GatheringPlace;
}();

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _StraightArrow = __webpack_require__(177);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//直箭头(3个点)
var drawtype = 'straightArrow';
var straightArrow = new _StraightArrow.StraightArrow();

//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    function EditEx() {
        _classCallCheck(this, EditEx);

        return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
    }

    _createClass(EditEx, [{
        key: 'getShowPositions',

        //根据标绘绘制的点，生成显示的边界点
        value: function getShowPositions(positions) {
            return straightArrow.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制

var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 2; //至少需要点的个数 
        _this2._maxPointNum = 2; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return straightArrow.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StraightArrow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//计算粗直箭头坐标
var StraightArrow = exports.StraightArrow = function () {
    function StraightArrow(opt) {
        _classCallCheck(this, StraightArrow);

        if (!opt) opt = {};
        //影响因素
        this.tailWidthFactor = opt.tailWidthFactor || 0.05;
        this.neckWidthFactor = opt.neckWidthFactor || 0.1;
        this.headWidthFactor = opt.headWidthFactor || 0.15;
        this.headAngle = Math.PI / 4;
        this.neckAngle = Math.PI * 0.17741;
        this.positions = null;
        this.plotUtil = _PlotUtil.plotUtil;
    }

    _createClass(StraightArrow, [{
        key: 'startCompute',
        value: function startCompute(positions) {

            var pnts = pointconvert.cartesians2mercators(positions);
            var _ref = [pnts[0], pnts[1]],
                pnt1 = _ref[0],
                pnt2 = _ref[1];
            var len = this.plotUtil.getBaseLength(pnts);
            var tailWidth = len * this.tailWidthFactor;
            var neckWidth = len * this.neckWidthFactor;
            var headWidth = len * this.headWidthFactor;
            var tailLeft = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
            var tailRight = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
            var headLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
            var headRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
            var neckLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
            var neckRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
            var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];

            var returnArr = pointconvert.mercators2cartesians(pList);
            return returnArr;
        }
    }]);

    return StraightArrow;
}();

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _Lune = __webpack_require__(179);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//弓形面(3个点)
var drawtype = 'lune';
var lune = new _Lune.Lune();

//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    function EditEx() {
        _classCallCheck(this, EditEx);

        return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
    }

    _createClass(EditEx, [{
        key: 'getShowPositions',

        //根据标绘绘制的点，生成显示的边界点
        value: function getShowPositions(positions) {
            return lune.startCompute(positions);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 3; //至少需要点的个数 
        _this2._maxPointNum = 3; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return lune.startCompute(positions);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Lune = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//弓形面
var Lune = exports.Lune = function () {
    function Lune(opt) {
        _classCallCheck(this, Lune);

        if (!opt) opt = {};
        //影响因素
        this.positions = null;
        this.plotUtil = _PlotUtil.plotUtil;
    }

    _createClass(Lune, [{
        key: 'startCompute',
        value: function startCompute(positions) {

            var pnts = pointconvert.cartesians2mercators(positions);
            var _ref = [pnts[0], pnts[1], pnts[2], undefined, undefined],
                pnt1 = _ref[0],
                pnt2 = _ref[1],
                pnt3 = _ref[2],
                startAngle = _ref[3],
                endAngle = _ref[4];

            var center = this.plotUtil.getCircleCenterOfThreePoints(pnt1, pnt2, pnt3);
            var radius = this.plotUtil.MathDistance(pnt1, center);
            var angle1 = this.plotUtil.getAzimuth(pnt1, center);
            var angle2 = this.plotUtil.getAzimuth(pnt2, center);
            if (this.plotUtil.isClockWise(pnt1, pnt2, pnt3)) {
                startAngle = angle2;
                endAngle = angle1;
            } else {
                startAngle = angle1;
                endAngle = angle2;
            }
            pnts = this.plotUtil.getArcPoints(center, radius, startAngle, endAngle);
            pnts.push(pnts[0]);

            var returnArr = pointconvert.mercators2cartesians(pnts);
            return returnArr;
        }
    }]);

    return Lune;
}();

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _PlotUtil = __webpack_require__(9);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//扇形(3个点)
var drawtype = 'sector';

function getPositions(positions, attribute) {

    var pnts = pointconvert.cartesians2mercators(positions);
    var center = pnts[0],
        pnt2 = pnts[1],
        pnt3 = pnts[2];
    var radius = _PlotUtil.plotUtil.MathDistance(pnt2, center);
    var startAngle = _PlotUtil.plotUtil.getAzimuth(pnt2, center);
    var endAngle = _PlotUtil.plotUtil.getAzimuth(pnt3, center);
    var pList = _PlotUtil.plotUtil.getArcPoints(center, radius, startAngle, endAngle);
    pList.push(center, pList[0]);

    var returnArr = pointconvert.mercators2cartesians(pList);
    return returnArr;
}

//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    function EditEx() {
        _classCallCheck(this, EditEx);

        return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
    }

    _createClass(EditEx, [{
        key: 'getShowPositions',

        //根据标绘绘制的点，生成显示的边界点
        value: function getShowPositions(positions) {
            return getPositions(positions, attribute);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制 


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 3; //至少需要点的个数 
        _this2._maxPointNum = 3; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return getPositions(positions, attribute);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _matrix = __webpack_require__(17);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//正多边形  边数取决于config.border
var drawtype = 'regular';

function getPositions(positions, attribute) {
    var center = positions[0];
    var point = positions[1];
    var num = attribute.config.border || 3; //边数量

    var addAngle = 360 / num;

    var pointArr = [];
    for (var i = 0; i < num; i++) {
        var thisAngle = addAngle * i;
        var newPoint = (0, _matrix.getRotateCenterPoint)(center, point, thisAngle);
        pointArr.push(newPoint);
    }
    return pointArr;
}

//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    function EditEx() {
        _classCallCheck(this, EditEx);

        return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
    }

    _createClass(EditEx, [{
        key: 'getShowPositions',

        //根据标绘绘制的点，生成显示的边界点
        value: function getShowPositions(positions) {
            return getPositions(positions, attribute);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 2; //至少需要点的个数 
        _this2._maxPointNum = 2; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return getPositions(positions, attribute);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(10);

var _Edit = __webpack_require__(11);

var _Draw2 = __webpack_require__(6);

var _util = __webpack_require__(1);

var _matrix = __webpack_require__(17);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//等腰三角形(3个点) 
var drawtype = 'triangleDY';

var midPoint = new Cesium.Cartesian3();

function getPositions(positions) {
    //p1 p2 用于控制腰的高度 p3用于控制夹角
    var p1 = positions[0];
    var p2 = positions[1];
    var p3 = positions[2];

    var midpoint = Cesium.Cartesian3.midpoint(p1, p2, midPoint);

    var angle1 = (0, _util.getAngle)(midpoint, p2);
    var angle2 = (0, _util.getAngle)(midpoint, p3);
    var angle = angle1 - angle2 - 90;
    var newPoint2 = (0, _matrix.getRotateCenterPoint)(midpoint, p3, angle);

    return [p1, p2, newPoint2];
}

//编辑

var EditEx = function (_EditPolygonEx) {
    _inherits(EditEx, _EditPolygonEx);

    function EditEx() {
        _classCallCheck(this, EditEx);

        return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
    }

    _createClass(EditEx, [{
        key: 'getShowPositions',

        //根据标绘绘制的点，生成显示的边界点
        value: function getShowPositions(positions) {
            return getPositions(positions, attribute);
        }
    }]);

    return EditEx;
}(_Edit.EditPolygonEx);

//绘制 


var DrawEx = function (_DrawPolygonEx) {
    _inherits(DrawEx, _DrawPolygonEx);

    //========== 构造方法 ========== 
    function DrawEx(opts) {
        _classCallCheck(this, DrawEx);

        var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

        _this2.type = drawtype;
        _this2.editClass = EditEx; //获取编辑对象

        _this2._minPointNum = 3; //至少需要点的个数 
        _this2._maxPointNum = 3; //最多允许点的个数 
        return _this2;
    }
    //根据标绘绘制的点，生成显示的边界点


    _createClass(DrawEx, [{
        key: 'getShowPositions',
        value: function getShowPositions(positions) {
            return getPositions(positions, attribute);
        }
    }]);

    return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawEx = exports.FeatureEx = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DivPoint = __webpack_require__(87);

var _Draw = __webpack_require__(24);

var _Draw2 = __webpack_require__(6);

var _Tooltip = __webpack_require__(7);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//div点
var drawtype = 'div-point';

//与entity的联动矢量对象

var FeatureEx = exports.FeatureEx = function () {
    function FeatureEx(options) {
        _classCallCheck(this, FeatureEx);

        var entity = options.entity;

        var divpoint = new _DivPoint.DivPoint(options.viewer, _extends({
            position: entity.position
        }, (0, _DivPoint.style2Entity)(options.style), {
            click: function click(e) {
                if (Cesium.defined(entity.hasDrawEdit) && !entity.hasDrawEdit()) return;

                divpoint.enable = false;

                options.activate(entity);
                entity.draw_tooltip = _Tooltip.message.edit.end;
            }
        }));
        divpoint.enable = false;
        this.target = divpoint;
    }

    _createClass(FeatureEx, [{
        key: 'activate',
        value: function activate() {
            this.target.enable = false;
        }
    }, {
        key: 'updateStyle',
        value: function updateStyle(style) {
            var newStyle = (0, _DivPoint.style2Entity)(style);
            for (var key in newStyle) {
                if (key == "html") continue;
                this.target[key] = newStyle[key];
            }
        }
    }, {
        key: 'finish',
        value: function finish() {
            this.target.enable = true;
            // this.target.tooltip = '单击后 激活编辑' //message.edit.start
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.target.destroy();
        }
    }, {
        key: 'position',
        get: function get() {
            return this.target.position;
        },
        set: function set(val) {
            this.target.position = val;
        }
    }]);

    return FeatureEx;
}();

var DrawEx = exports.DrawEx = function (_DrawPoint) {
    _inherits(DrawEx, _DrawPoint);

    function DrawEx() {
        _classCallCheck(this, DrawEx);

        return _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).apply(this, arguments));
    }

    _createClass(DrawEx, [{
        key: 'createFeatureEx',
        value: function createFeatureEx(style, entity) {
            var that = this;
            if (entity.featureEx) {
                entity.featureEx.activate();
            } else {
                entity.point.show = false;
                entity.featureEx = new FeatureEx({
                    viewer: this.viewer,
                    entity: entity,
                    style: style,
                    activate: function activate(entity) {
                        that.activate(entity);
                    }
                });
            }
        }
    }]);

    return DrawEx;
}(_Draw.DrawPoint);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(8);

var _Draw = __webpack_require__(45);

var _Draw2 = __webpack_require__(6);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//div点（转图片）
var drawtype = 'div-point-img';

var DrawEx = exports.DrawEx = function (_DrawBillboard) {
    _inherits(DrawEx, _DrawBillboard);

    function DrawEx() {
        _classCallCheck(this, DrawEx);

        return _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).apply(this, arguments));
    }

    _createClass(DrawEx, [{
        key: 'updateFeatureEx',

        //更新图标，子类用
        value: function updateFeatureEx(style, entity) {
            var that = this;

            var div = (0, _zepto.zepto)(style.html);
            div.appendTo(style.parent || 'body');

            div = div.get(0);

            this._islosdImg = true;
            if (window.domtoimage) {
                //lib/dom2img/dom-to-image.js
                domtoimage.toPng(div).then(function (dataUrl) {
                    entity.billboard.image = "" + dataUrl;

                    div.remove();
                    that._islosdImg = false;
                }).catch(function (error) {
                    marslog.warn('未知原因，导出失败!', error);

                    div.remove();
                    that._islosdImg = false;
                });
            } else if (window.html2canvas) {
                //lib/dom2img/html2canvas.js
                html2canvas(div, {
                    backgroundColor: null,
                    allowTaint: true
                }).then(function (canvas) {
                    entity.billboard.image = "" + canvas.toDataURL("image/png");

                    div.remove();
                    that._islosdImg = false;
                }).catch(function (error) {
                    marslog.warn('未知原因，导出失败!', error);

                    div.remove();
                    that._islosdImg = false;
                });;
            }
        }
    }]);

    return DrawEx;
}(_Draw.DrawBillboard);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(45);

var _Draw2 = __webpack_require__(6);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//字体点（转图片）
var drawtype = 'font-point';

var DrawEx = exports.DrawEx = function (_DrawBillboard) {
    _inherits(DrawEx, _DrawBillboard);

    function DrawEx() {
        _classCallCheck(this, DrawEx);

        return _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).apply(this, arguments));
    }

    _createClass(DrawEx, [{
        key: 'updateFeatureEx',

        //更新图标，子类用
        value: function updateFeatureEx(style, entity) {
            var that = this;

            var size = Cesium.defaultValue(style.iconSize, 50);

            var div = document.createElement("div"); //创建一个div
            div.setAttribute('style', 'padding: 10px;text-align:center;max-width:' + (size + 10) + 'px;max-height:' + (size + 10) + 'px;');
            var jd = document.createElement("i");
            jd.setAttribute("class", Cesium.defaultValue(style.iconClass, "fa fa-automobile"));
            jd.setAttribute('style', 'font-size:' + size + 'px;color:' + style.color + ';');
            div.appendChild(jd);
            document.body.appendChild(div);

            this._islosdImg = true;
            if (window.domtoimage) {
                //lib/dom2img/dom-to-image.js
                domtoimage.toPng(div).then(function (dataUrl) {
                    entity.billboard.image = "" + dataUrl;

                    document.body.removeChild(div);
                    that._islosdImg = false;
                }).catch(function (error) {
                    marslog.warn('未知原因，导出失败!', error);

                    document.body.removeChild(div);
                    that._islosdImg = false;
                });
            } else if (window.html2canvas) {
                //lib/dom2img/html2canvas.js
                html2canvas(div, {
                    backgroundColor: null,
                    allowTaint: true
                }).then(function (canvas) {
                    entity.billboard.image = "" + canvas.toDataURL("image/png");

                    document.body.removeChild(div);
                    that._islosdImg = false;
                }).catch(function (error) {
                    marslog.warn('未知原因，导出失败!', error);

                    document.body.removeChild(div);
                    that._islosdImg = false;
                });
            }
        }
    }]);

    return DrawEx;
}(_Draw.DrawBillboard);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawP = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

exports.registerP = registerP;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _util = __webpack_require__(1);

var util = _interopRequireWildcard(_util);

var _point = __webpack_require__(2);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _Tooltip = __webpack_require__(7);

var _index = __webpack_require__(20);

var attr = _interopRequireWildcard(_index);

var _DrawP = __webpack_require__(88);

var _DrawP2 = __webpack_require__(187);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//类库外部扩展的类
var exDraw = {};
function registerP(type, layerClass) {
    exDraw[type] = layerClass;
}

//绘制primitive类型

var DrawP = exports.DrawP = function (_MarsClass) {
    _inherits(DrawP, _MarsClass);

    //========== 构造方法 ========== 
    function DrawP(viewer, options) {
        _classCallCheck(this, DrawP);

        var _this = _possibleConstructorReturn(this, (DrawP.__proto__ || Object.getPrototypeOf(DrawP)).call(this));

        _this.viewer = viewer;
        _this.options = options || {};

        _this.dataSource = new Cesium.CustomDataSource(); //用于编辑辅助点
        _this.viewer.dataSources.add(_this.dataSource);

        _this.primitives = new Cesium.PrimitiveCollection(); //用于primitive
        _this.viewer.scene.primitives.add(_this.primitives);

        if (Cesium.defaultValue(_this.options.removeScreenSpaceEvent, true)) {
            _this.viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
            _this.viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }

        _this.tooltip = new _Tooltip.Tooltip(_this.viewer.container); //鼠标提示信息

        _this.hasEdit(Cesium.defaultValue(_this.options.hasEdit, true)); //是否可编辑


        //编辑工具初始化
        var _opts = {
            viewer: _this.viewer,
            dataSource: _this.dataSource,
            primitives: _this.primitives,
            tooltip: _this.tooltip
        };

        //primitive
        _this.drawCtrl = {};
        _this.drawCtrl['model'] = new _DrawP2.DrawPModel(_opts);

        //外部图层
        for (var key in exDraw) {
            _this.drawCtrl[key] = new exDraw[key](_opts);
        }

        //绑定事件抛出方法
        var that = _this;
        for (var type in _this.drawCtrl) {
            _this.drawCtrl[type]._fire = function (type, data, propagate) {
                that.fire(type, data, propagate);
            };
        }

        _this.isContinued = Cesium.defaultValue(_this.options.isContinued, false);
        _this.isAutoEditing = Cesium.defaultValue(_this.options.isAutoEditing, true);
        _this.on(_MarsClass2.eventType.drawCreated, function (e) {
            var _this2 = this;

            setTimeout(function () {
                if (_this2.isContinued) {
                    //连续标绘时
                    _this2.stopDraw();
                    _this2.startDraw(_this2._last_attribute, _this2._last_drawOkCallback);
                } else if (_this2.isAutoEditing) {
                    //创建完成后激活编辑 
                    _this2.startEditing(e.entity);
                }
            }, 50);
        }, _this);
        return _this;
    }
    //========== 对外属性 ==========  


    _createClass(DrawP, [{
        key: 'startDraw',


        //==========分组相关==========
        // addGroup


        //==========绘制相关==========
        value: function startDraw(attribute, drawOkCallback) {
            //参数是字符串id或uri时
            if (typeof attribute === 'string') {
                attribute = { type: attribute };
            } else {
                if (attribute == null || attribute.type == null) {
                    marslog.warn('需要传入指定绘制的type类型！');
                    return;
                }
            }

            var type = attribute.type;
            if (this.drawCtrl[type] == null) {
                marslog.warn('不能进行type为【' + type + '】的绘制，无该类型！');
                return;
            }

            if (!drawOkCallback && attribute.success) {
                drawOkCallback = attribute.success;
                delete attribute.success;
            }
            this._last_drawOkCallback = drawOkCallback;
            this._last_attribute = attribute;

            //赋默认值  
            attribute = attr.addGeoJsonDefVal(attribute);

            this.stopDraw();
            var entity = this.drawCtrl[type].activate(attribute, drawOkCallback);
            this.bindDeleteContextmenu(entity);
            return entity;
        }
        //对已经绘制完成的entity，重新激活开始编辑[目前仅支持polyline、polygon]

    }, {
        key: 'restartDraw',
        value: function restartDraw(entity, drawOkCallback) {
            var attribute = entity.attribute;
            var type = attribute.type;
            if (this.drawCtrl[type] == null) {
                marslog.warn('不能进行type为【' + type + '】的绘制，无该类型！');
                return;
            }

            if (!drawOkCallback && attribute.success) {
                drawOkCallback = attribute.success;
                delete attribute.success;
            }
            this._last_drawOkCallback = drawOkCallback;
            this._last_attribute = attribute;

            this.stopDraw();
            var entity = this.drawCtrl[type].activate(entity, drawOkCallback);
            return entity;
        }
        //是否还在绘制中

    }, {
        key: 'hasDrawing',
        value: function hasDrawing() {
            for (var type in this.drawCtrl) {
                if (this.drawCtrl[type]._enabled) return true;
            }
            return false;
        }
        //外部控制，完成绘制，比如手机端无法双击结束

    }, {
        key: 'endDraw',
        value: function endDraw() {
            for (var type in this.drawCtrl) {
                if (this.drawCtrl[type].endDraw) this.drawCtrl[type].endDraw();
            }
            return this;
        }
    }, {
        key: 'stopDraw',
        value: function stopDraw() {
            this.stopEditing();
            for (var type in this.drawCtrl) {
                this.drawCtrl[type].disable(true);
            }
            return this;
        }
    }, {
        key: 'clearDraw',
        value: function clearDraw() {
            //删除所有
            this.stopDraw();

            var arrEntity = this.getEntitys();
            for (var i = 0, len = arrEntity.length; i < len; i++) {
                var entity = arrEntity[i];
                if (entity.editing) {
                    entity.editing.destroy();
                    delete entity.editing;
                }
            }
            this.dataSource.entities.removeAll();
            this.primitives.removeAll();

            return this;
        }
    }, {
        key: 'closeTooltip',
        value: function closeTooltip() {
            if (!this.tooltip) return;

            this.tooltip.setVisible(false);
            if (this.tiptimeTik) {
                clearTimeout(this.tiptimeTik);
                delete this.tiptimeTik;
            }
        }
        //==========编辑相关==========
        // currEditFeature: null,      //当前编辑的要素  

    }, {
        key: 'getCurrentEntity',
        value: function getCurrentEntity() {
            return this.currEditFeature;
        }
        // _hasEdit: null,

    }, {
        key: 'hasEdit',
        value: function hasEdit(val) {
            if (this._hasEdit !== null && this._hasEdit === val) return;

            this._hasEdit = val;
            if (val) {
                this.bindSelectEvent();
            } else {
                this.stopEditing();
                this.destroySelectEvent();
            }
        }
        //绑定鼠标选中事件

    }, {
        key: 'bindSelectEvent',
        value: function bindSelectEvent() {
            var _this3 = this;

            //选取对象
            var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
            handler.setInputAction(function (event) {
                var pickedObject = _this3.viewer.scene.pick(event.position, 5, 5);
                if (Cesium.defined(pickedObject)) {
                    var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;

                    if (_this3.hasDrawing()) return; //还在绘制中时，跳出
                    if (_this3.currEditFeature && _this3.currEditFeature === entity) return; //重复单击了跳出
                    if (!Cesium.defaultValue(entity.hasEdit, true)) return; //如果设置了不可编辑跳出

                    if (entity && _this3.isMyEntity(entity)) {
                        if (!Cesium.defaultValue(entity.inProgress, false)) {
                            _this3.startEditing(entity);
                            _this3.closeTooltip();
                            if (entity.draw_tooltip) {
                                _this3.tooltip.showAt(event.position, entity.draw_tooltip);
                            }
                            return;
                        }
                    }
                }
                _this3.stopEditing();
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

            //编辑提示事件
            handler.setInputAction(function (event) {
                if (!_this3._hasEdit) return;

                //还在绘制中时，跳出
                if (_this3.hasDrawing()) return;

                //正在拖拽其他的entity时，跳出
                if (!_this3.viewer.scene.screenSpaceCameraController.enableInputs) return;

                _this3.closeTooltip();

                var pickedObject = _this3.viewer.scene.pick(event.endPosition, 5, 5);
                if (Cesium.defined(pickedObject)) {
                    var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;
                    if (entity && entity.editing && !Cesium.defaultValue(entity.inProgress, false) && _this3.isMyEntity(entity)) {
                        var tooltip = _this3.tooltip;

                        //删除右键菜单打开了不显示tooltip
                        if (_this3.viewer.mars.contextmenu && _this3.viewer.mars.contextmenu.show && _this3.viewer.mars.contextmenu.target == entity) return;

                        _this3.tiptimeTik = setTimeout(function () {
                            //edit中的MOUSE_MOVE会关闭提示，延迟执行。
                            tooltip.showAt(event.endPosition, _Tooltip.message.edit.start);
                        }, 100);
                    }
                }
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

            this.selectHandler = handler;
        }
    }, {
        key: 'destroySelectEvent',
        value: function destroySelectEvent() {
            this.selectHandler && this.selectHandler.destroy();
            this.selectHandler = undefined;
        }
    }, {
        key: 'startEditing',
        value: function startEditing(entity) {
            this.stopEditing();
            if (entity == null || !this._hasEdit) return;

            if (entity.editing && entity.editing.activate) {
                entity.editing.activate();
            }
            this.currEditFeature = entity;
        }
    }, {
        key: 'stopEditing',
        value: function stopEditing() {
            this.closeTooltip();
            if (this.currEditFeature && this.currEditFeature.editing && this.currEditFeature.editing.disable) {
                this.currEditFeature.editing.disable();
            }
            this.currEditFeature = null;
        }
        //修改了属性

    }, {
        key: 'updateAttribute',
        value: function updateAttribute(attribute, entity) {
            if (entity == null) entity = this.currEditFeature;
            if (entity == null || attribute == null) return;

            attribute.style = attribute.style || {};
            attribute.attr = attribute.attr || {};

            //更新属性
            var type = entity.attribute.type;
            this.drawCtrl[type].style2Entity(attribute.style, entity);
            entity.attribute = attribute;

            //如果在编辑状态，更新绑定的拖拽点
            if (entity.editing) {
                if (entity.editing.updateAttrForEditing) entity.editing.updateAttrForEditing();

                if (entity.editing.updateDraggers) entity.editing.updateDraggers();
            }

            //名称 绑定到tooltip 
            if (this.options.nameTooltip) {
                var that = this;
                if (entity.attribute.attr && entity.attribute.attr.name) {
                    entity.tooltip = {
                        html: entity.attribute.attr.name,
                        visible: function visible() {
                            return !that._hasEdit;
                        }
                    };
                } else {
                    entity.tooltip = null;
                }
            }
            return entity;
        }
    }, {
        key: 'updateStyle',
        value: function updateStyle(style, entity) {
            if (entity == null) entity = this.currEditFeature;
            if (entity == null) return;

            var type = entity.attribute.type;

            var oldstyle = entity.attribute.style || {};
            for (var key in style) {
                oldstyle[key] = style[key];
            }
            this.drawCtrl[type].style2Entity(oldstyle, entity);
        }

        //修改坐标、高程

    }, {
        key: 'setPositions',
        value: function setPositions(positions, entity) {
            if (entity == null) entity = this.currEditFeature;
            if (entity == null || positions == null) return;

            //如果在编辑状态，更新绑定的拖拽点
            if (entity.editing) {
                entity.editing.setPositions(positions);
                entity.editing.updateDraggers();
            }
            return entity;
        }
        //==========删除相关========== 
        //右键菜单

    }, {
        key: 'bindDeleteContextmenu',
        value: function bindDeleteContextmenu(entity) {
            var that = this;
            entity.contextmenuItems = entity.contextmenuItems || [];
            entity.contextmenuItems.push({
                text: '删除对象',
                iconCls: 'fa fa-trash-o',
                visible: function visible(e) {
                    that.closeTooltip();

                    var entity = e.target;
                    if (entity.inProgress && !entity.editing) return false;

                    if (Cesium.defined(that.options.hasDel)) return that._hasEdit && that.options.hasDel(e);else return that._hasEdit;
                },
                callback: function callback(e) {
                    var entity = e.target;

                    if (entity.editing && entity.editing.disable) {
                        entity.editing.disable();
                    }
                    that.deleteEntity(entity);
                }
            });
        }
        //删除单个

    }, {
        key: 'deleteEntity',
        value: function deleteEntity(entity) {
            if (entity == null) entity = this.currEditFeature;
            if (entity == null) return;

            if (entity.editing) {
                entity.editing.destroy();
                delete entity.editing;
            }

            if (this.primitives.contains(entity)) this.primitives.remove(entity);

            this.fire(_MarsClass2.eventType.delete, { entity: entity });
        }
    }, {
        key: 'remove',
        value: function remove(entity) {
            //兼容不同习惯命名
            return this.deleteEntity(entity);
        }
        //是否为当前编辑器编辑的标号

    }, {
        key: 'isMyEntity',
        value: function isMyEntity(entity) {
            if (this.primitives.contains(entity)) return true;
            return false;
        }
        //删除所有

    }, {
        key: 'deleteAll',
        value: function deleteAll() {
            //兼容不同习惯命名
            this.clearDraw();
        }
    }, {
        key: 'removeAll',
        value: function removeAll() {
            //兼容不同习惯命名
            this.clearDraw();
        }
        //==========转换GeoJSON==========
        //转换当前所有为geojson

    }, {
        key: 'toGeoJSON',
        value: function toGeoJSON(entity) {
            this.stopDraw();

            if (entity == null) {
                //全部数据 
                var arrEntity = this.getEntitys();
                if (arrEntity.length == 0) return null;

                var features = [];
                for (var i = 0, len = arrEntity.length; i < len; i++) {
                    var entity = arrEntity[i];
                    if (entity.attribute == null || entity.attribute.type == null) continue;

                    var type = entity.attribute.type;
                    var geojson = this.drawCtrl[type].toGeoJSON(entity);
                    if (geojson == null) continue;
                    geojson = attr.removeGeoJsonDefVal(geojson);

                    features.push(geojson);
                }
                if (features.length > 0) return { type: "FeatureCollection", features: features };else return null;
            } else {
                var type = entity.attribute.type;
                var geojson = this.drawCtrl[type].toGeoJSON(entity);
                geojson = attr.removeGeoJsonDefVal(geojson);
                return geojson;
            }
        }
        //加载goejson数据

    }, {
        key: 'jsonToEntity',
        value: function jsonToEntity(json, isClear, isFly) {
            //兼容旧版本方法名
            return this.loadJson(json, {
                clear: isClear,
                flyTo: isFly
            });
        }
    }, {
        key: 'loadJson',
        value: function loadJson(json, opts) {
            opts = opts || {};

            var jsonObjs = json;
            try {
                if (util.isString(json)) jsonObjs = JSON.parse(json);
            } catch (e) {
                util.alert(e.name + ": " + e.message + " \n请确认json文件格式正确!!!");
                return;
            }

            if (opts.clear) {
                this.clearDraw();
            }

            var arrthis = [];
            var jsonFeatures = jsonObjs.features ? jsonObjs.features : [jsonObjs];

            for (var i = 0, len = jsonFeatures.length; i < len; i++) {
                var feature = jsonFeatures[i];

                if (!feature.properties || !feature.properties.type) {
                    //非本身保存的外部其他geojson数据
                    feature.properties = feature.properties || {};
                    switch (feature.geometry.type) {
                        case "MultiPolygon":
                        case "Polygon":
                            feature.properties.type = "polygon";
                            break;
                        case "MultiLineString":
                        case "LineString":
                            feature.properties.type = "polyline";
                            break;
                        case "MultiPoint":
                        case "Point":
                            feature.properties.type = "point";
                            break;
                    }
                }
                feature.properties.style = opts.style || feature.properties.style || {};
                feature.properties.attr = feature.properties.attr || {};

                if (opts.onEachFeature) //添加到地图前 回调方法
                    opts.onEachFeature(feature, feature.properties.type, i);

                var type = feature.properties.type;
                if (this.drawCtrl[type] == null) {
                    marslog.warn('数据无法识别或者数据的[' + type + ']类型参数有误');
                    continue;
                }

                var entity = this.getEntityById(feature.properties.attr.id);
                if (entity) {
                    this.updateStyle(feature.properties.style, entity);

                    var positions = (0, _point.getPositionByGeoJSON)(feature);
                    if (positions) this.setPositions(positions, entity);
                } else {
                    entity = this.addFeature(type, feature);
                }

                if (opts.onEachEntity) //添加到地图后回调方法
                    opts.onEachEntity(feature, entity, i);

                arrthis.push(entity);
            }

            if (opts.flyTo) {
                this.viewer.mars.flyTo(arrthis);
            }

            return arrthis;
        }

        //外部添加billboard点数据

    }, {
        key: 'addBillboard',
        value: function addBillboard(point, style) {
            if (point instanceof Cesium.Cartesian3) {
                point = pointconvert.cartesian2lonlat(point);
            }
            var type = 'billboard';

            var feature = {
                type: "Feature",
                properties: { style: style },
                geometry: { type: "Point", coordinates: point }
            };

            var entity = this.addFeature(type, feature);
            return entity;
        }
        //外部添加billboard点数据

    }, {
        key: 'addPoint',
        value: function addPoint(point, style) {
            if (point instanceof Cesium.Cartesian3) {
                point = pointconvert.cartesian2lonlat(point);
            }

            var type = 'point';

            var feature = {
                type: "Feature",
                properties: { style: style },
                geometry: { type: "Point", coordinates: point }
            };

            var entity = this.addFeature(type, feature);
            return entity;
        }
        //外部添加线数据

    }, {
        key: 'addPolyline',
        value: function addPolyline(coordinates, style) {
            var type = 'polyline';

            var feature = {
                type: "Feature",
                properties: { style: style },
                geometry: {
                    type: "LineString",
                    coordinates: coordinates
                }
            };

            var entity = this.addFeature(type, feature);
            return entity;
        }
        //外部添加面数据

    }, {
        key: 'addPolygon',
        value: function addPolygon(coordinates, style) {
            var type = 'polygon';

            var feature = {
                type: "Feature",
                properties: { style: style },
                geometry: {
                    type: "Polygon",
                    coordinates: [coordinates]
                }
            };

            var entity = this.addFeature(type, feature);
            return entity;
        }
        //外部添加数据（内部使用的）

    }, {
        key: 'addFeature',
        value: function addFeature(type, feature) {
            feature.properties.type = type;
            feature.properties.style = feature.properties.style || {};

            //赋默认值  
            feature.properties = attr.addGeoJsonDefVal(feature.properties);

            var entity = this.drawCtrl[type].jsonToEntity(feature);
            this.bindDeleteContextmenu(entity);

            //名称 绑定到tooltip
            if (this.options.nameTooltip) {
                if (entity.attribute.attr && entity.attribute.attr.name) {
                    var that = this;
                    entity.tooltip = {
                        html: entity.attribute.attr.name,
                        visible: function visible() {
                            return !that._hasEdit;
                        }
                    };
                } else {
                    entity.tooltip = null;
                }
            }

            return entity;
        }
        //属性转entity

    }, {
        key: 'attributeToEntity',
        value: function attributeToEntity(attribute, positions) {
            var entity = this.drawCtrl[attribute.type].attributeToEntity(attribute, positions);
            this.bindDeleteContextmenu(entity);

            //名称 绑定到tooltip
            if (this.options.nameTooltip) {
                if (entity.attribute.attr && entity.attribute.attr.name) {
                    var that = this;
                    entity.tooltip = {
                        html: entity.attribute.attr.name,
                        visible: function visible() {
                            return !that._hasEdit;
                        }
                    };
                } else {
                    entity.tooltip = null;
                }
            }
            return entity;
        }

        // //绑定外部非Draw产生的entity到标绘
        // bindExtraEntity(entity, attribute) {
        //     attribute = attribute || {};
        //     attribute.type = attribute.type || attr.getTypeName(entity);
        //     attribute.style = attribute.style || {};
        //     // attribute = attr.addGeoJsonDefVal(attribute);

        //     var entity = this.drawCtrl[attribute.type].bindExtraEntity(entity, attribute);
        //     this.bindDeleteContextmenu(entity);

        //     entity.entityCollection.remove(entity);//从原有的集合中删除 
        //     this.dataSource.entities.add(entity);//加入到draw集合图层中
        // }
        //==========对外接口========== 

    }, {
        key: 'setVisible',
        value: function setVisible(visible) {
            this._visible = visible;
            if (!visible) {
                this.stopDraw();
            }

            this.dataSource.show = visible;
            this.primitives.show = visible;
        }
        //是否存在绘制

    }, {
        key: 'hasDraw',
        value: function hasDraw() {
            return this.getEntitys().length > 0;
        }
        //获取所有绘制的实体对象列表

    }, {
        key: 'getEntitys',
        value: function getEntitys(noStop) {
            if (!noStop) this.stopDraw();

            var arr = this.primitives._primitives;
            return arr;
        }
        // getDataSource() {
        //     return this.dataSource;
        // }

    }, {
        key: 'getEntityById',
        value: function getEntityById(id) {
            if (!id) return null;

            var arrEntity = this.getEntitys();
            for (var i = 0, len = arrEntity.length; i < len; i++) {
                var entity = arrEntity[i];
                if (id == entity.attribute.attr.id) {
                    return entity;
                }
            }
            return null;
        }
        //获取实体的经纬度值 坐标数组

    }, {
        key: 'getCoordinates',
        value: function getCoordinates(entity) {
            var type = entity.attribute.type;
            var coor = this.drawCtrl[type].getCoordinates(entity);
            return coor;
        }
        //获取实体的坐标数组

    }, {
        key: 'getPositions',
        value: function getPositions(entity) {
            var type = entity.attribute.type;
            var positions = this.drawCtrl[type].getPositions(entity);
            return positions;
        }
    }, {
        key: 'flyTo',
        value: function flyTo(entity, opts) {
            this.viewer.mars.flyTo(entity, opts);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.stopDraw();
            this.hasEdit(false);

            for (var type in this.drawCtrl) {
                this.drawCtrl[type].destroy();
            }
            delete this.drawCtrl;
            this.clearDraw();

            if (this.viewer.dataSources.contains(this.dataSource)) {
                this.viewer.dataSources.remove(this.dataSource, true);
            }
            delete this.dataSource;

            if (this.viewer.scene.primitives.contains(this.primitives)) {
                this.viewer.scene.primitives.remove(this.primitives);
            }
            delete this.primitives;

            this.tooltip.destroy();
            _get(DrawP.prototype.__proto__ || Object.getPrototypeOf(DrawP.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'visible',
        get: function get() {
            return this.getVisible();
        },
        set: function set(val) {
            this.setVisible(val);
        }
    }, {
        key: 'edit',
        get: function get() {
            return this._hasEdit;
        },
        set: function set(val) {
            this.hasEdit(val);
        }

        //是否还在绘制中

    }, {
        key: 'drawing',
        get: function get() {
            return this.hasDrawing();
        }
    }, {
        key: 'entitys',
        get: function get() {
            return this.getEntitys();
        }
    }]);

    return DrawP;
}(_MarsClass2.MarsClass);

//绑定到draw，方便外部使用


DrawP.Base = _DrawP.DrawPBase;
DrawP.Model = _DrawP2.DrawPModel;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrawPModel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(31);

var attr = _interopRequireWildcard(_Attr);

var _Tooltip = __webpack_require__(7);

var _DrawP = __webpack_require__(88);

var _EditP = __webpack_require__(89);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPModel = exports.DrawPModel = function (_DrawPBase) {
    _inherits(DrawPModel, _DrawPBase);

    //========== 构造方法 ========== 
    function DrawPModel(opts) {
        _classCallCheck(this, DrawPModel);

        var _this = _possibleConstructorReturn(this, (DrawPModel.__proto__ || Object.getPrototypeOf(DrawPModel)).call(this, opts));

        _this.type = 'point';
        _this.attrClass = attr; //对应的属性控制静态类 
        _this.editClass = _EditP.EditPModel; //获取编辑对象 
        return _this;
    }

    //根据attribute参数创建Entity


    _createClass(DrawPModel, [{
        key: 'createFeature',
        value: function createFeature(attribute) {
            var _this2 = this;

            this._positions_draw = Cesium.Cartesian3.ZERO;

            //绘制时，是否自动隐藏模型，可避免拾取坐标存在问题。
            var _drawShow = Cesium.defaultValue(attribute.drawShow, false);

            var style = attribute.style;

            var modelPrimitive = this.primitives.add(Cesium.Model.fromGltf({
                url: style.modelUrl,
                modelMatrix: this.getModelMatrix(style),
                minimumPixelSize: Cesium.defaultValue(style.minimumPixelSize, 0.0),
                scale: Cesium.defaultValue(style.scale, 1.0),
                show: _drawShow
            }));
            modelPrimitive.loadOk = false;
            modelPrimitive.readyPromise.then(function (model) {
                model.loadOk = true;

                //播放动画
                // model.activeAnimations.addAll({
                //     loop : Cesium.ModelAnimationLoop.REPEAT, 
                // }); 

                _this2.style2Entity(style, model);
                _this2.fire(_MarsClass.eventType.load, { drawtype: _this2.type, entity: model, model: model });
            });
            modelPrimitive.attribute = attribute;
            modelPrimitive._drawShow = _drawShow;
            this.entity = modelPrimitive;

            return this.entity;
        }
    }, {
        key: 'getModelMatrix',
        value: function getModelMatrix(cfg, position) {
            var hpRoll = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(cfg.heading || 0), Cesium.Math.toRadians(cfg.pitch || 0), Cesium.Math.toRadians(cfg.roll || 0));
            var fixedFrameTransform = Cesium.Transforms.eastNorthUpToFixedFrame;

            var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(position || this._positions_draw, hpRoll, this.viewer.scene.globe.ellipsoid, fixedFrameTransform);
            // Cesium.Matrix4.multiplyByUniformScale(modelMatrix, Cesium.defaultValue(cfg.scale, 1), modelMatrix);
            return modelMatrix;
        }
    }, {
        key: 'style2Entity',
        value: function style2Entity(style, entity) {
            entity.modelMatrix = this.getModelMatrix(style, entity.position);
            return attr.style2Entity(style, entity);
        }
        //绑定鼠标事件

    }, {
        key: 'bindEvent',
        value: function bindEvent() {
            var _this3 = this;

            this.getHandler().setInputAction(function (event) {
                var point = (0, _point.getCurrentMousePosition)(_this3.viewer.scene, event.endPosition, _this3.entity);
                if (point) {
                    _this3._positions_draw = point;
                    _this3.entity.modelMatrix = _this3.getModelMatrix(_this3.entity.attribute.style);
                }
                _this3.tooltip.showAt(event.endPosition, _Tooltip.message.draw.point.start);
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

            this.getHandler().setInputAction(function (event) {
                var point = (0, _point.getCurrentMousePosition)(_this3.viewer.scene, event.position, _this3.entity);
                if (point) {
                    _this3._positions_draw = point;
                    _this3.disable();
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }
        //图形绘制结束,更新属性

    }, {
        key: 'finish',
        value: function finish() {
            this.entity.modelMatrix = this.getModelMatrix(this.entity.attribute.style);
            this.entity.show = true;
            this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象     
            this.entity.position = this.getDrawPosition();
        }
    }]);

    return DrawPModel;
}(_DrawP.DrawPBase);

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditPBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _point = __webpack_require__(2);

var _Tooltip = __webpack_require__(7);

var _Dragger = __webpack_require__(14);

var draggerCtl = _interopRequireWildcard(_Dragger);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPBase = exports.EditPBase = function (_MarsClass) {
    _inherits(EditPBase, _MarsClass);

    //========== 构造方法 ========== 
    function EditPBase(entity, viewer, dataSource) {
        _classCallCheck(this, EditPBase);

        var _this = _possibleConstructorReturn(this, (EditPBase.__proto__ || Object.getPrototypeOf(EditPBase)).call(this));

        _this.entity = entity;
        _this.viewer = viewer;
        _this.dataSource = dataSource;

        _this.draggers = [];
        _this._minPointNum = 1; //至少需要点的个数 (值是draw中传入)
        _this._maxPointNum = 9999; //最多允许点的个数 (值是draw中传入)
        return _this;
    }

    _createClass(EditPBase, [{
        key: 'fire',
        value: function fire(type, data, propagate) {
            if (this._fire) this._fire(type, data, propagate);
        }
    }, {
        key: 'formatNum',
        value: function formatNum(num, digits) {
            return (0, _point.formatNum)(num, digits);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(val) {
            this.viewer._container.style.cursor = val ? 'crosshair' : '';
        }
        //激活绘制

    }, {
        key: 'activate',
        value: function activate() {
            if (this._enabled) {
                return this;
            }
            this._enabled = true;

            this.entity.inProgress = true;
            this.changePositionsToCallback();
            this.bindDraggers();
            this.bindEvent();

            this.fire(_MarsClass2.eventType.editStart, { edittype: this.entity.attribute.type, entity: this.entity });

            return this;
        }
        //释放绘制

    }, {
        key: 'disable',
        value: function disable() {
            if (!this._enabled) {
                return this;
            }
            this._enabled = false;

            this.destroyEvent();
            this.destroyDraggers();
            this.finish();

            this.entity.inProgress = false;
            this.fire(_MarsClass2.eventType.editStop, { edittype: this.entity.attribute.type, entity: this.entity });
            this.tooltip.setVisible(false);

            return this;
        }
    }, {
        key: 'changePositionsToCallback',
        value: function changePositionsToCallback() {}
        //图形编辑结束后调用

    }, {
        key: 'finish',
        value: function finish() {}
        //拖拽点 事件

    }, {
        key: 'bindEvent',
        value: function bindEvent() {
            var _this2 = this;

            var scratchBoundingSphere = new Cesium.BoundingSphere();
            var zOffset = new Cesium.Cartesian3();

            var draggerHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.canvas);
            draggerHandler.dragger = null;

            //选中后拖动
            draggerHandler.setInputAction(function (event) {
                var pickedObject = _this2.viewer.scene.pick(event.position);
                if (Cesium.defined(pickedObject)) {
                    var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;
                    if (entity && Cesium.defaultValue(entity._isDragger, false)) {
                        _this2.viewer.scene.screenSpaceCameraController.enableRotate = false;
                        _this2.viewer.scene.screenSpaceCameraController.enableTilt = false;
                        _this2.viewer.scene.screenSpaceCameraController.enableTranslate = false;
                        _this2.viewer.scene.screenSpaceCameraController.enableInputs = false;

                        if (_this2.viewer.mars && _this2.viewer.mars.popup) _this2.viewer.mars.popup.close(entity);

                        draggerHandler.dragger = entity;
                        draggerHandler.dragger.show = Cesium.defaultValue(entity._drawShow, false);

                        _this2.setCursor(true);

                        if (draggerHandler.dragger.onDragStart) {
                            var position = (0, _point.getPositionValue)(draggerHandler.dragger.position);
                            draggerHandler.dragger.onDragStart(draggerHandler.dragger, position);
                        }

                        _this2.fire(_MarsClass2.eventType.editMouseDown, {
                            edittype: _this2.entity.attribute.type,
                            entity: _this2.entity,
                            position: event.position
                        });
                    }
                }
            }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

            draggerHandler.setInputAction(function (event) {
                var dragger = draggerHandler.dragger;
                if (dragger) {
                    switch (dragger._pointType) {
                        case draggerCtl.PointType.MoveHeight:
                            //改变高度垂直拖动
                            var dy = event.endPosition.y - event.startPosition.y;

                            var position = (0, _point.getPositionValue)(dragger.position, _this2.viewer.clock.currentTime);
                            var tangentPlane = new Cesium.EllipsoidTangentPlane(position);

                            scratchBoundingSphere.center = position;
                            scratchBoundingSphere.radius = 1;

                            var metersPerPixel = _this2.viewer.scene.frameState.camera.getPixelSize(scratchBoundingSphere, _this2.viewer.scene.frameState.context.drawingBufferWidth, _this2.viewer.scene.frameState.context.drawingBufferHeight) * 1.5;

                            Cesium.Cartesian3.multiplyByScalar(tangentPlane.zAxis, -dy * metersPerPixel, zOffset);
                            var newPosition = Cesium.Cartesian3.clone(position);
                            Cesium.Cartesian3.add(position, zOffset, newPosition);

                            dragger.position = newPosition;
                            if (dragger.onDrag) {
                                dragger.onDrag(dragger, newPosition, position);
                            }
                            _this2.updateAttrForEditing();
                            break;
                        default:
                            //默认修改位置
                            _this2.tooltip.showAt(event.endPosition, _Tooltip.message.edit.end);

                            var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.endPosition, _this2.entity);

                            if (point) {
                                dragger.position = point;
                                if (dragger.onDrag) {
                                    dragger.onDrag(dragger, point);
                                }
                                _this2.updateAttrForEditing();
                            }
                            break;
                    }
                    _this2.fire(_MarsClass2.eventType.editMouseMove, {
                        edittype: _this2.entity.attribute.type,
                        entity: _this2.entity,
                        position: event.endPosition
                    });
                } else {
                    _this2.tooltip.setVisible(false);

                    var pickedObject = _this2.viewer.scene.pick(event.endPosition);
                    if (Cesium.defined(pickedObject)) {
                        var entity = pickedObject.id;
                        if (entity && Cesium.defaultValue(entity._isDragger, false) && entity.draw_tooltip) {
                            var draw_tooltip = entity.draw_tooltip;

                            //可删除时，提示右击删除
                            if (draggerCtl.PointType.Control == entity._pointType && _this2._positions_draw && _this2._positions_draw.length && _this2._positions_draw.length > _this2._minPointNum) draw_tooltip += _Tooltip.message.del.def;

                            if (_this2.viewer.mars.contextmenu && _this2.viewer.mars.contextmenu.show && _this2.viewer.mars.contextmenu.target == entity) {
                                //删除右键菜单打开了不显示tooltip

                            } else {
                                _this2.tooltip.showAt(event.endPosition, draw_tooltip);
                            }
                        }
                    }
                }
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

            draggerHandler.setInputAction(function (event) {
                var dragger = draggerHandler.dragger;
                if (dragger) {
                    _this2.setCursor(false);
                    dragger.show = true;

                    var position = (0, _point.getPositionValue)(dragger.position, _this2.viewer.clock.currentTime);

                    if (dragger.onDragEnd) {
                        dragger.onDragEnd(dragger, position);
                    }
                    _this2.fire(_MarsClass2.eventType.editMovePoint, { edittype: _this2.entity.attribute.type, entity: _this2.entity, position: position });

                    draggerHandler.dragger = null;

                    _this2.viewer.scene.screenSpaceCameraController.enableRotate = true;
                    _this2.viewer.scene.screenSpaceCameraController.enableTilt = true;
                    _this2.viewer.scene.screenSpaceCameraController.enableTranslate = true;
                    _this2.viewer.scene.screenSpaceCameraController.enableInputs = true;
                }
            }, Cesium.ScreenSpaceEventType.LEFT_UP);

            //右击删除一个点
            draggerHandler.setInputAction(function (event) {
                //右击删除上一个点
                var pickedObject = _this2.viewer.scene.pick(event.position);
                if (Cesium.defined(pickedObject)) {
                    var entity = pickedObject.id;
                    if (entity && Cesium.defaultValue(entity._isDragger, false) && draggerCtl.PointType.Control == entity._pointType) {
                        var isDelOk = _this2.deletePointForDragger(entity, event.position);

                        if (isDelOk) _this2.fire(_MarsClass2.eventType.editRemovePoint, { edittype: _this2.entity.attribute.type, entity: _this2.entity });
                    }
                }
            }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

            this.draggerHandler = draggerHandler;
        }
    }, {
        key: 'destroyEvent',
        value: function destroyEvent() {
            this.viewer.scene.screenSpaceCameraController.enableRotate = true;
            this.viewer.scene.screenSpaceCameraController.enableTilt = true;
            this.viewer.scene.screenSpaceCameraController.enableTranslate = true;
            this.viewer.scene.screenSpaceCameraController.enableInputs = true;

            this.setCursor(false);

            if (this.draggerHandler) {
                if (this.draggerHandler.dragger) this.draggerHandler.dragger.show = true;

                this.draggerHandler.destroy();
                this.draggerHandler = null;
            }
        }
    }, {
        key: 'bindDraggers',
        value: function bindDraggers() {}
    }, {
        key: 'updateDraggers',
        value: function updateDraggers() {
            if (!this._enabled) {
                return this;
            }

            this.destroyDraggers();
            this.bindDraggers();
        }
    }, {
        key: 'destroyDraggers',
        value: function destroyDraggers() {
            for (var i = 0, len = this.draggers.length; i < len; i++) {
                this.dataSource.entities.remove(this.draggers[i]);
            }
            this.draggers = [];
        }
        //删除点

    }, {
        key: 'deletePointForDragger',
        value: function deletePointForDragger(dragger, position) {
            if (!this._positions_draw) return;
            if (this._positions_draw.length - 1 < this._minPointNum) {
                this.tooltip.showAt(position, _Tooltip.message.del.min + this._minPointNum);
                return false;
            }

            var index = dragger.index;
            if (index >= 0 && index < this._positions_draw.length) {
                this._positions_draw.splice(index, 1);
                this.updateDraggers();
                this.updateAttrForEditing();
                return true;
            } else {
                return false;
            }
        }
    }, {
        key: 'updateAttrForEditing',
        value: function updateAttrForEditing() {}
    }, {
        key: 'destroy',
        value: function destroy() {
            this.disable();
            _get(EditPBase.prototype.__proto__ || Object.getPrototypeOf(EditPBase.prototype), 'destroy', this).call(this);
        }
    }]);

    return EditPBase;
}(_MarsClass2.MarsClass);

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CircleFadeMaterial = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _CircleFadeMaterial = __webpack_require__(190);

var _CircleFadeMaterial2 = _interopRequireDefault(_CircleFadeMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultColor = new Cesium.Color(0, 0, 0, 0);

//圆形 单个扩散效果 材质 

var CircleFadeMaterial = exports.CircleFadeMaterial = function () {
    //========== 构造方法 ========== 
    function CircleFadeMaterial(options) {
        _classCallCheck(this, CircleFadeMaterial);

        options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

        this._definitionChanged = new Cesium.Event();
        this._color = undefined;
        this._colorSubscription = undefined;

        this.color = Cesium.defaultValue(options.color, defaultColor); //颜色
        this._duration = options.duration || 1000; //时长

        this._time = undefined;
    }

    //========== 对外属性 ==========  


    _createClass(CircleFadeMaterial, [{
        key: "getType",


        //========== 方法 ========== 
        /**
         * Gets the {@link Cesium.Material} type at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the type.
         * @returns {String} The type of material.
         */
        value: function getType(time) {
            return Cesium.Material.CircleFadeMaterialType;
        }

        /**
         * Gets the value of the property at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */

    }, {
        key: "getValue",
        value: function getValue(time, result) {
            if (!Cesium.defined(result)) {
                result = {};
            }
            result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);

            if (this._time === undefined) {
                this._time = new Date().getTime();
            }
            result.time = (new Date().getTime() - this._time) / this._duration;
            return result;
        }

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param { Cesium.Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */

    }, {
        key: "equals",
        value: function equals(other) {
            return this === other || //
            other instanceof CircleFadeMaterial && Cesium.Property.equals(this._color, other._color);
        }
    }, {
        key: "isConstant",
        get: function get() {
            return false;
        }
    }, {
        key: "definitionChanged",
        get: function get() {
            return this._definitionChanged;
        }
    }]);

    return CircleFadeMaterial;
}();

Object.defineProperties(CircleFadeMaterial.prototype, {
    /**
     * Gets or sets the  Cesium.Property specifying the {@link Cesium.Color} of the line.
     * @memberof PolylineGlowMaterialProperty.prototype
     * @type { Cesium.Property}
     */
    color: Cesium.createPropertyDescriptor('color')
});

//静态方法，处理材质
Cesium.Material.CircleFadeMaterialType = 'CircleFadeMaterial';
Cesium.Material._materialCache.addMaterial(Cesium.Material.CircleFadeMaterialType, {
    fabric: {
        type: Cesium.Material.CircleFadeMaterialType,
        uniforms: {
            color: new Cesium.Color(1, 0, 0, 1.0),
            time: 1
        },
        source: _CircleFadeMaterial2.default
    },
    translucent: function translucent() {
        return true;
    }
});

/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    material.diffuse = 1.5 * color.rgb;\r\n    vec2 st = materialInput.st;\r\n    float dis = distance(st, vec2(0.5, 0.5));\r\n    float per = fract(time);\r\n    if(dis > per * 0.5){\r\n        //material.alpha = 0.0;\r\n        discard;\r\n    }else {\r\n        material.alpha = color.a  * dis / per / 2.0;\r\n    }\r\n    return material;\r\n}"

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CircleScanMaterial = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _CircleScanMaterial = __webpack_require__(192);

var _CircleScanMaterial2 = _interopRequireDefault(_CircleScanMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//圆形 扫描效果 材质 
var CircleScanMaterial = exports.CircleScanMaterial = function () {
    //========== 构造方法 ========== 
    function CircleScanMaterial(options) {
        _classCallCheck(this, CircleScanMaterial);

        options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

        this._definitionChanged = new Cesium.Event();
        this._colorSubscription = undefined;

        this._color = Cesium.defaultValue(options.color, new Cesium.Color(1, 0, 0, 1.0)); //颜色
        this._scanImg = Cesium.defaultValue(options.url);
    }

    //========== 对外属性 ==========  


    _createClass(CircleScanMaterial, [{
        key: "getType",


        //========== 方法 ========== 
        /**
         * Gets the {@link Cesium.Material} type at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the type.
         * @returns {String} The type of material.
         */
        value: function getType(time) {
            return Cesium.Material.EntityScanMaterialType;
        }

        /**
         * Gets the value of the property at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */

    }, {
        key: "getValue",
        value: function getValue(time, result) {
            if (!Cesium.defined(result)) {
                result = {};
            }
            result.color = this._color;
            result.scanImg = this._scanImg;
            return result;
        }

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param { Cesium.Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */

    }, {
        key: "equals",
        value: function equals(other) {
            return this === other || //
            other instanceof CircleScanMaterial && Cesium.Property.equals(this._color, other._color);
        }
    }, {
        key: "isConstant",
        get: function get() {
            return false;
        }
    }, {
        key: "definitionChanged",
        get: function get() {
            return this._definitionChanged;
        }
    }]);

    return CircleScanMaterial;
}();

Object.defineProperties(CircleScanMaterial.prototype, {
    /**
     * Gets or sets the  Cesium.Property specifying the {@link Cesium.Color} of the line.
     * @memberof PolylineGlowMaterialProperty.prototype
     * @type { Cesium.Property}
     */
    color: Cesium.createPropertyDescriptor('color'),

    scanImg: Cesium.createPropertyDescriptor('scanImg')
});

//静态方法，处理材质
Cesium.Material.EntityScanMaterialType = 'CircleScanMaterial'; /**  渐变的气泡 */
Cesium.Material._materialCache.addMaterial(Cesium.Material.EntityScanMaterialType, {
    fabric: {
        type: Cesium.Material.EntityScanMaterialType,
        uniforms: {
            color: new Cesium.Color(1, 0, 0, 1.0),
            scanImg: ""
        },
        source: _CircleScanMaterial2.default
    },
    translucent: function translucent() {
        return true;
    }
});

/***/ }),
/* 192 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    vec2 st = materialInput.st;\r\n    vec4 imgC = texture2D(scanImg,st);\r\n    if(imgC.a>.0){\r\n        material.diffuse = color.rgb;\r\n    }\r\n    material.alpha = imgC.a;\r\n    return material;\r\n}"

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GroundLineFlowMaterial = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _GroundLineFlowMaterial = __webpack_require__(194);

var _GroundLineFlowMaterial2 = _interopRequireDefault(_GroundLineFlowMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//贴地线线 流动效果 材质
var GroundLineFlowMaterial = exports.GroundLineFlowMaterial = function GroundLineFlowMaterial(options) {
    _classCallCheck(this, GroundLineFlowMaterial);

    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

    var color = Cesium.defaultValue(options.color, new Cesium.Color(1, 0, 0, 1.0));
    var image = options.url || options.image; //必须是png
    var repeat = Cesium.defaultValue(options.repeat, {
        x: 10,
        y: 1
    });
    var axisY = Cesium.defaultValue(options.axisY, false);
    var speed = Cesium.defaultValue(options.speed, 1); //速度建议1-10
    return new Cesium.Material({
        fabric: {
            uniforms: {
                color: color,
                image: image,
                repeat: repeat,
                axisY: axisY,
                speed: speed
            },
            source: _GroundLineFlowMaterial2.default
        }
    });
};

/***/ }),
/* 194 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput) \r\n{ \r\n    czm_material material = czm_getDefaultMaterial(materialInput); \r\n    vec2 st = repeat * materialInput.st;\r\n    // vec4 color = texture2D(image, materialInput.st/repeat); \r\n    vec4 colorImage = texture2D(image, vec2(fract((axisY?st.t:st.s) - czm_frameNumber*speed/100.0), st.t));\r\n    if(color.a == 0.0)\r\n    {\r\n        material.alpha = colorImage.a;\r\n        material.diffuse = colorImage.rgb; \r\n    }\r\n    else\r\n    {\r\n        material.alpha = colorImage.a * color.a;\r\n        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \r\n    }\r\n    return material; \r\n}"

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextMaterial = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TextMaterial = __webpack_require__(196);

var _TextMaterial2 = _interopRequireDefault(_TextMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultColor = new Cesium.Color(0, 0, 0, 0);

//文字贴图 材质

var TextMaterial = exports.TextMaterial = function () {
    //========== 构造方法 ========== 
    function TextMaterial(options) {
        _classCallCheck(this, TextMaterial);

        options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
        if (!options.text) return;
        this._text = options.text;
        this._textStyles = Cesium.defaultValue(options.textStyles, {
            font: '50px 楷体',
            fill: true,
            fillColor: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
            stroke: true,
            strokeWidth: 2,
            strokeColor: new Cesium.Color(1.0, 1.0, 1.0, 0.8),
            backgroundColor: new Cesium.Color(1.0, 1.0, 1.0, 0.1),
            textBaseline: 'top',
            padding: 40
        });
        this._definitionChanged = new Cesium.Event();
        this._color = undefined;
        this._colorSubscription = undefined;
        this.color = Cesium.defaultValue(options.color, defaultColor); //颜色
        this.repeat = Cesium.defaultValue(options.repeat, new Cesium.Cartesian2(1.0, 1.0));
        this._img = this._text2Img(this._text, this._textStyles);
        var _material = getImageMaterial(this._img.src, this.repeat);
        this._materialType = Cesium.clone(_material.type); //材质类型
        this._materialImage = Cesium.clone(_material.image); //材质图片
    }

    //========== 对外属性 ==========   


    _createClass(TextMaterial, [{
        key: "getType",


        //========== 方法 ========== 

        /**
         * Gets the {@link Cesium.Material} type at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the type.
         * @returns {String} The type of material.
         */
        value: function getType(time) {
            return this._materialType;
        }

        /**
         * Gets the value of the property at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */

    }, {
        key: "getValue",
        value: function getValue(time, result) {
            if (!Cesium.defined(result)) {
                result = {};
            }
            result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
            result.image = this._materialImage;
            result.repeat = this.repeat;
            return result;
        }

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cesium.Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */

    }, {
        key: "equals",
        value: function equals(other) {
            return this === other || //
            other instanceof TextMaterial && Cesium.Property.equals(this._color, other._color);
        }
    }, {
        key: "_text2Img",
        value: function _text2Img(text, styles) {
            //opts.type   img/png
            var canvas = Cesium.writeTextToCanvas(text, styles);
            if (!canvas) return;
            this.canvas = canvas;
            var img = new Image();
            img.src = canvas.toDataURL("image/png");
            return img;
        }
    }, {
        key: "isConstant",
        get: function get() {
            return false;
        }
    }, {
        key: "definitionChanged",
        get: function get() {
            return this._definitionChanged;
        }
    }, {
        key: "text",
        get: function get() {
            return this._text;
        },
        set: function set(val) {
            if (!val) return;
            this._text = val;
            delete this._img;
            this._img = this._text2Img(this._text, this._textStyles);
            var _material = getImageMaterial(this._img.src, this.repeat);
            this._materialType = Cesium.clone(_material.type); //材质类型
            this._materialImage = Cesium.clone(_material.image); //材质图片
        }
    }, {
        key: "textStyles",
        get: function get() {
            return this._textStyles;
        },
        set: function set(val) {
            if (!val) return;
            delete this._img;
            this._textStyles = val;
            this._img = this._text2Img(this._text, this._textStyles);
            var _material = getImageMaterial(this._img.src, this.repeat);
            this._materialType = Cesium.clone(_material.type); //材质类型
            this._materialImage = Cesium.clone(_material.image); //材质图片
        }
    }]);

    return TextMaterial;
}();

Object.defineProperties(TextMaterial.prototype, {
    /**
     * Gets or sets the Cesium.Property specifying the {@link Cesium.Color} of the line.
     * @memberof PolylineGlowMaterialProperty.prototype
     * @type {Cesium.Property}
     */
    color: Cesium.createPropertyDescriptor('color')
});

//静态方法，处理材质
var cacheIdx = 0;
var nameEx = "Text";
function getImageMaterial(imgurl, repeat) {
    cacheIdx++;
    var typeName = nameEx + cacheIdx + "Type";
    var imageName = nameEx + cacheIdx + "Image";

    Cesium.Material[typeName] = typeName;
    Cesium.Material[imageName] = imgurl;

    Cesium.Material._materialCache.addMaterial(Cesium.Material[typeName], {
        fabric: {
            type: typeName,
            uniforms: {
                color: new Cesium.Color(1, 0, 0, 1.0),
                image: Cesium.Material[imageName],
                time: 0,
                repeat: repeat || new Cesium.Cartesian2(1.0, 1.0)
            },
            source: _TextMaterial2.default
        },
        translucent: function translucent() {
            return true;
        }
    });

    return {
        type: Cesium.Material[typeName],
        image: Cesium.Material[imageName]
    };
}

/***/ }),
/* 196 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    vec2 mst = fract(materialInput.st + vec2(.0,.0));\r\n    mst = vec2(mst.x,mst.y);\r\n    vec2 st = fract(repeat * mst);\r\n    vec4 colorImage = texture2D(image, st);\r\n    if(color.a == 0.0)\r\n    {\r\n        material.alpha = colorImage.a;\r\n        material.diffuse = colorImage.rgb; \r\n    }\r\n    else\r\n    {\r\n        material.alpha = colorImage.a * color.a;\r\n        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \r\n    }\r\n    return material;\r\n}"

/***/ }),
/* 197 */
/***/ (function(module, exports) {

module.exports = "attribute vec4 position;\r\nattribute vec3 normal;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = czm_modelViewProjection * position;\r\n    v_position = vec3(position);\r\n    v_positionWC = (czm_model * position).xyz;\r\n    v_positionEC = (czm_modelView * position).xyz;\r\n    v_normalEC = czm_normal * normal;\r\n}"

/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_OES_standard_derivatives\r\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nuniform bool u_showIntersection;\r\nuniform bool u_showThroughEllipsoid;\r\n\r\nuniform float u_radius;\r\nuniform float u_xHalfAngle;\r\nuniform float u_yHalfAngle;\r\nuniform float u_normalDirection;\r\nuniform float u_type;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvec4 getColor(float sensorRadius, vec3 pointEC)\r\n{\r\n    czm_materialInput materialInput;\r\n\r\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\r\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\r\n    materialInput.str = pointMC / sensorRadius;\r\n\r\n    vec3 positionToEyeEC = -v_positionEC;\r\n    materialInput.positionToEyeEC = positionToEyeEC;\r\n\r\n    vec3 normalEC = normalize(v_normalEC);\r\n    materialInput.normalEC = u_normalDirection * normalEC;\r\n\r\n    czm_material material = czm_getMaterial(materialInput);\r\n    // czm_lightDirectionEC在cesium1.66开始加入的\r\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\r\n\r\n}\r\n\r\nbool isOnBoundary(float value, float epsilon)\r\n{\r\n    float width = getIntersectionWidth();\r\n    float tolerance = width * epsilon;\r\n\r\n#ifdef GL_OES_standard_derivatives\r\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\r\n    float pixels = width * delta;\r\n    float temp = abs(value);\r\n    // There are a couple things going on here.\r\n    // First we test the value at the current fragment to see if it is within the tolerance.\r\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\r\n    // but we don't want to admit points that are obviously not on the surface.\r\n    // For example, if we are looking for \"value\" to be close to 0, but value is 1 and the adjacent value is 2,\r\n    // then the delta would be 1 and \"temp - delta\" would be \"1 - 1\" which is zero even though neither of\r\n    // the points is close to zero.\r\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\r\n#else\r\n    return abs(value) < tolerance;\r\n#endif\r\n}\r\n\r\nvec4 shade(bool isOnBoundary)\r\n{\r\n    if (u_showIntersection && isOnBoundary)\r\n    {\r\n        return getIntersectionColor();\r\n    }\r\n    if(u_type == 1.0){\r\n        return getLineColor();\r\n    }\r\n    return getColor(u_radius, v_positionEC);\r\n}\r\n\r\nfloat ellipsoidSurfaceFunction(vec3 point)\r\n{\r\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\r\n    return dot(scaled, scaled) - 1.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\r\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\r\n\r\n    //vec3 pixDir = normalize(v_position);\r\n    float positionX = v_position.x;\r\n    float positionY = v_position.y;\r\n    float positionZ = v_position.z;\r\n\r\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\r\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\r\n    vec3 lineY = vec3(0, positionY, positionZ);\r\n    float resX = dot(normalize(lineX), zDir);\r\n    if(resX < cos(u_xHalfAngle)-0.00001){\r\n        discard;\r\n    }\r\n    float resY = dot(normalize(lineY), zDir);\r\n    if(resY < cos(u_yHalfAngle)-0.00001){\r\n        discard;\r\n    }\r\n\r\n\r\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\r\n\r\n    // Occluded by the ellipsoid?\r\n\tif (!u_showThroughEllipsoid)\r\n\t{\r\n\t    // Discard if in the ellipsoid\r\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\r\n\t    if (ellipsoidValue < 0.0)\r\n\t    {\r\n            discard;\r\n\t    }\r\n\r\n\t    // Discard if in the sensor's shadow\r\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\r\n\t    {\r\n\t        discard;\r\n\t    }\r\n    }\r\n\r\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\r\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\r\n    //isOnEllipsoid = false;\r\n    //if((resX >= 0.8 && resX <= 0.81)||(resY >= 0.8 && resY <= 0.81)){\r\n    /*if(false){\r\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n    }else{\r\n        gl_FragColor = shade(isOnEllipsoid);\r\n    }\r\n*/\r\n    gl_FragColor = shade(isOnEllipsoid);\r\n\r\n}"

/***/ }),
/* 199 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 u_intersectionColor;\nuniform float u_intersectionWidth;\nuniform vec4 u_lineColor;\n\nbool inSensorShadow(vec3 coneVertexWC, vec3 pointWC)\n{\n    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.    \n    vec3 D = czm_ellipsoidInverseRadii;\n\n    // Sensor vertex in the scaled ellipsoid space\n    vec3 q = D * coneVertexWC;\n    float qMagnitudeSquared = dot(q, q);\n    float test = qMagnitudeSquared - 1.0;\n    \n    // Sensor vertex to fragment vector in the ellipsoid's scaled space\n    vec3 temp = D * pointWC - q;\n    float d = dot(temp, q);\n    \n    // Behind silhouette plane and inside silhouette cone\n    return (d < -test) && (d / length(temp) < -sqrt(test));\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvec4 getLineColor()\n{\n    return u_lineColor;\n}\n\nvec4 getIntersectionColor()\n{\n    return u_intersectionColor;\n}\n\nfloat getIntersectionWidth()\n{\n    return u_intersectionWidth;\n}\n\nvec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)\n{\n    // (s, t) both in the range [0, 1]\n    float t = pointMC.z / sensorRadius;\n    float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);\n    s = s - floor(s);\n    \n    return vec2(s, t);\n}\n"

/***/ }),
/* 200 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_OES_standard_derivatives\r\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nuniform bool u_showIntersection;\r\nuniform bool u_showThroughEllipsoid;\r\n\r\nuniform float u_radius;\r\nuniform float u_xHalfAngle;\r\nuniform float u_yHalfAngle;\r\nuniform float u_normalDirection;\r\nuniform vec4 u_color;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvec4 getColor(float sensorRadius, vec3 pointEC)\r\n{\r\n    czm_materialInput materialInput;\r\n\r\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\r\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\r\n    materialInput.str = pointMC / sensorRadius;\r\n\r\n    vec3 positionToEyeEC = -v_positionEC;\r\n    materialInput.positionToEyeEC = positionToEyeEC;\r\n\r\n    vec3 normalEC = normalize(v_normalEC);\r\n    materialInput.normalEC = u_normalDirection * normalEC;\r\n\r\n    czm_material material = czm_getMaterial(materialInput);\r\n\r\n    material.diffuse = u_color.rgb;\r\n    material.alpha = u_color.a;\r\n    // czm_lightDirectionEC在cesium1.66开始加入的\r\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\r\n\r\n}\r\n\r\nbool isOnBoundary(float value, float epsilon)\r\n{\r\n    float width = getIntersectionWidth();\r\n    float tolerance = width * epsilon;\r\n\r\n#ifdef GL_OES_standard_derivatives\r\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\r\n    float pixels = width * delta;\r\n    float temp = abs(value);\r\n    // There are a couple things going on here.\r\n    // First we test the value at the current fragment to see if it is within the tolerance.\r\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\r\n    // but we don't want to admit points that are obviously not on the surface.\r\n    // For example, if we are looking for \"value\" to be close to 0, but value is 1 and the adjacent value is 2,\r\n    // then the delta would be 1 and \"temp - delta\" would be \"1 - 1\" which is zero even though neither of\r\n    // the points is close to zero.\r\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\r\n#else\r\n    return abs(value) < tolerance;\r\n#endif\r\n}\r\n\r\nvec4 shade(bool isOnBoundary)\r\n{\r\n    if (u_showIntersection && isOnBoundary)\r\n    {\r\n        return getIntersectionColor();\r\n    }\r\n    return getColor(u_radius, v_positionEC);\r\n}\r\n\r\nfloat ellipsoidSurfaceFunction(vec3 point)\r\n{\r\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\r\n    return dot(scaled, scaled) - 1.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\r\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\r\n\r\n    //vec3 pixDir = normalize(v_position);\r\n    float positionX = v_position.x;\r\n    float positionY = v_position.y;\r\n    float positionZ = v_position.z;\r\n\r\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\r\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\r\n    vec3 lineY = vec3(0, positionY, positionZ);\r\n    float resX = dot(normalize(lineX), zDir);\r\n    if(resX < cos(u_xHalfAngle) - 0.0001){\r\n        discard;\r\n    }\r\n    float resY = dot(normalize(lineY), zDir);\r\n    if(resY < cos(u_yHalfAngle)- 0.0001){\r\n        discard;\r\n    }\r\n\r\n\r\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\r\n\r\n    // Occluded by the ellipsoid?\r\n\tif (!u_showThroughEllipsoid)\r\n\t{\r\n\t    // Discard if in the ellipsoid\r\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\r\n\t    if (ellipsoidValue < 0.0)\r\n\t    {\r\n            discard;\r\n\t    }\r\n\r\n\t    // Discard if in the sensor's shadow\r\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\r\n\t    {\r\n\t        discard;\r\n\t    }\r\n    }\r\n\r\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\r\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\r\n    gl_FragColor = shade(isOnEllipsoid);\r\n\r\n}"

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RectangularSensorVisualizer = undefined;
exports.removePrimitive = removePrimitive;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _RectangularSensorPrimitive = __webpack_require__(90);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var AssociativeArray = Cesium.AssociativeArray;
var Cartesian3 = Cesium.Cartesian3;
var Color = Cesium.Color;
var defined = Cesium.defined;
var DeveloperError = Cesium.DeveloperError;
var Matrix3 = Cesium.Matrix3;
var Matrix4 = Cesium.Matrix4;
var Quaternion = Cesium.Quaternion;
var MaterialProperty = Cesium.MaterialProperty;
var Property = Cesium.Property;

var matrix3Scratch = new Matrix3();
// var matrix4Scratch = new Matrix4();
var cachedPosition = new Cartesian3();
var cachedGazePosition = new Cartesian3();
var cachedOrientation = new Quaternion();
var diffVectorScratch = new Cartesian3();
var orientationScratch = new Quaternion();

function removePrimitive(entity, hash, primitives) {
    var data = hash[entity.id];
    if (Cesium.defined(data)) {
        var primitive = data.primitive;
        try {
            primitives.remove(primitive);
        } catch (e) {}
        if (primitive.isDestroyed && !primitive.isDestroyed()) {
            primitive.destroy();
        }
        delete hash[entity.id];
    }
};

var RectangularSensorVisualizer = function RectangularSensorVisualizer(scene, entityCollection) {
    // >>includeStart('debug', pragmas.debug);
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(entityCollection)) {
        throw new DeveloperError('entityCollection is required.');
    }
    // >>includeEnd('debug');

    entityCollection.collectionChanged.addEventListener(RectangularSensorVisualizer.prototype._onCollectionChanged, this);

    this._scene = scene;
    this._primitives = scene.primitives;
    this._entityCollection = entityCollection;
    this._hash = {};
    this._entitiesToVisualize = new AssociativeArray();

    this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
};

/**
 * Updates the primitives created by this visualizer to match their
 * Entity counterpart at the given time.
 *
 * @param {JulianDate} time The time to update to.
 * @returns {Boolean} This function always returns true.
 */
RectangularSensorVisualizer.prototype.update = function (time) {
    // >>includeStart('debug', pragmas.debug);
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    // >>includeEnd('debug');

    var entities = this._entitiesToVisualize.values;
    var hash = this._hash;
    var primitives = this._primitives;

    for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];
        var rectangularSensorGraphics = entity._rectangularSensor;

        var position;
        var orientation;
        var radius;
        var xHalfAngle;
        var yHalfAngle;
        var data = hash[entity.id];
        var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(rectangularSensorGraphics._show, time, true);

        if (show) {
            position = Property.getValueOrUndefined(entity._position, time, cachedPosition);
            orientation = Property.getValueOrUndefined(entity._orientation, time, cachedOrientation);
            radius = Property.getValueOrUndefined(rectangularSensorGraphics._radius, time);
            xHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._xHalfAngle, time);
            yHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._yHalfAngle, time);
            show = defined(position) && defined(xHalfAngle) && defined(yHalfAngle);
        }

        if (!show) {
            // don't bother creating or updating anything else
            if (defined(data)) {
                data.primitive.show = false;
            }
            continue;
        }

        var primitive = defined(data) ? data.primitive : undefined;
        if (!defined(primitive)) {
            primitive = new _RectangularSensorPrimitive.RectangularSensorPrimitive();
            primitive.id = entity;
            primitives.add(primitive);

            data = {
                primitive: primitive,
                position: undefined,
                orientation: undefined
            };
            hash[entity.id] = data;
        }

        var gaze = Property.getValueOrUndefined(rectangularSensorGraphics._gaze, time);
        if (defined(gaze)) {

            var targetPosition = Property.getValueOrUndefined(gaze._position, time, cachedGazePosition);

            if (!defined(position) || !defined(targetPosition)) {
                continue;
            }

            var diffVector = Cartesian3.subtract(position, targetPosition, diffVectorScratch);
            var rotate = Cartesian3.angleBetween(Cesium.Cartesian3.UNIT_Z, diffVector);
            var cross = Cartesian3.cross(Cesium.Cartesian3.UNIT_Z, diffVector, diffVectorScratch);
            var orientation = Quaternion.fromAxisAngle(cross, rotate - Math.PI, orientationScratch);

            //replace original radius
            radius = Cartesian3.distance(position, targetPosition);
            primitive.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, primitive.modelMatrix);
        } else {
            if (!Cartesian3.equals(position, data.position) || !Quaternion.equals(orientation, data.orientation)) {
                if (defined(orientation)) {
                    primitive.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, primitive.modelMatrix);
                    data.position = Cartesian3.clone(position, data.position);
                    data.orientation = Quaternion.clone(orientation, data.orientation);
                } else {
                    primitive.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
                    data.position = Cartesian3.clone(position, data.position);
                }
            }
        }

        primitive.show = true;
        primitive.gaze = gaze;
        primitive.radius = radius;
        primitive.xHalfAngle = xHalfAngle;
        primitive.yHalfAngle = yHalfAngle;
        primitive.lineColor = Property.getValueOrDefault(rectangularSensorGraphics._lineColor, time, Color.WHITE);
        primitive.showSectorLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorLines, time, true);
        primitive.showSectorSegmentLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorSegmentLines, time, true);
        primitive.showLateralSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showLateralSurfaces, time, true);
        primitive.material = MaterialProperty.getValue(time, rectangularSensorGraphics._material, primitive.material);
        primitive.showDomeSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showDomeSurfaces, time, true);
        primitive.showDomeLines = Property.getValueOrDefault(rectangularSensorGraphics._showDomeLines, time, true);
        primitive.showIntersection = Property.getValueOrDefault(rectangularSensorGraphics._showIntersection, time, true);
        primitive.intersectionColor = Property.getValueOrDefault(rectangularSensorGraphics._intersectionColor, time, Color.WHITE);
        primitive.intersectionWidth = Property.getValueOrDefault(rectangularSensorGraphics._intersectionWidth, time, 1);
        primitive.showThroughEllipsoid = Property.getValueOrDefault(rectangularSensorGraphics._showThroughEllipsoid, time, true);
        primitive.scanPlaneMode = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneMode, time);
        primitive.scanPlaneColor = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneColor, time, Color.WHITE);
        primitive.showScanPlane = Property.getValueOrDefault(rectangularSensorGraphics._showScanPlane, time, true);
        primitive.scanPlaneRate = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneRate, time, 1);
    }
    return true;
};

/**
 * Returns true if this object was destroyed; otherwise, false.
 *
 * @returns {Boolean} True if this object was destroyed; otherwise, false.
 */
RectangularSensorVisualizer.prototype.isDestroyed = function () {
    return false;
};

/**
 * Removes and destroys all primitives created by this instance.
 */
RectangularSensorVisualizer.prototype.destroy = function () {
    var entities = this._entitiesToVisualize.values;
    var hash = this._hash;
    var primitives = this._primitives;
    for (var i = entities.length - 1; i > -1; i--) {
        removePrimitive(entities[i], hash, primitives);
    }

    //删除所有绑定的数据
    for (var _i in this) {
        delete this[_i];
    }

    return Cesium.destroyObject(this);
};

/**
 * @private
 */
RectangularSensorVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
    var entities = this._entitiesToVisualize;
    if (!entities) return;

    var hash = this._hash;
    var primitives = this._primitives;

    var i;
    var entity;
    for (i = added.length - 1; i > -1; i--) {
        entity = added[i];
        if (defined(entity._rectangularSensor) && defined(entity._position)) {
            entities.set(entity.id, entity);
        }
    }

    for (i = changed.length - 1; i > -1; i--) {
        entity = changed[i];
        if (defined(entity._rectangularSensor) && defined(entity._position)) {
            entities.set(entity.id, entity);
        } else {
            removePrimitive(entity, hash, primitives);
            entities.remove(entity.id);
        }
    }

    for (i = removed.length - 1; i > -1; i--) {
        entity = removed[i];
        removePrimitive(entity, hash, primitives);
        entities.remove(entity.id);
    }
};

var originalDefaultVisualizersCallback = Cesium.DataSourceDisplay.defaultVisualizersCallback;
Cesium.DataSourceDisplay.defaultVisualizersCallback = function (scene, entityCluster, dataSource) {
    var entities = dataSource.entities;
    var array = originalDefaultVisualizersCallback(scene, entityCluster, dataSource);
    return array.concat([new RectangularSensorVisualizer(scene, entities)]);
};

exports.RectangularSensorVisualizer = RectangularSensorVisualizer;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DynamicRiver = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.Lines2Plane = Lines2Plane;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _util = __webpack_require__(1);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _Draw = __webpack_require__(6);

var _DynamicRiverFS = __webpack_require__(203);

var _DynamicRiverFS2 = _interopRequireDefault(_DynamicRiverFS);

var _DynamicRiverVS = __webpack_require__(204);

var _DynamicRiverVS2 = _interopRequireDefault(_DynamicRiverVS);

var _DynamicRiverMaterial = __webpack_require__(205);

var _DynamicRiverMaterial2 = _interopRequireDefault(_DynamicRiverMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//动态河流、公路
var DynamicRiver = exports.DynamicRiver = function () {
    //========== 构造方法 ========== 

    function DynamicRiver(viewer, options) {
        _classCallCheck(this, DynamicRiver);

        this.viewer = viewer;

        options = options || {};
        this.options = options;

        this._positions = Cesium.defaultValue(options.positions, null);

        this._image = Cesium.defaultValue(options.image, null); //贴图路径
        this._flipY = Cesium.defaultValue(options.flipY, false); //uv交换（图片横竖切换）
        this._width = Cesium.defaultValue(options.width, 10); //宽度
        this._height = Cesium.defaultValue(options.height, 0); //拔高数值
        this._alpha = Cesium.defaultValue(options.alpha, 0.5); //透明度
        this._speed = Cesium.defaultValue(options.speed, 1.0); //流动速度

        this._move = Cesium.defaultValue(options.move, true); //是否开启流动效果
        this._moveDir = Cesium.defaultValue(options.moveDir, true); //设置流动方向
        this._moveVar = Cesium.defaultValue(options.moveVar, new Cesium.Cartesian3(50, 1, 100)); //流动动画参数，不建议调整该参数

        this.resetPos();
    }

    //========== 对外属性 ==========  


    _createClass(DynamicRiver, [{
        key: "resetPos",


        //========== 方法 ========== 

        value: function resetPos() {
            if (this.riverPrimitive) {
                this.viewer.scene.primitives.remove(this.riverPrimitive);
                delete this.riverPrimitive;
            }

            if (!(0, _util.isArray)(this._positions) || !this._positions.length) return;

            this.sideRes = Lines2Plane(this._positions, this.width, this.height);
            if (!this.sideRes) return;

            this.material = this.prepareMaterial();
            this.riverPrimitive = this.createPrimitive();
            this.viewer.scene.primitives.add(this.riverPrimitive);
        }
    }, {
        key: "drawLines",
        value: function drawLines(style) {
            if (!this.drawControl) {
                this.drawControl = new _Draw.Draw(this.viewer, {
                    hasEdit: false,
                    removeScreenSpaceEvent: true
                });
            }
            var control = this.drawControl;

            var that = this;
            control.startDraw({
                type: "polyline",
                style: style || {
                    color: "#55ff33",
                    width: 3,
                    clampToGround: true
                },
                success: function success(entity) {
                    var positions = that.drawControl.getPositions(entity);
                    that.setPositions(positions);
                    that.drawControl.deleteAll();
                }
            });
        }
    }, {
        key: "setPositions",
        value: function setPositions(positions) {
            this._positions = positions;
            this.resetPos();
        }
    }, {
        key: "prepareMaterial",
        value: function prepareMaterial() {
            if (this.image) {
                var material = new Cesium.Material({
                    fabric: {
                        uniforms: {
                            image: this.image,
                            alpha: this.alpha,
                            moveVar: this.moveVar,
                            reflux: this.moveDir ? -1 : 1,
                            speed: this.speed,
                            move: this.move,
                            flipY: this.flipY
                        },
                        source: _DynamicRiverMaterial2.default
                    }
                });
                return material;
            } else {
                var material = Cesium.Material.fromType('Color');
                material.uniforms.color = new Cesium.Color(0.0, 1.0, 0.0, this.alpha);
                return material;
            }
        }
    }, {
        key: "createPrimitive",
        value: function createPrimitive() {
            //创建图元
            var sides = this.sideRes;
            var positions = new Float64Array(sides.vertexs);
            var attributes = new Cesium.GeometryAttributes();
            attributes.position = new Cesium.GeometryAttribute({
                componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: positions
            });
            attributes.st = new Cesium.GeometryAttribute({
                componentDatatype: Cesium.ComponentDatatype.FLOAT,
                componentsPerAttribute: 2,
                values: sides.uvs
            });
            var geometry = new Cesium.Geometry({
                attributes: attributes,
                indices: sides.indexs,
                primitiveType: Cesium.PrimitiveType.TRIANGLES,
                boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
            });
            // geometry._workerName = ""

            var instance = new Cesium.GeometryInstance({
                geometry: geometry
            });
            var renderState = new Cesium.RenderState();
            renderState.depthTest.enabled = true;
            var ppp = new Cesium.Primitive({
                geometryInstances: instance,
                appearance: new Cesium.Appearance({
                    material: this.material,
                    renderState: renderState,
                    vertexShaderSource: _DynamicRiverVS2.default,
                    fragmentShaderSource: _DynamicRiverFS2.default //czm_lightDirectionEC在cesium1.66开始加入的
                })
            });
            return ppp;
        }
    }, {
        key: "offsetHeight",
        value: function offsetHeight(height, time) {
            if (!height || !time || !this.riverPrimitive) return;
            var that = this;
            var currH = 0;
            var avgF = 20; //平均每帧20毫秒，即每秒50帧；
            var avgH = height / (time * avgF);

            var selfV = this.sideRes.self;
            var totalN = new Cesium.Cartesian3();
            for (var i = 0, len = selfV.length; i < len; i++) {
                //求平均的法线
                var currN = Cesium.Cartesian3.normalize(selfV[i], new Cesium.Cartesian3());
                Cesium.Cartesian3.add(totalN, currN, totalN);
            }
            Cesium.Cartesian3.normalize(totalN, totalN);

            var initM = Cesium.clone(this.riverPrimitive.modelMatrix);

            this.dhEvent = function () {
                if (Math.abs(currH) <= Math.abs(height)) {
                    //可以升高，可以降低，height可以为负值
                    var currNor = Cesium.Cartesian3.multiplyByScalar(totalN, currH, new Cesium.Cartesian3());
                    that.riverPrimitive.modelMatrix = Cesium.Matrix4.multiplyByTranslation(initM, currNor, new Cesium.Matrix4());
                } else {
                    that.viewer.clock.onTick.removeEventListener(that.dhEvent);
                }
                currH += avgH;
            };
            this.viewer.clock.onTick.addEventListener(this.dhEvent);
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            this.viewer.scene.primitives.remove(this.riverPrimitive);

            if (this.drawControl) {
                this.drawControl.destroy();
                delete this.drawControl;
            }
            this.material.destroy();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "positions",
        get: function get() {
            return this._positions;
        },
        set: function set(val) {
            this.setPositions(val);
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        },
        set: function set(val) {
            this._width = Number(val) || 1;
            this.resetPos();
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        },
        set: function set(val) {
            this._height = Number(val);
            this.resetPos();
        }
    }, {
        key: "alpha",
        get: function get() {
            return this._alpha;
        },
        set: function set(val) {
            this._alpha = Number(val);
            this.material.uniforms.alpha = this._alpha;
        }
    }, {
        key: "moveDir",
        get: function get() {
            return this._moveDir;
        },
        set: function set(val) {
            this._moveDir = Boolean(val);
            this.material.uniforms.reflux = this._moveDir ? -1 : 1;
        }
    }, {
        key: "speed",
        get: function get() {
            return this._speed;
        },
        set: function set(val) {
            this._speed = Number(val) || 1;
            this.material.uniforms.speed = this._speed;
        }
    }, {
        key: "image",
        get: function get() {
            return this._image;
        },
        set: function set(str) {
            this._image = str;
            this.material.uniforms.image = this._image;
        }
    }, {
        key: "move",
        get: function get() {
            return this._move;
        },
        set: function set(val) {
            this._move = Boolean(val);
            this.material.uniforms.move = this._move;
        }
    }, {
        key: "flipY",
        get: function get() {
            return this._flipY;
        },
        set: function set(val) {
            this._flipY = Boolean(val);
            this.material.uniforms.flipY = this._flipY;
        }
    }, {
        key: "moveVar",
        get: function get() {
            return this._moveVar;
        },
        set: function set(val) {
            this._moveVar = val;
            this.material.uniforms.moveVar = this._moveVar;
        }
    }]);

    return DynamicRiver;
}();

function Lines2Plane(lineArr, width, height) {
    if (!lineArr || lineArr.length <= 1 || !width || width == 0) {
        marslog.warn("请确认参数符合规则：数组长度大于1，宽高不能为0！");
        return;
    }
    var len = lineArr.length;
    var leftPots = [];
    var rightPots = [];
    var halfW = width / 2.0;
    for (var i = 0; i < len; i++) {
        var prevP = void 0;
        var currP = void 0;
        var nextP = void 0;
        var leftPot = void 0;
        var rightPot = void 0;
        if (i == 0) {
            prevP = lineArr[i];
            currP = lineArr[i];
            nextP = lineArr[i + 1];
        } else if (i == len - 1) {
            prevP = lineArr[i - 1];
            currP = lineArr[i];
            nextP = lineArr[i - 1];
        } else {
            prevP = lineArr[i - 1];
            currP = lineArr[i];
            nextP = lineArr[i + 1];
        }

        if (height != 0) {
            prevP = RaisePoint(prevP, height);
            currP = RaisePoint(currP, height);
            nextP = RaisePoint(nextP, height);
        }

        if (prevP && currP && nextP) {
            var sides = GetSides(currP, nextP, halfW);
            leftPot = sides.left;
            rightPot = sides.right;

            if (i == 0) {
                leftPots.push(leftPot);
                rightPots.push(rightPot);
                leftPots.push(leftPot);
                rightPots.push(rightPot);
                continue;
            } else {
                if (i < len - 1) {
                    leftPots.push(leftPot);
                    rightPots.push(rightPot);
                } else {
                    leftPots.push(rightPot);
                    rightPots.push(leftPot);
                    leftPots.push(rightPot);
                    rightPots.push(leftPot);
                    continue;
                }
            }

            sides = GetSides(currP, prevP, halfW);
            leftPot = sides.left;
            rightPot = sides.right;
            leftPots.push(rightPot);
            rightPots.push(leftPot);
        }
    }
    // return {
    //     left:leftPots,
    //     right:rightPots,
    //     self:lineArr
    // }

    var leftPotsRes = [];
    var rightPotsRes = [];
    if (leftPots.length == len * 2) {
        for (var _i = 0; _i < len; _i++) {
            var CurrP = lineArr[_i];

            var lf1 = leftPots[_i * 2 + 0];
            var lf2 = leftPots[_i * 2 + 1];
            var dir1 = Cesium.Cartesian3.subtract(lf1, CurrP, new Cesium.Cartesian3());
            var dir2 = Cesium.Cartesian3.subtract(lf2, CurrP, new Cesium.Cartesian3());
            var avgDir = Cesium.Cartesian3.add(dir1, dir2, new Cesium.Cartesian3());
            var avgPot = Cesium.Cartesian3.add(CurrP, avgDir, new Cesium.Cartesian3());
            leftPotsRes.push(Cesium.clone(avgPot));

            var rg1 = rightPots[_i * 2 + 0];
            var rg2 = rightPots[_i * 2 + 1];
            dir1 = Cesium.Cartesian3.subtract(rg1, CurrP, new Cesium.Cartesian3());
            dir2 = Cesium.Cartesian3.subtract(rg2, CurrP, new Cesium.Cartesian3());
            avgDir = Cesium.Cartesian3.add(dir1, dir2, new Cesium.Cartesian3());
            avgPot = Cesium.Cartesian3.add(CurrP, avgDir, new Cesium.Cartesian3());
            rightPotsRes.push(Cesium.clone(avgPot));
        }
    } else {
        marslog.warn("计算左右侧点出问题！");
        return;
    }

    var uvs = [];
    var vertexs = [];
    var vertexsH = [];
    var vertexsL = [];
    var indexs = [];

    //先记录右边点，后记录左边点、记录2遍为了分离UV
    for (var _i2 = 0; _i2 < len; _i2++) {
        var encodeRes = Cesium.EncodedCartesian3.fromCartesian(rightPotsRes[_i2]);
        vertexs.push(rightPotsRes[_i2].x);
        vertexs.push(rightPotsRes[_i2].y);
        vertexs.push(rightPotsRes[_i2].z);

        vertexsH.push(encodeRes.high.x);
        vertexsH.push(encodeRes.high.y);
        vertexsH.push(encodeRes.high.z);

        vertexsL.push(encodeRes.low.x);
        vertexsL.push(encodeRes.low.y);
        vertexsL.push(encodeRes.low.z);

        uvs.push(1, 1);

        //记录索引以及UV
        if (_i2 < len - 1) {
            indexs.push(_i2 + len * 2);
            indexs.push(_i2 + 1);
            indexs.push(_i2 + 1 + len);

            indexs.push(_i2 + len * 2);
            indexs.push(_i2 + 1 + len);
            indexs.push(len + _i2 + len * 2);
        }
    }
    for (var _i3 = 0; _i3 < len; _i3++) {
        var _encodeRes = Cesium.EncodedCartesian3.fromCartesian(leftPotsRes[_i3]);
        vertexs.push(leftPotsRes[_i3].x);
        vertexs.push(leftPotsRes[_i3].y);
        vertexs.push(leftPotsRes[_i3].z);

        vertexsH.push(_encodeRes.high.x);
        vertexsH.push(_encodeRes.high.y);
        vertexsH.push(_encodeRes.high.z);

        vertexsL.push(_encodeRes.low.x);
        vertexsL.push(_encodeRes.low.y);
        vertexsL.push(_encodeRes.low.z);

        uvs.push(1, 0);
    }

    for (var _i4 = 0; _i4 < len; _i4++) {
        var _encodeRes2 = Cesium.EncodedCartesian3.fromCartesian(rightPotsRes[_i4]);
        vertexs.push(rightPotsRes[_i4].x);
        vertexs.push(rightPotsRes[_i4].y);
        vertexs.push(rightPotsRes[_i4].z);

        vertexsH.push(_encodeRes2.high.x);
        vertexsH.push(_encodeRes2.high.y);
        vertexsH.push(_encodeRes2.high.z);

        vertexsL.push(_encodeRes2.low.x);
        vertexsL.push(_encodeRes2.low.y);
        vertexsL.push(_encodeRes2.low.z);

        uvs.push(0, 1);

        // if(i<len-1){
        //     // indexs.push(i + len*2);
        //     // indexs.push(i+1 + len*2);
        //     // indexs.push(i+1+len + len*2);

        //     // indexs.push(i + len*2);
        //     // indexs.push(i+1+len + len*2);
        //     // indexs.push(len+i + len*2);
        // }
    }
    for (var _i5 = 0; _i5 < len; _i5++) {
        var _encodeRes3 = Cesium.EncodedCartesian3.fromCartesian(leftPotsRes[_i5]);
        vertexs.push(leftPotsRes[_i5].x);
        vertexs.push(leftPotsRes[_i5].y);
        vertexs.push(leftPotsRes[_i5].z);

        vertexsH.push(_encodeRes3.high.x);
        vertexsH.push(_encodeRes3.high.y);
        vertexsH.push(_encodeRes3.high.z);

        vertexsL.push(_encodeRes3.low.x);
        vertexsL.push(_encodeRes3.low.y);
        vertexsL.push(_encodeRes3.low.z);

        uvs.push(0, 0);
    }

    return {
        left: leftPotsRes,
        right: rightPotsRes,
        self: lineArr,
        vertexs: new Float32Array(vertexs),
        vertexsH: new Float32Array(vertexsH),
        vertexsL: new Float32Array(vertexsL),
        indexs: new Uint16Array(indexs),
        uvs: new Float32Array(uvs)
    };
}

function RaisePoint(pot, height) {
    if (!(pot instanceof Cesium.Cartesian3)) {
        marslog.warn("请确认点是Cartesian3类型！");
        return;
    }
    if (!height || height == 0) {
        marslog.warn("请确认高度是非零数值！");
        return;
    }
    var dir = Cesium.Cartesian3.normalize(pot, new Cesium.Cartesian3());
    var ray = new Cesium.Ray(pot, dir);
    return Cesium.Ray.getPoint(ray, height);
}

function GetSides(firstP, sceondP, halfW) {
    var dir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(sceondP, firstP, new Cesium.Cartesian3()), new Cesium.Cartesian3());
    var nor = Cesium.Cartesian3.normalize(firstP, new Cesium.Cartesian3());
    var leftDir = Cesium.Cartesian3.cross(nor, dir, new Cesium.Cartesian3());
    var rightDir = Cesium.Cartesian3.cross(dir, nor, new Cesium.Cartesian3());
    var leftray = new Cesium.Ray(firstP, leftDir);
    var rightray = new Cesium.Ray(firstP, rightDir);
    var leftPot = Cesium.Ray.getPoint(leftray, halfW);
    var rightPot = Cesium.Ray.getPoint(rightray, halfW);
    return {
        left: leftPot,
        right: rightPot
    };
}

/***/ }),
/* 203 */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n\n    materialInput.s = v_st.s;\n    materialInput.st = v_st;\n    materialInput.str = vec3(v_st, 0.0);\n\n    // Convert tangent space material normal to eye space\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\n    // Convert view vector to world space\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n\n    #ifdef FLAT\n        gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n    #else\n        gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n    #endif\n}\n"

/***/ }),
/* 204 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"

/***/ }),
/* 205 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput) { \n    czm_material material = czm_getDefaultMaterial(materialInput); \n    vec2 st = materialInput.st;\n    if(move){\n        float r = sqrt((st.x-0.8)*(st.x-0.8) + (st.y-0.8)*(st.y-0.8));\n        float r2 = sqrt((st.x-0.2)*(st.x-0.2) + (st.y-0.2)*(st.y-0.2));\n        float z = cos(moveVar.x*r + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        float z2 = cos(moveVar.x*r2 + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        st += sqrt(z*z+z2*z2);\n        st.s += reflux * czm_frameNumber/1000.0 * speed;\n        st.s = mod(st.s,1.0);\n    }\n    if(flipY){\n        st = vec2(st.t,st.s);\n    }\n    vec4 colorImage = texture2D(image, st);\n    material.alpha = alpha;\n    material.diffuse = colorImage.rgb; \n    return material; \n}"

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParticleSystemEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//粒子效果封装，方便控制。
var ParticleSystemEx = exports.ParticleSystemEx = function () {

    //========== 构造方法 ========== 

    function ParticleSystemEx(viewer, options) {
        _classCallCheck(this, ParticleSystemEx);

        if (!viewer) return;

        this.viewer = viewer;
        this.options = options;

        this.viewer.clock.shouldAnimate = true;

        //一些临时数据
        this.emitterModelMatrix = new Cesium.Matrix4();
        this.translation = new Cesium.Cartesian3();
        this.rotation = new Cesium.Quaternion();
        this.hpr = new Cesium.HeadingPitchRoll();
        this.trs = new Cesium.TranslationRotationScale();

        //内部属性
        this.position = options.position; //中心点位置        
        this._show = Cesium.defaultValue(options.show, true);
        this._maxHeight = Cesium.defaultValue(options.maxHeight, 5000);
        this.gravity = Cesium.defaultValue(options.gravity, 0); //重力因子，会修改速度矢量以改变方向或速度（基于物理的效果）

        this.transX = Cesium.defaultValue(options.transX, 0);
        this.transY = Cesium.defaultValue(options.transY, 0);
        this.transZ = Cesium.defaultValue(options.transZ, 0);

        this.target = Cesium.defaultValue(options.target, new Cesium.Cartesian3(0, 0, 0)); //粒子的方向

        this._init(options);
    }

    //========== 对外属性 ==========  
    //显示隐藏


    _createClass(ParticleSystemEx, [{
        key: "_init",


        //========== 方法 ========== 
        value: function _init(options) {
            //默认值
            var viewModel = {
                startColor: Cesium.Color.LIGHTCYAN.withAlpha(0.3), //粒子出生时的颜色
                endColor: Cesium.Color.WHITE.withAlpha(0.0), //当粒子死亡时的颜色

                imageSize: new Cesium.Cartesian2(25, 25), //粒子图片的Size大小（单位：像素）
                // scale:1.0,//粒子的比例 
                startScale: 2.0, //粒子在出生时的比例（单位：相对于imageSize大小的倍数）
                endScale: 4.0, //粒子在死亡时的比例（单位：相对于imageSize大小的倍数）

                // particleLife:1.1, //粒子存在的时间（单位：秒）
                minimumParticleLife: 1.1, //粒子可能存在的最短寿命时间，实际寿命将随机生成（单位：秒）
                maximumParticleLife: 3.1, //粒子可能存在的最长寿命时间，实际寿命将随机生成（单位：秒）

                // speed:1.0,//粒子初速度
                minimumSpeed: 1.0, //粒子初速度的最小界限，超过该最小界限，随机选择粒子的实际速度。（单位：米/秒）
                maximumSpeed: 2.0, //粒子初速度的最大界限，超过该最大界限，随机选择粒子的实际速度。（单位：米/秒）

                emissionRate: 100, //粒子发射器的发射速率 （单位：次/秒）

                loop: true, //是否循环
                lifetime: 16.0, //生命周期（单位：秒）

                // bursts: [//而粒子会在5s、10s、15s时分别进行一次粒子大爆发 
                //     new Cesium.ParticleBurst({ time: 5.0, minimum: 10, maximum: 100 }),  // 当在5秒时，发射的数量为10-100
                //     new Cesium.ParticleBurst({ time: 10.0, minimum: 50, maximum: 100 }), // 当在10秒时，发射的数量为50-100
                //     new Cesium.ParticleBurst({ time: 15.0, minimum: 200, maximum: 300 })  // 当在15秒时，发射的数量为200-300
                // ],
                emitter: new Cesium.CircleEmitter(2.0), //此系统的粒子发射器(指定方向)，  共有 圆形、锥体、球体、长方体 ( BoxEmitter,CircleEmitter,ConeEmitter,SphereEmitter ) 几类

                modelMatrix: this._computeModelMatrix(this.viewer.clock.currentTime), // 4x4转换矩阵，可将粒子系统从模型转换为世界坐标 
                emitterModelMatrix: this._computeEmitterModelMatrix(this), // 4x4转换矩阵，用于在粒子系统本地坐标系中转换粒子系统发射器
                show: this._show
            };

            if (Cesium.defaultValue(options.hasDefUpdate, true)) {
                //回调函数，参数是(particle,dt)，分别是单个粒子的属性和两次发射之间的时间间隔(单位:s)
                var applyGravity = function applyGravity(particle, dt) {
                    var translatCar3 = that.target.clone();

                    var position = particle.position;
                    Cesium.Cartesian3.add(particle.position, translatCar3, particle.position);

                    var gravityScratch = new Cesium.Cartesian3();

                    Cesium.Cartesian3.normalize(position, gravityScratch);
                    Cesium.Cartesian3.multiplyByScalar(gravityScratch, that.gravity * dt, gravityScratch);
                    particle.velocity = Cesium.Cartesian3.add(particle.velocity, gravityScratch, particle.velocity);
                };

                var that = this;
                viewModel.updateCallback = applyGravity;
            }

            for (var key in options) {
                var value = options[key];
                switch (key) {
                    default:
                        //直接赋值
                        viewModel[key] = value;
                        break;
                    case "position": //跳过扩展其他属性的参数
                    case "modelMatrix":
                    case "gravity":
                        break;
                    case "particleSize":
                        viewModel.imageSize = new Cesium.Cartesian2(value, value);
                        break;
                }
            }

            //构造粒子对象
            this.particleSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem(viewModel));

            this.viewer.scene.preUpdate.addEventListener(this._scene_preUpdateHandler, this);

            //加控制，只在相机高度低于一定高度时才开启本效果
            this.viewer.scene.camera.changed.addEventListener(this._camera_changedHandler, this);
        }
    }, {
        key: "_scene_preUpdateHandler",
        value: function _scene_preUpdateHandler(scene, time) {
            if (!this.particleSystem) return;

            this.particleSystem.modelMatrix = this._computeModelMatrix(time);
            this.particleSystem.emitterModelMatrix = this._computeEmitterModelMatrix(this);
        }
    }, {
        key: "_computeModelMatrix",
        value: function _computeModelMatrix(time) {
            if (this.position) {
                var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(this.position);
                // var hprRotation = Cesium.Matrix3.fromHeadingPitchRoll(new Cesium.HeadingPitchRoll(2.619729, 0.0, 0.0));
                // var hpr = Cesium.Matrix4.fromRotationTranslation(hprRotation, new Cesium.Cartesian3(0.0, 0.0, -2.0));
                // Cesium.Matrix4.multiply(modelMatrix, hpr, modelMatrix);
                return modelMatrix;
            } else if (this.options.modelMatrix) {
                return this.options.modelMatrix(time);
            }
        }
    }, {
        key: "_computeEmitterModelMatrix",
        value: function _computeEmitterModelMatrix(that) {
            that.hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0, that.hpr);
            that.trs.translation = Cesium.Cartesian3.fromElements(that.transX, that.transY, that.transZ, that.translation);
            that.trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(that.hpr, that.rotation);

            Cesium.Matrix4.fromTranslationRotationScale(that.trs, that.emitterModelMatrix);

            // var translatCar3 = new Cesium.Cartesian3(-2, -2, 2);
            // Cesium.Matrix4.multiplyByTranslation(that.emitterModelMatrix, translatCar3, that.emitterModelMatrix);
            return that.emitterModelMatrix;
        }
    }, {
        key: "_camera_changedHandler",
        value: function _camera_changedHandler(event) {
            if (this.viewer.camera.positionCartographic.height < this._maxHeight) {
                if (this.particleSystem.show != this._show) this.particleSystem.show = this._show;
            } else {
                if (this.particleSystem.show) this.particleSystem.show = false;
            }
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            this.viewer.scene.preUpdate.removeEventListener(this._scene_preUpdateHandler, this);
            this.viewer.scene.camera.changed.removeEventListener(this._camera_changedHandler, this);

            this.viewer.scene.primitives.remove(this.particleSystem);

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(val) {
            this._show = val;
            if (this.particleSystem) this.particleSystem.show = this._show;
        }

        //修改Image大小

    }, {
        key: "particleSize",
        get: function get() {
            return this.particleSize || 25;
        },
        set: function set(particleSize) {
            if (!this.particleSystem) return;

            this.particleSystem.minimumImageSize.x = particleSize;
            this.particleSystem.minimumImageSize.y = particleSize;
            this.particleSystem.maximumImageSize.x = particleSize;
            this.particleSystem.maximumImageSize.y = particleSize;
        }
    }]);

    return ParticleSystemEx;
}();

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlatBillboard = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _FlatBillboardFS = __webpack_require__(208);

var _FlatBillboardFS2 = _interopRequireDefault(_FlatBillboardFS);

var _FlatBillboardVS = __webpack_require__(209);

var _FlatBillboardVS2 = _interopRequireDefault(_FlatBillboardVS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//平放的图标
//目前DrawCommand单向渲染的，无法鼠标单击拾取对象 
var FlatBillboard = exports.FlatBillboard = function () {
  //========== 构造方法 ========== 
  function FlatBillboard(viewer, options) {
    _classCallCheck(this, FlatBillboard);

    this.viewer = viewer;
    this.options = options || {};

    this.width = options.width || options.size || 50;
    this.height = Cesium.defaultValue(options.height, this.width);
    this.show = Cesium.defaultValue(options.show, true);

    var oldVal = Cesium.defaultValue(options.distanceDisplayCondition, new Cesium.DistanceDisplayCondition(0, 5000000));
    this.distanceDisplayCondition = new Cesium.Cartesian2(oldVal.near, oldVal.far);

    this.textureDef = new Cesium.Texture({
      context: this.viewer.scene.context,
      width: 500,
      height: 500
    });
    this.textures = {};

    if (options.data) this.init(options.data);

    this._pickId = this.viewer.scene.context.createPickId({
      id: "FlatBillboard",
      primitive: this
    });
  }

  //========== 对外属性 ==========  
  //数据


  _createClass(FlatBillboard, [{
    key: "init",


    //========== 方法 ========== 
    value: function init(arrdata) {
      this.clear();

      this.options.data = arrdata;

      if (this.billboardCollection) {
        this.addBillboardCollection();
      }

      //按图片分组
      var imaObj = {};
      for (var i = 0, len = arrdata.length; i < len; i++) {
        var item = arrdata[i];

        if (!imaObj[item.image]) imaObj[item.image] = [];

        imaObj[item.image].push(item);
      }

      var commands = [];
      for (var key in imaObj) {
        var arr = imaObj[key];
        var image = key;

        //加载图片
        this.prepareTexture(image);

        //生成Command
        var VAO = this.prepareVAO(arr);
        var command = this.prepareCommand(VAO, image);
        commands.push(command);
      }
      this.commands = commands;

      this.render();
    }
  }, {
    key: "prepareTexture",
    value: function prepareTexture(imgUrl) {
      var _this = this;

      var image = new Image();
      image.onload = function (e) {
        var texture = new Cesium.Texture({
          context: _this.viewer.scene.context,
          source: image
        });
        _this.textures[imgUrl] = texture;
      };
      image.src = imgUrl;
    }
  }, {
    key: "prepareVAO",
    value: function prepareVAO(points) {
      var vertexs_H = [];
      var vertexs_L = [];
      var indexs = [];
      var uvs = [];
      var colors = [];
      for (var i = 0, len = points.length; i < len; i++) {
        var currP = points[i];
        var currCar = currP.position;
        var angle = currP.angle;

        indexs.push(i * 4 + 0);
        indexs.push(i * 4 + 2);
        indexs.push(i * 4 + 1);
        indexs.push(i * 4 + 0);
        indexs.push(i * 4 + 3);
        indexs.push(i * 4 + 2);

        // 伪造双精度数据 
        var currDF = new Float32Array(6);
        currDF[0] = currCar.x;
        currDF[1] = currCar.x - currDF[0];
        currDF[2] = currCar.y;
        currDF[3] = currCar.y - currDF[2];
        currDF[4] = currCar.z;
        currDF[5] = currCar.z - currDF[4];

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        uvs.push(0, 0);
        uvs.push(0, 1);
        uvs.push(1, 1);
        uvs.push(1, 0);
        var trans = Cesium.Transforms.eastNorthUpToFixedFrame(currCar);
        var mz = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(angle));
        var rotationZ = Cesium.Matrix4.fromRotationTranslation(mz);
        var currMat = Cesium.Matrix4.multiply(trans, rotationZ, new Cesium.Matrix4());

        var heightScale = this.height / this.width;

        var zxj = new Cesium.Cartesian3(-1, -heightScale, 0);
        Cesium.Matrix4.multiplyByPointAsVector(currMat, zxj, zxj);
        Cesium.Cartesian3.normalize(zxj, zxj);
        colors.push(zxj.x, zxj.y, zxj.z);

        var zsj = new Cesium.Cartesian3(-1, heightScale, 0);
        Cesium.Matrix4.multiplyByPointAsVector(currMat, zsj, zsj);
        Cesium.Cartesian3.normalize(zsj, zsj);
        colors.push(zsj.x, zsj.y, zsj.z);

        var ysj = new Cesium.Cartesian3(1, heightScale, 0);
        Cesium.Matrix4.multiplyByPointAsVector(currMat, ysj, ysj);
        Cesium.Cartesian3.normalize(ysj, ysj);
        colors.push(ysj.x, ysj.y, ysj.z);

        var yxj = new Cesium.Cartesian3(1, -heightScale, 0);
        Cesium.Matrix4.multiplyByPointAsVector(currMat, yxj, yxj);
        Cesium.Cartesian3.normalize(yxj, yxj);
        colors.push(yxj.x, yxj.y, yxj.z);
      }

      return {
        index: new Uint16Array(indexs),
        vertex_H: {
          values: new Float32Array(vertexs_H),
          componentDatatype: "DOUBLE",
          componentsPerAttribute: 3
        },
        vertex_L: {
          values: new Float32Array(vertexs_L),
          componentDatatype: "DOUBLE",
          componentsPerAttribute: 3
        },
        uv: {
          values: new Float32Array(uvs),
          componentDatatype: "FLOAT",
          componentsPerAttribute: 2
        },
        color: {
          values: new Float32Array(colors),
          componentDatatype: "FLOAT",
          componentsPerAttribute: 3
        }
      };
    }
  }, {
    key: "prepareCommand",
    value: function prepareCommand(VAO, imgUrl) {
      var context = this.viewer.scene.context;

      var width = context.drawingBufferWidth;
      var height = context.drawingBufferHeight;
      var sp = Cesium.ShaderProgram.fromCache({
        context: context,
        vertexShaderSource: _FlatBillboardVS2.default,
        fragmentShaderSource: _FlatBillboardFS2.default,
        attributeLocations: {
          position3DHigh: 0,
          position3DLow: 1,
          color: 2,
          st: 3
        }
      });

      var indexBuffer = Cesium.Buffer.createIndexBuffer({
        context: context,
        typedArray: VAO.index,
        usage: Cesium.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium.IndexDatatype.UNSIGNED_SHORT
      });

      var va = new Cesium.VertexArray({
        context: context,
        attributes: [{
          index: 0,
          vertexBuffer: Cesium.Buffer.createVertexBuffer({
            context: context,
            typedArray: VAO.vertex_H.values,
            usage: Cesium.BufferUsage.STATIC_DRAW
          }),
          componentsPerAttribute: 3
        }, {
          index: 1,
          vertexBuffer: Cesium.Buffer.createVertexBuffer({
            context: context,
            typedArray: VAO.vertex_L.values,
            usage: Cesium.BufferUsage.STATIC_DRAW
          }),
          componentsPerAttribute: 3
        }, {
          index: 2,
          vertexBuffer: Cesium.Buffer.createVertexBuffer({
            context: context,
            typedArray: VAO.color.values,
            usage: Cesium.BufferUsage.STATIC_DRAW
          }),
          componentsPerAttribute: 3
        }, {
          index: 3,
          vertexBuffer: Cesium.Buffer.createVertexBuffer({
            context: context,
            typedArray: VAO.uv.values,
            usage: Cesium.BufferUsage.STATIC_DRAW
          }),
          componentsPerAttribute: 2
        }],
        indexBuffer: indexBuffer
      });

      var rs = Cesium.RenderState.fromCache();
      var that = this;
      var bs = Cesium.BoundingSphere.fromVertices(VAO.vertex_H.values);
      bs.radius = 1000000;
      // rs.depthMask = true;

      var command = new Cesium.DrawCommand({
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        shaderProgram: sp,
        vertexArray: va,
        modelMatrix: Cesium.Matrix4.IDENTITY,
        pickOnly: true,
        renderState: rs,
        boundingVolume: bs,
        uniformMap: {
          mm: function mm() {
            // return that.viewer.scene.camera.frustum._offCenterFrustum._perspectiveMatrix;
            if (that.viewer.scene.camera.frustum._offCenterFrustum) return that.viewer.scene.camera.frustum._offCenterFrustum._perspectiveMatrix;else return that.viewer.scene.camera.frustum._orthographicMatrix;
          },
          vv: function vv() {
            return that.viewer.scene.camera._viewMatrix;
          },
          resolution: function resolution() {
            return new Cesium.Cartesian2(width, height);
          },
          billWidth: function billWidth() {
            return that.width * 2;
          },
          billImg: function billImg() {
            return that.textures[imgUrl] || that.textureDef;
          },
          u_distanceDisplayCondition: function u_distanceDisplayCondition() {
            return that.distanceDisplayCondition;
          },
          u_eyePos: function u_eyePos() {
            return that.viewer.scene.camera.positionWC;
          }
        },
        castShadows: false,
        receiveShadows: false,
        pass: Cesium.Pass.TRANSLUCENT,
        pickCommand: new Cesium.DrawCommand({
          owner: this,
          pickOnly: true
        })
      });
      return command;
    }
  }, {
    key: "render",
    value: function render() {
      this.viewer.scene.primitives.add(this);
    }
  }, {
    key: "update",
    value: function update(frameState) {
      if (!this.show) {
        if (this.billboardCollection) {
          this.removeBillboardCollection();
        }
        return;
      }

      if (frameState.mode === Cesium.SceneMode.SCENE3D) {
        //三维模式下
        var commandList = frameState.commandList;
        if (commandList && this.commands) {
          commandList.push.apply(commandList, _toConsumableArray(this.commands));
        }

        if (this.billboardCollection) {
          this.removeBillboardCollection();
        }
      } else {
        if (!this.billboardCollection) {
          this.addBillboardCollection();
        }
      }
    }
  }, {
    key: "removeBillboardCollection",
    value: function removeBillboardCollection() {
      if (!this.billboardCollection) return;

      this.viewer.scene.primitives.remove(this.billboardCollection);
      delete this.billboardCollection;
    }
  }, {
    key: "addBillboardCollection",
    value: function addBillboardCollection() {
      var arrdata = this.data;
      if (!arrdata) return;

      if (this.billboardCollection) {
        this.removeBillboardCollection();
      }
      this.billboardCollection = new Cesium.BillboardCollection({ scene: this.viewer.scene });
      this.viewer.scene.primitives.add(this.billboardCollection);

      for (var i = 0, len = arrdata.length; i < len; i++) {
        var item = arrdata[i];

        var primitive = this.billboardCollection.add({
          position: item.position,
          image: item.image,
          rotation: Cesium.Math.toRadians(item.angle),
          scale: 1,
          width: this.width,
          height: this.height
        });

        primitive.data = item.data || item;
        primitive.tooltip = this.options.tooltip;
        primitive.popup = this.options.popup;
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.options && this.options.data) this.options.data = null;

      if (this.commands) {
        delete this.commands;
      }

      for (var key in this.textures) {
        if (this.textures[key]) {
          this.textures[key].destroy();
        }
      }
      this.textures = {};

      if (this.billboardCollection) {
        this.billboardCollection.removeAll();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.primitives.remove(this);
      if (!this.viewer) return;

      this.clear();
      this.removeBillboardCollection();

      this.textureDef.destroy();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "data",
    get: function get() {
      return this.options.data;
    },
    set: function set(val) {
      this.init(val);
    }
  }]);

  return FlatBillboard;
}();

/***/ }),
/* 208 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform vec2 u_distanceDisplayCondition;\nuniform vec3 u_eyePos;\nvarying vec3 v_worldPos;\nuniform sampler2D billImg;\nvarying vec2 v_st;\nvoid main() {\n    float dis = distance(u_eyePos, v_worldPos);\n    if (dis < u_distanceDisplayCondition.x || dis > u_distanceDisplayCondition.y) {\n        discard;\n    } else {\n        gl_FragColor = texture2D(billImg,v_st);\n    }\n}"

/***/ }),
/* 209 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 color;\nattribute vec2 st;\nattribute float batchId;\nuniform mat4 mm;\nuniform mat4 vv;\nuniform vec2 resolution;\nuniform float billWidth;\nvarying vec2 v_st;\nvarying vec3 v_worldPos;\nvec4 transform(mat4 m,mat4 v,vec3 coord) {\n    return m * v * vec4(coord, 1.0);\n}\nvec2 project(vec4 device) {\n    vec3 device_normal = device.xyz / device.w;\n    vec2 clip_pos = (device_normal * 0.5 + 0.5).xy;\n    return clip_pos * resolution;\n}\nvec4 unproject(vec2 screen, float z, float w) {\n    vec2 clip_pos = screen / resolution;\n    vec2 device_normal = clip_pos * 2.0 - 1.0;\n    return vec4(device_normal * w, z, w);\n}\nvoid main() { \n    v_st = st;\n    vec3 currP = position3DHigh.xyz + position3DLow.xyz;\n    v_worldPos = currP;\n    vec4 eyeCurrP = transform(mm,vv,currP);\n    vec2 winCurrP = project(eyeCurrP);\n    vec3 dirEye = czm_viewRotation * color;\n    dirEye = normalize(dirEye);\n    vec2 newWinCurrP = winCurrP + dirEye.xy * billWidth;\n    gl_Position = unproject(newWinCurrP, eyeCurrP.z, eyeCurrP.w);\n    gl_PointSize = billWidth;\n}"

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FlatImage = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _FlatImageMaterial = __webpack_require__(211);

var _FlatImageMaterial2 = _interopRequireDefault(_FlatImageMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//平放的图片（图片随地图缩放） 
var FlatImage = exports.FlatImage = function () {
    //========== 构造方法 ========== 
    function FlatImage(viewer, options) {
        _classCallCheck(this, FlatImage);

        this.viewer = viewer;
        this.options = options || {};

        this.size = Cesium.defaultValue(options.size, 50);
        this._show = Cesium.defaultValue(options.show, true);

        //
        var primitiveCollection = new Cesium.PrimitiveCollection();
        primitiveCollection.show = this._show;
        this.viewer.scene.primitives.add(primitiveCollection);

        this.primitiveCollection = primitiveCollection;

        if (options.data) this.init(options.data);
    }

    //========== 对外属性 ==========  
    //数据


    _createClass(FlatImage, [{
        key: "init",


        //========== 方法 ========== 
        value: function init(arrdata) {
            this.clear();

            for (var i = 0, len = arrdata.length; i < len; i++) {
                var item = arrdata[i];
                var primitive = this.createPrimitive(item, item.size || this.size);
                this.primitiveCollection.add(primitive);
            }
        }
    }, {
        key: "createPrimitive",
        value: function createPrimitive(item, size) {
            var mat4 = Cesium.Transforms.eastNorthUpToFixedFrame(item.position);

            var mz = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(item.angle));
            var rotationZ = Cesium.Matrix4.fromRotationTranslation(mz);
            Cesium.Matrix4.multiply(mat4, rotationZ, mat4);

            var vertices = new Float64Array([//顶点坐标
            -size, -size, 0, size, -size, 0, size, size, 0, -size, size, 0]);
            var st = new Float32Array([//纹理坐标
            0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]);
            //let positions=new Float64Array;
            var attributes = new Cesium.GeometryAttributes();
            var indices = new Uint16Array(6); //顶点索引
            indices[0] = 0;
            indices[1] = 1;
            indices[2] = 2;
            indices[3] = 0;
            indices[4] = 2;
            indices[5] = 3;
            attributes.position = new Cesium.GeometryAttribute({ //顶点attributes
                componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: vertices
            });
            attributes.st = new Cesium.GeometryAttribute({
                componentDatatype: Cesium.ComponentDatatype.FLOAT,
                componentsPerAttribute: 2,
                values: st
            });
            //自定义几何图形时，使用图片纹理，需要自己设置st,normal属性
            var rect = new Cesium.Geometry({
                attributes: attributes,
                primitiveType: Cesium.PrimitiveType.TRIANGLES,
                indices: indices,
                boundingSphere: Cesium.BoundingSphere.fromVertices(vertices)
            });
            Cesium.GeometryPipeline.computeNormal(rect);
            var instance = new Cesium.GeometryInstance({
                geometry: rect,
                modelMatrix: mat4,
                id: 'flatImage'
            });

            var primitive = new Cesium.Primitive({
                geometryInstances: [instance],
                appearance: new Cesium.MaterialAppearance({
                    flat: true,
                    material: new Cesium.Material({
                        fabric: {
                            uniforms: {
                                image: item.image,
                                speed: 0.0
                            },
                            source: _FlatImageMaterial2.default
                        }
                    }),
                    materialSupport: Cesium.MaterialAppearance.MaterialSupport.TEXTURED
                }),
                compressVertices: false,
                asynchronous: false
            });

            primitive.tooltip = item.tooltip;
            primitive.popup = item.popup;

            // let speed = 0.0;
            // const setIntervalID = setInterval(function () {//如果使用scene.preUpdate等帧刷新，则图片不显示
            //     if (speed <= 1.0) {
            //         speed += 0.05;
            //     } else {
            //         clearInterval(setIntervalID);
            //         speed = 0.0
            //     }
            //     primitive.appearance.material.uniforms.speed = speed;
            // }, 500)

            return primitive;
        }
    }, {
        key: "clear",
        value: function clear() {
            this.primitiveCollection.removeAll();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.clear();
            this.viewer.scene.primitives.remove(this.primitiveCollection);

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "data",
        get: function get() {
            return this.options.data;
        },
        set: function set(val) {
            this.options.data = val;
            this.init(val);
        }

        //数据

    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(val) {
            this._show = val;
            if (this.primitiveCollection) this.primitiveCollection.show = this._show;
        }
    }]);

    return FlatImage;
}();

/***/ }),
/* 211 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput){\n    float isRed=step(speed,materialInput.st.x);\n    vec3 red;\n    if(isRed==0.0){\n        red = vec3(1.0,0.0,0.1);\n    }\n    else{\n        red = vec3(1.0,1.0,1.0);\n    }\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = czm_gammaCorrect(texture2D(image, fract(materialInput.st)).rgb *red); \n    \n    material.alpha = texture2D(image, fract(materialInput.st)).a;\n    return material;\n} "

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConeGlow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

exports.getCirclePosition = getCirclePosition;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _point = __webpack_require__(2);

var _ConeGlowCircleOuterMaterial = __webpack_require__(213);

var _ConeGlowCircleOuterMaterial2 = _interopRequireDefault(_ConeGlowCircleOuterMaterial);

var _ConeGlowCylinderGaussMaterial = __webpack_require__(214);

var _ConeGlowCylinderGaussMaterial2 = _interopRequireDefault(_ConeGlowCylinderGaussMaterial);

var _ConeGlowGradientMaterial = __webpack_require__(215);

var _ConeGlowGradientMaterial2 = _interopRequireDefault(_ConeGlowGradientMaterial);

var _ConeGlowRingScanMaterial = __webpack_require__(216);

var _ConeGlowRingScanMaterial2 = _interopRequireDefault(_ConeGlowRingScanMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//光柱
var ConeGlow = exports.ConeGlow = function (_MarsClass) {
    _inherits(ConeGlow, _MarsClass);

    function ConeGlow(viewer, options) {
        _classCallCheck(this, ConeGlow);

        var _this = _possibleConstructorReturn(this, (ConeGlow.__proto__ || Object.getPrototypeOf(ConeGlow)).call(this, options));

        _this.viewer = viewer;
        _this.options = options;

        _this.position = options.position; //中心点
        _this.extrudedHeight = Cesium.defaultValue(options.height, 1000);
        _this.u_color = Cesium.defaultValue(options.color, Cesium.Color.fromCssColorString("#00ffff"));
        _this._show = Cesium.defaultValue(options.show, true);
        _this._distanceDisplayCondition = Cesium.defaultValue(options.distanceDisplayCondition, new Cesium.DistanceDisplayConditionGeometryInstanceAttribute());

        var radius = Cesium.defaultValue(options.radius, 100);

        _this.topRadius = radius / 100.0;
        _this.topRadius = _this.topRadius > 1.0 ? 1.0 : _this.topRadius;
        _this.inner_controlPoints = getCirclePosition(_this.position, radius * 0.7);
        _this.outer_controlPoints = getCirclePosition(_this.position, radius); //计算底部外圈
        _this.circular_clone_topPoints = getCirclePosition(_this.position, _this.topRadius); //计算顶部
        _this.circlePoints_2 = getCirclePosition(_this.position, radius * 2); //计算顶部

        _this.primitive1 = null; //外圈
        _this.primitive2 = null; //内圈
        _this.primitive3 = null; //底部圆
        _this.primitive4 = null; //底部放大钰圆环

        _this.ringCanvas = _this.drawRingCanvas();
        _this.gradientCircleCanvas = _this.cirdrawGradientCircleCanvas();

        //兼容直接传入单击回调方法，适合简单场景下使用。
        if (options.click) {
            _this.on(_MarsClass2.eventType.click, options.click);
        }

        _this.draw();
        return _this;
    }

    //========== 对外属性 ==========   


    _createClass(ConeGlow, [{
        key: "draw",


        //========== 方法 ========== 

        value: function draw() {
            var _this2 = this;

            this.getParticleImage(function () {
                _this2.addOuter(); //外圈
            });

            this.addInner(); //内圈
            this.addCircle(); //底部圆
            this.addRing(); //底部放大钰圆环
        }
    }, {
        key: "addOuter",


        //添加绘制外圈粒子效果
        value: function addOuter() {
            var side_instances = createCylinderInstance(this.outer_controlPoints, this.circular_clone_topPoints, {
                height: this.extrudedHeight,
                distanceDisplayCondition: this._distanceDisplayCondition
            });
            this.primitive1 = new Cesium.Primitive({
                geometryInstances: side_instances,
                appearance: new Cesium.EllipsoidSurfaceAppearance({
                    material: new Cesium.Material({
                        fabric: {
                            uniforms: {
                                u_color: this.u_color,
                                image: this.image
                            },
                            source: _ConeGlowCircleOuterMaterial2.default
                        }
                    })
                }),
                asynchronous: false
            });
            this.primitive1.tooltip = this.options.tooltip;
            this.primitive1.popup = this.options.popup;
            this.primitive1.eventTarget = this;
            this.viewer.scene.primitives.add(this.primitive1);
        }
    }, {
        key: "addInner",


        //添加绘制内圈圆柱闪烁效果
        value: function addInner() {
            var side_instances = createCylinderInstance(this.inner_controlPoints, this.circular_clone_topPoints, {
                height: this.extrudedHeight,
                color: this.v_color,
                distanceDisplayCondition: this._distanceDisplayCondition
            });
            var a = new Cesium.EllipsoidSurfaceAppearance({
                material: new Cesium.Material({
                    //translucent:false,
                    fabric: {
                        uniforms: {
                            u_color: this.u_color
                        },
                        source: _ConeGlowCylinderGaussMaterial2.default
                    }
                })
            });
            this.primitive2 = new Cesium.Primitive({
                geometryInstances: side_instances,
                appearance: a,
                asynchronous: false
            });
            this.primitive2.tooltip = this.options.tooltip;
            this.primitive2.popup = this.options.popup;
            this.primitive2.eventTarget = this;
            this.primitive2.show = this._show;
            this.viewer.scene.primitives.add(this.primitive2);
        }
    }, {
        key: "addCircle",


        //绘制底部圆
        value: function addCircle() {
            var carto = Cesium.Cartographic.fromCartesian(this.position);
            var instance = createCircleInstance(this.circlePoints_2, {
                perPositionHeight: carto.height >= 1,
                distanceDisplayCondition: this._distanceDisplayCondition
            });
            this.primitive3 = new Cesium.Primitive({
                geometryInstances: instance,
                appearance: new Cesium.EllipsoidSurfaceAppearance({
                    material: new Cesium.Material({
                        fabric: {
                            uniforms: {
                                u_color: this.u_color,
                                image: this.gradientCircleCanvas
                            },
                            source: _ConeGlowGradientMaterial2.default
                        }
                    })
                }),
                asynchronous: false
            });

            this.primitive3.tooltip = this.options.tooltip;
            this.primitive3.popup = this.options.popup;
            this.primitive3.eventTarget = this;
            this.primitive3.show = this._show;
            this.viewer.scene.primitives.add(this.primitive3);
        }
    }, {
        key: "addRing",


        //添加绘制底部扩散圆环
        value: function addRing() {
            var carto = Cesium.Cartographic.fromCartesian(this.position);
            var instance = createCircleInstance(this.circlePoints_2, {
                perPositionHeight: carto.height >= 1,
                distanceDisplayCondition: this._distanceDisplayCondition
            });
            this.primitive4 = new Cesium.Primitive({
                geometryInstances: instance,
                appearance: new Cesium.EllipsoidSurfaceAppearance({
                    material: new Cesium.Material({
                        fabric: {
                            uniforms: {
                                u_color: this.u_color,
                                image: this.ringCanvas
                            },
                            source: _ConeGlowRingScanMaterial2.default
                        }
                    })
                }),
                asynchronous: false
            });

            this.primitive4.tooltip = this.options.tooltip;
            this.primitive4.popup = this.options.popup;
            this.primitive4.eventTarget = this;
            this.primitive4.show = this._show;
            this.viewer.scene.primitives.add(this.primitive4);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            if (this.primitive1) {
                this.viewer.scene.primitives.remove(this.primitive1);
            }
            if (this.primitive2) {
                this.viewer.scene.primitives.remove(this.primitive2);
            }
            if (this.primitive3) {
                this.viewer.scene.primitives.remove(this.primitive3);
            }
            if (this.primitive4) {
                this.viewer.scene.primitives.remove(this.primitive4);
            }
            _get(ConeGlow.prototype.__proto__ || Object.getPrototypeOf(ConeGlow.prototype), "destroy", this).call(this);
        }
    }, {
        key: "getParticleImage",


        //================材质贴图Canvas ====================
        //画粒子图
        value: function getParticleImage(callback) {
            var image = new Image();
            image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAEACAYAAADSoXR2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExQTg0NDEyMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjExQTg0NDEzMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTFBODQ0MTAwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTFBODQ0MTEwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz41vRwAAAAE90lEQVR42uydyW4UMRCG3T2dgYSAEGs4sp44cCJBcGUJbwCvALwWPAI8ABwAiUVwgLBdkEikJEiAGMhkZqhfU1aa1sy0g+yaJPyWSupOpPjz0uVyucrJer2eG2fJ3ZgLAQhAgC0PgN8XIlkqgGLE75oih0WmRVZEvop0rHog18rnRe6IzInsthyCXFt+TuSKyGmRXZZDgK5eFrkv8l7kiUhrxN/JSo3pigSvcNmI1bCh3b5LK2+NqHyvyEF9x3z5HgqRRViOAXhW5JrCoNdei/y20gMYxhmRSyIXRY6JTMT4DENLW+SdyD19x/NajDmwmYIW79Hnn+MA4GJEAAIQgABJbMJB+n5Sl9zWZvR9DABUfkJkVt8fi3zUldAEoKl24Y2S1fPZEmBdZFHkkb4vxTLRQ5djbyUf0ncYrD/UADUB8MZno2Q19yx7gIqIAAQgAAEIQIAtYZT+85LvRnjQCoPKR3rQUgN4Y3ZeK30g8qps0qeeAzDn4TWD9+ySG+BBS90DaGnVg9a2tgnR4il9/jkOACoiAhCAAASIZpAAFl6yulO0JACo/IDrn6CedP1zxOciv6wAYNnAP3RVBeWtJQCWzG8iL/X9g4vkqNzMctzUXtintt2KM/aS+bmQaY90rb8CF6tSKiICEIAABCAAAQiwbfcFIWVCbUcc9bZDLKiYAKj4uOv7Bb+ILLj+8W7PCgC7Jhzv44Qdh9yrru8V61jPgd645gD2io+15RiC5ZA5ENNPmGmDmtrta9YAVEQE2FlrQUM/J6efU8cSAD87ojodBaccS6kgiiErGiq/qe93XT+3oGU5BJnbyKrIUs6BQZoQUEcrQ7CYagiGqeKiMgnXLXsg5uJUm/RQJKy8fGS7PMw6SgVQPrJFGZr0kCfUL/7IFjIzrLGpemBQ0kPbehL6I9vMjUh6oEVEAAIQgAAEIAABdpyj0qcK71YrqGUJANNrv+sHOcAiRpDDM1cTY1BEHk7kqyP/2Ac5vLEEQEG8aDnIoTb5ObZRWg5ywG5o1dX4ClNYxT7IISgJPsXGpLut9MCWU0S5bqkmdAa3LQEwcZDAfkZ3tthQfkwNkVeeD6kiuaUabcp6DpS9YyalrAdQ8bT1EFQVUabarND9fNuyB2gREYAABCAAAQhAAAIQoM770UgBXARCIr/koDogVlzgrWuxemBKd0m4JnBed0+5ZQ9gn3BK5LK+P4y5ewoB8DFiKO91COLFfwVuTCZV1hSoYw1APZCsFIkbN1Haaa87wwiKQe6eT27AEX6esPVVd8/kOOdAz/oz9FE0p+uGIKUeqE5C8xgSKiICEIAABCAAAQhAAAIQgAAEIAABCECA6AA+sbkREyDUUYlKD6ggZwzRkr8tewBhusisv+0in5qE/hFchoZTE0TL4p8sTbtIpyahQ4Ag5fKpSVBmfdDECvQTZjoM0U9N6KgkwH9xY7PXpPiCmq5yuaLVldHIO7jgNi5XfOEhCqNh9udHV/RnC5YAUDTftdV4/ivvwEoRVS9XXPWa1FIT5ird8jpSB+BDN3rO8AaGMnGy0I0QRYTvdk6NkOsucuhGCMAgI8Q0isaHbmAevNMhiD4P6iZhstANGiQE2PEGCRo2NcgAsQDwKnxWFdlT17/duWU1BJmuHz6A5bwbEsCScgh+qAHit3Jr1oooOPExdRBLbeJjSpuwuy30AAH+CDAAPH5ltESNYl4AAAAASUVORK5CYII=';
            image.onload = function () {
                this.image = this.drawCanvas(image);
                if (callback) callback();
            }.bind(this);
        }
    }, {
        key: "drawCanvas",
        value: function drawCanvas(image) {
            var canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 256;
            var ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, 64, 256);
            ctx.drawImage(image, 0, 0);
            ctx.drawImage(image, 33, 0);
            return canvas;
        }

        //画圆环图

    }, {
        key: "drawRingCanvas",
        value: function drawRingCanvas() {
            var canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            var ctx = canvas.getContext('2d');

            //ctx.clearRect(0,0,512,512);
            ctx.fillStyle = 'rgba(255,255,255,0)';
            ctx.strokeStyle = "rgba(255, 255, 255,255)";
            ctx.setLineDash([50, 50]);
            ctx.lineWidth = 30;
            ctx.beginPath();
            ctx.arc(256, 256, 150, 0, Math.PI * 2, true);
            ctx.stroke();
            ctx.restore();
            return canvas;
        }

        //画渐变圆

    }, {
        key: "cirdrawGradientCircleCanvas",
        value: function cirdrawGradientCircleCanvas() {
            var canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            var ctx = canvas.getContext('2d');

            var gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0.1, "rgba(255, 255, 255, 1.0)");
            gradient.addColorStop(0.2, "rgba(255, 255, 255, 0.0)");
            gradient.addColorStop(0.3, "rgba(255, 255, 255, 0.9)");
            gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.0)");
            gradient.addColorStop(0.9, "rgba(255, 255, 255, 0.2)");
            gradient.addColorStop(1.0, "rgba(255, 255, 255, 1.0)");

            ctx.clearRect(0, 0, 512, 512);
            ctx.beginPath();
            ctx.arc(256, 256, 256, 0, Math.PI * 2, true);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();

            return canvas;
        }
    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(value) {
            this._show = value;

            if (this.primitive1) {
                this.primitive1.show = value;
            }
            if (this.primitive2) {
                this.primitive2.show = value;
            }
            if (this.primitive3) {
                this.primitive3.show = value;
            }
            if (this.primitive4) {
                this.primitive4.show = value;
            }
        }
    }, {
        key: "popup",
        get: function get() {
            return this.options.popup;
        },
        set: function set(value) {
            this.options.popup = value;

            if (this.primitive1) {
                this.primitive1.popup = value;
            }
            if (this.primitive2) {
                this.primitive2.popup = value;
            }
            if (this.primitive3) {
                this.primitive3.popup = value;
            }
            if (this.primitive4) {
                this.primitive4.popup = value;
            }
        }
    }, {
        key: "tooltip",
        get: function get() {
            return this.options.tooltip;
        },
        set: function set(value) {
            this.options.tooltip = value;

            if (this.primitive1) {
                this.primitive1.tooltip = value;
            }
            if (this.primitive2) {
                this.primitive2.tooltip = value;
            }
            if (this.primitive3) {
                this.primitive3.tooltip = value;
            }
            if (this.primitive4) {
                this.primitive4.tooltip = value;
            }
        }
    }]);

    return ConeGlow;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


ConeGlow.event = {
    click: _MarsClass2.eventType.click

    //创建 圆 效果
};function createCircleInstance(pos, options) {
    var polygon = new Cesium.PolygonGeometry({
        polygonHierarchy: new Cesium.PolygonHierarchy(pos),
        perPositionHeight: options.perPositionHeight
    });
    return new Cesium.GeometryInstance({
        geometry: polygon,
        attributes: {
            distanceDisplayCondition: options.distanceDisplayCondition
        }
    });
}

//创建 圆锥柱体 效果
function createCylinderInstance(pts, topPts, options) {
    var height = options.height,
        color = options.color || new Cesium.Color(0.5, 0.8, 1.0, 2.);

    var newpts = pts.slice();

    var length = pts.length;
    var len_2 = 2 * length;
    var sts = [];
    var st_interval = 1.0 / (length - 1);
    var define_indices = [];

    var ep = [];
    for (var i = 0; i < length; i++) {
        ep.push((0, _point.addPositionsHeight)(topPts[i], height));
        sts.push(i * st_interval);
        sts.push(0.);

        var i_1 = i + 1;
        var i_11 = (i + 1) % length;
        var len_2_i_1 = len_2 - i_1;
        define_indices.push.apply(define_indices, [len_2_i_1 - 1, len_2_i_1, i]); //用materialAppearance贴纹理正确
        define_indices.push.apply(define_indices, [i, i_11, len_2_i_1 - 1]);
    }

    for (var _i = 0; _i < ep.length; _i++) {
        newpts.push(ep[length - _i - 1]);

        sts.push(1. - _i * st_interval);
        sts.push(1.);
    }

    var polygon = new Cesium.PolygonGeometry({
        polygonHierarchy: new Cesium.PolygonHierarchy(newpts),
        perPositionHeight: true
    });
    polygon = Cesium.PolygonGeometry.createGeometry(polygon);
    polygon.indices = define_indices;
    polygon.attributes.st.values = sts;

    return new Cesium.GeometryInstance({
        geometry: polygon,
        attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(color),
            distanceDisplayCondition: options.distanceDisplayCondition
        }
    });
}

//计算圆坐标
function getCirclePosition(center, radius) {
    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120;

    var res = [];
    var mm = Cesium.Transforms.eastNorthUpToFixedFrame(center);

    var interval = 2 * Math.PI / length;
    var startPos = 2 * Math.PI * 270 / 360;

    for (var i = 0; i < length; i++) {
        var a = startPos - interval * i;
        var p = new Cesium.Cartesian3(Math.sin(a) * radius, Math.cos(a) * radius, 0.);
        res.push(Cesium.Matrix4.multiplyByPoint(mm, p, new Cesium.Cartesian3()));
    }
    res.push(res[0]);

    return res;
}

/***/ }),
/* 213 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float time = fract(czm_frameNumber / 90.) ;\n    vec2 new_st = fract(st-vec2(time,time));\n    vec4 color = texture2D(image,new_st);\n\n    vec3 diffuse = color.rgb;\n    float alpha = color.a;\n    diffuse *= u_color.rgb;\n    alpha *= u_color.a;\n    alpha *= u_color.a;\n    material.diffuse = diffuse;\n    material.alpha = alpha * pow(1. - st.t,u_color.a);\n    return material;\n}"

/***/ }),
/* 214 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float powerRatio = 1./(fract(czm_frameNumber / 30.0) +  1.) ;\n    float alpha = pow(1. - st.t,powerRatio);\n    vec4 color = vec4(u_color.rgb, alpha*u_color.a);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}"

/***/ }),
/* 215 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 tColor = u_color;\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float length = length(center)/0.5;\n    float time = 1. - abs(czm_frameNumber / 360. - 0.5);\n\n    float param = 1. - step(length, 0.6);//大于0.6模糊，rate = 0.6\n    float scale = param * length;// 0.6< length 返回0，反之返回1.\n    float alpha = param * (1.0 - abs(scale - 0.8) / 0.2);// 0.8 < length 返回0，反之返回1.\n\n    float param1 = step(length, 0.7);//小于0.5模糊\n    float scale1 = param1 * length;// 0.6< length 返回0，反之返回1.\n    alpha += param1 * (1.0 - abs(scale1 - 0.35) / 0.35);// 0.8 < length 返回0，反之返回1.\n\n    material.diffuse = u_color.rgb * vec3(u_color.a);\n    material.alpha = pow(alpha, 4.0);\n    return material;\n}"

/***/ }),
/* 216 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float time = -czm_frameNumber * 3.1415926 / 180.;//扫描速度1度\n    float sin_t = sin(time);\n    float cos_t = cos(time);\n    vec2 center_rotate = vec2(center.s*cos_t-center.t*sin_t+0.5,center.s*sin_t+center.t*cos_t+0.5);\n    vec4 color = texture2D(image,center_rotate);\n    vec3 tColor = color.rgb * u_color.rgb;\n    tColor *= u_color.a;\n    material.diffuse = tColor;\n    float length = 2. - length(center)/0.5;\n    material.alpha = color.a * pow(length, 0.5);//color.r = 0 或1\n    return material;\n}"

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DiffuseWallGlow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _point = __webpack_require__(2);

var _polygon = __webpack_require__(13);

var _DiffuseWallGlowVS = __webpack_require__(218);

var _DiffuseWallGlowVS2 = _interopRequireDefault(_DiffuseWallGlowVS);

var _DiffuseWallGlowFS = __webpack_require__(219);

var _DiffuseWallGlowFS2 = _interopRequireDefault(_DiffuseWallGlowFS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//立体面(或圆)散射效果
var DiffuseWallGlow = exports.DiffuseWallGlow = function () {
    function DiffuseWallGlow(viewer, options) {
        _classCallCheck(this, DiffuseWallGlow);

        this.viewer = viewer;
        this.options = options;

        if (options.positions) {
            //多边形时
            this.center = (0, _point.centerOfMass)(options.positions);
            this.positions = options.positions;
        } else {
            //圆形时 
            this.center = options.position;
            this.positions = (0, _polygon.getEllipseOuterPositions)({
                position: options.position,
                radius: Cesium.defaultValue(options.radius, 100), //半径
                count: Cesium.defaultValue(options.count, 50) //共返回(count*4)个点
            });
        }

        this.translucent = Cesium.defaultValue(options.translucent, true);
        this.height = Cesium.defaultValue(options.height, 1000);
        this.direction = Cesium.defaultValue(options.direction, -1);
        this.color = Cesium.defaultValue(options.color, new Cesium.Color(0.5, 0.8, 1));
        this._show = Cesium.defaultValue(options.show, true);

        //缩放参数
        this.speed = Cesium.defaultValue(options.speed, 1000);
        this.mScale = Cesium.Matrix4.fromUniformScale(1.0);
        this.xyScale = 2.;
        // this.modelMatrix = Cesium.Matrix4.fromUniformScale(1.0); 

        this.draw();
    }

    //========== 对外属性 ==========  


    _createClass(DiffuseWallGlow, [{
        key: "draw",


        //========== 方法 ========== 
        value: function draw() {
            var cps = this.positions;
            var up = (0, _point.addPositionsHeight)(this.positions, this.height);

            //计算位置
            var pos = []; //坐标
            var sts = []; //纹理
            var indices = []; //索引
            var normal = []; //法向量
            for (var i = 0, count = cps.length; i < count; i++) {
                var ni = (i + 1) % count;
                pos.push.apply(pos, [cps[i].x, cps[i].y, cps[i].z]);
                pos.push.apply(pos, [cps[ni].x, cps[ni].y, cps[ni].z]);
                pos.push.apply(pos, [up[ni].x, up[ni].y, up[ni].z]);
                pos.push.apply(pos, [up[i].x, up[i].y, up[i].z]);

                normal.push.apply(normal, [0, 0, 1]);
                normal.push.apply(normal, [0, 0, 1]);
                normal.push.apply(normal, [0, 0, 1]);
                normal.push.apply(normal, [0, 0, 1]);

                sts.push.apply(sts, [0, 0, 1, 0, 1, 1, 0, 1]); //四个点的纹理一次存入

                var ii = i * 4;
                var i1 = ii + 1;
                var i2 = ii + 2;
                var i3 = ii + 3;
                indices.push.apply(indices, [i2, i3, ii, ii, i1, i2]);
            }

            var positions = new Float64Array(pos);
            var gi = new Cesium.GeometryInstance({
                geometry: new Cesium.Geometry({
                    attributes: {
                        position: new Cesium.GeometryAttribute({
                            // 使用double类型的position进行计算
                            componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                            //componentDatatype: Cesium.ComponentDatatype.FLOAT,
                            componentsPerAttribute: 3,
                            values: positions
                        }),
                        normal: new Cesium.GeometryAttribute({
                            componentDatatype: Cesium.ComponentDatatype.FLOAT,
                            componentsPerAttribute: 3,
                            values: new Float32Array(normal)
                        }),
                        st: new Cesium.GeometryAttribute({
                            componentDatatype: Cesium.ComponentDatatype.FLOAT,
                            componentsPerAttribute: 2,
                            values: new Float32Array(sts)
                        })
                    },
                    indices: new Uint16Array(indices),
                    primitiveType: Cesium.PrimitiveType.TRIANGLES,
                    boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
                })
            });
            this.primitive = new Cesium.Primitive({
                geometryInstances: gi,
                appearance: new Cesium.MaterialAppearance({
                    material: new Cesium.Material({
                        translucent: this.translucent,
                        fabric: {
                            uniforms: {
                                u_color: this.color
                            },
                            source: this.getShader(this.translucent)
                        }
                    }),
                    vertexShaderSource: _DiffuseWallGlowVS2.default,
                    fragmentShaderSource: _DiffuseWallGlowFS2.default
                }),
                asynchronous: false
            });
            this.primitive.show = this._show;
            this.viewer.scene.primitives.add(this.primitive);

            this.viewer.scene.primitives.add(this);
        }
    }, {
        key: "update",
        value: function update(fs) {
            if (this.primitive && this._show) {
                var time = fs.frameNumber / this.speed;
                var tt = time - Math.floor(time);

                tt = tt < 0.01 ? 0.01 : tt;
                this.mScale[0] = this.mScale[5] = tt * this.xyScale;
                this.mScale[10] = 1.1 - tt;
                this.primitive.modelMatrix = scaleXYZ(this.center, this.mScale);
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.viewer.scene.primitives.remove(this);
            if (!this.viewer) return;

            if (this.primitive) {
                this.viewer.scene.primitives.remove(this.primitive);
                delete this.primitive;
            }

            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "getShader",


        //片源着色器
        value: function getShader(t) {
            var fs = 'uniform vec4 u_color;\n' + "    vec4 xh_getMaterial(vec2 st){" + '    float alpha = pow(1. - st.t, 4.);\n';
            if (t) {
                fs += '    vec4 color = vec4(u_color.rgb * u_color.a, alpha);';
            } else {
                fs += '    vec4 color = vec4(u_color.rgb * u_color.a, 1.);';
            }
            fs += '    return color;\n' + '}\n';
            return fs;
        }
    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(value) {
            this._show = value;

            if (this.primitive) {
                this.primitive.show = value;
            }
        }
    }]);

    return DiffuseWallGlow;
}();

function scaleXYZ(point, mScale) {
    var m = Cesium.Transforms.eastNorthUpToFixedFrame(point);
    var inverse = Cesium.Matrix4.inverse(m, new Cesium.Matrix4());

    var tt = Cesium.Matrix4.multiply(mScale, inverse, new Cesium.Matrix4());
    return Cesium.Matrix4.multiply(m, tt, new Cesium.Matrix4());
}

/***/ }),
/* 218 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\nvarying vec2 v_st;\nvarying vec3 v_normalEC;\nvarying vec3 v_positionEC;\nvoid main()\n{\n    vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n    v_normalEC = czm_normal * normal;\n    v_st=st;\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\nvoid main(){\n    gl_FragColor = xh_getMaterial(v_st);\n}"

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScrollWallGlow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass = __webpack_require__(3);

var _point = __webpack_require__(2);

var _ScrollWallGlowVS = __webpack_require__(221);

var _ScrollWallGlowVS2 = _interopRequireDefault(_ScrollWallGlowVS);

var _ScrollWallGlowFS = __webpack_require__(222);

var _ScrollWallGlowFS2 = _interopRequireDefault(_ScrollWallGlowFS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//走马灯围墙效果
var ScrollWallGlow = exports.ScrollWallGlow = function () {
    function ScrollWallGlow(viewer, options) {
        _classCallCheck(this, ScrollWallGlow);

        this.viewer = viewer;
        this.options = options;

        this.positions = options.positions;

        this.color = Cesium.defaultValue(options.color, Cesium.Color.YELLOW);
        this.u_tcolor = Cesium.defaultValue(options.u_tcolor, Cesium.Color.YELLOW); //设置不透明的时候，alpha小于的颜色值
        this.height = Cesium.defaultValue(options.height, 500);
        this.speed = Cesium.defaultValue(options.speed, 600);
        this.direction = Cesium.defaultValue(options.direction, -1); //方向：1往上、-1往下
        this.translucent = Cesium.defaultValue(options.translucent, true); //添加透明参数,true为透明
        this.style = Cesium.defaultValue(options.style, 1);
        this._show = Cesium.defaultValue(options.show, true);

        this.draw();
    }
    //========== 对外属性 ==========  


    _createClass(ScrollWallGlow, [{
        key: "draw",


        //========== 方法 ========== 
        value: function draw() {
            var cps = this.positions;
            var up = (0, _point.addPositionsHeight)(cps, this.height);

            //计算位置
            var pos = []; //坐标
            var sts = []; //纹理
            var indices = []; //索引
            var normal = []; //法向量

            for (var i = 0, len = cps.length; i < len; i++) {
                var ni = i + 1;
                if (ni == len) ni = 0;

                pos.push.apply(pos, [cps[i].x, cps[i].y, cps[i].z]);
                pos.push.apply(pos, [cps[ni].x, cps[ni].y, cps[ni].z]);
                pos.push.apply(pos, [up[ni].x, up[ni].y, up[ni].z]);
                pos.push.apply(pos, [up[i].x, up[i].y, up[i].z]);

                normal.push.apply(normal, [0, 0, 1]);
                normal.push.apply(normal, [0, 0, 1]);
                normal.push.apply(normal, [0, 0, 1]);
                normal.push.apply(normal, [0, 0, 1]);

                sts.push.apply(sts, [0, 0, 1, 0, 1, 1, 0, 1]); //四个点的纹理一次存入

                var ii = i * 4;
                var i1 = ii + 1;
                var i2 = ii + 2;
                var i3 = ii + 3;
                indices.push.apply(indices, [ii, i1, i2, i2, i3, ii]);
            }

            var positions = new Float64Array(pos);
            var gi = new Cesium.GeometryInstance({
                geometry: new Cesium.Geometry({
                    attributes: {
                        position: new Cesium.GeometryAttribute({
                            // 使用double类型的position进行计算
                            componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                            //componentDatatype: Cesium.ComponentDatatype.FLOAT,
                            componentsPerAttribute: 3,
                            values: positions
                        }),
                        normal: new Cesium.GeometryAttribute({
                            componentDatatype: Cesium.ComponentDatatype.FLOAT,
                            componentsPerAttribute: 3,
                            values: new Float32Array(normal)
                        }),
                        st: new Cesium.GeometryAttribute({
                            componentDatatype: Cesium.ComponentDatatype.FLOAT,
                            componentsPerAttribute: 2,
                            values: new Float32Array(sts)
                        })
                    },
                    indices: new Uint16Array(indices),
                    primitiveType: Cesium.PrimitiveType.TRIANGLES,
                    boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
                })
            });

            this.primitive = new Cesium.Primitive({
                geometryInstances: gi,
                appearance: new Cesium.MaterialAppearance({
                    material: new Cesium.Material({
                        translucent: this.translucent,
                        fabric: {
                            uniforms: {
                                u_color: this.color,
                                speed: this.speed,
                                direction: this.direction,
                                u_tcolor: this.u_tcolor
                            },
                            source: this.createShader(this.translucent)
                        }
                    }),
                    vertexShaderSource: _ScrollWallGlowVS2.default,
                    fragmentShaderSource: _ScrollWallGlowFS2.default
                }),
                asynchronous: false
            });
            this.primitive.show = this._show;
            this.viewer.scene.primitives.add(this.primitive);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            if (this.primitive) {
                this.viewer.scene.primitives.remove(this.primitive);
                delete this.primitive;
            }

            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "createShader",
        value: function createShader(t) {
            //修改了shader
            var fs = '';
            if (this.style === 1) {
                fs += 'czm_material czm_getMaterial( czm_materialInput cmi )\n' + '{\n' + '    czm_material material = czm_getDefaultMaterial(cmi);\n' + '    vec2 st = cmi.st;' + '    float t = fract(czm_frameNumber/speed) * direction;\n' + '    vec2 st1 = vec2(st.s,fract(st.t - t));\n' + '    vec4 color = vec4(0.,0.,0.,0.);\n' + '    float tt = 0.5 - abs(0.5 - st1.t);\n' + '    float ss = st1.s ;\n';
                if (t) {
                    fs += '   float alpha = tt * 2.;\n' + '   color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n' + '   material.diffuse = color.rgb;\n' + '   material.alpha = color.a;\n' + '   return material;\n' + '}\n';
                } else {
                    fs += '   color = vec4(u_color.rgb * u_color.a * pow(tt,0.25),1.0);' + '   material.diffuse = color.rgb;\n' + '   material.alpha = color.a;\n' + '   return material;\n' + '}\n';
                }
            } else {
                fs += 'czm_material czm_getMaterial( czm_materialInput cmi )\n' + '{\n' + '    czm_material material = czm_getDefaultMaterial(cmi);\n' + '    vec2 st = cmi.st;\n' + '    float t = fract(czm_frameNumber/speed) * direction;\n' + '    vec2 st1 = vec2(fract(st.s - t),st.t);\n' + '    vec4 color = vec4(0.,0.,0.,0.);\n' + '    float alpha = 1.-st.t;\n' + '    float value = fract(st1.s/0.25);\n' + '    alpha *= sin(value * 3.1415926);\n';
                if (t) {
                    fs += ' color = vec4(u_color.rgb * u_color.a, alpha * 1.2);' + '   material.diffuse = color.rgb;\n' + '   material.alpha = color.a;\n' + '   return material;\n' + '}\n';
                } else {
                    fs += ' color = vec4(u_color.rgb * u_color.a,alpha);\n' + '   material.diffuse = color.rgb;\n' + '   material.alpha = color.a;\n' + '   return material;\n' + '}\n';
                }
            }
            return fs;
        }
    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(value) {
            this._show = value;

            if (this.primitive) {
                this.primitive.show = value;
            }
        }
    }]);

    return ScrollWallGlow;
}();

/***/ }),
/* 221 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\nvarying vec2 v_st;\nvarying vec3 v_normalEC;\nvarying vec3 v_positionEC;\nvoid main()\n{\n    vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n    v_normalEC = czm_normal * normal;\n    v_st=st;\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}"

/***/ }),
/* 222 */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n    vec3 normalEC = normalize(v_normalEC);\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n}"

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FogEffect = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Fog = __webpack_require__(224);

var _Fog2 = _interopRequireDefault(_Fog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 场景雾效果
//原理：根据深度图的深度值，对片元进行不同程度的模糊
var FogEffect = exports.FogEffect = function () {
    //========== 构造方法 ========== 
    function FogEffect(options) {
        _classCallCheck(this, FogEffect);

        this.viewer = options.viewer;

        this.fogByDistance = Cesium.defaultValue(options.fogByDistance, new Cesium.Cartesian4(10, 0.0, 1000, 0.9)); //雾强度 
        this.color = Cesium.defaultValue(options.color, Cesium.Color.WHITE); //雾颜色

        this._show = Cesium.defaultValue(options.show, true);
        this._maxHeight = Cesium.defaultValue(options.maxHeight, 9000);

        this.init();
    }

    //========== 对外属性 ==========  
    //是否开启效果


    _createClass(FogEffect, [{
        key: "init",


        //========== 方法 ========== 

        value: function init() {
            var that = this;

            this.FogStage = new Cesium.PostProcessStage({
                fragmentShader: _Fog2.default,
                uniforms: {
                    fogByDistance: function fogByDistance() {
                        return that.fogByDistance;
                    },
                    fogColor: function fogColor() {
                        return that.color;
                    }
                },
                enabled: this._show
            });
            this.viewer.scene.postProcessStages.add(this.FogStage);

            //加控制，只在相机高度低于一定高度时才开启本效果
            this.viewer.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
        }
    }, {
        key: "camera_changedHandler",
        value: function camera_changedHandler(event) {
            if (this.viewer.camera.positionCartographic.height < this._maxHeight) {
                this.FogStage.enabled = this._show;
            } else {
                this.FogStage.enabled = false;
            }
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            this.viewer.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
            this.viewer.scene.postProcessStages.remove(this.FogStage);

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(val) {
            this._show = Boolean(val);
            this.FogStage.enabled = this._show;
        }
    }]);

    return FogEffect;
}();

/***/ }),
/* 224 */
/***/ (function(module, exports) {

module.exports = "float getDistance(sampler2D depthTexture, vec2 texCoords) \r\n{ \r\n    float depth = czm_unpackDepth(texture2D(depthTexture, texCoords)); \r\n    if (depth == 0.0) { \r\n        return czm_infinity; \r\n    } \r\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth); \r\n    return -eyeCoordinate.z / eyeCoordinate.w; \r\n} \r\nfloat interpolateByDistance(vec4 nearFarScalar, float distance) \r\n{ \r\n    float startDistance = nearFarScalar.x; \r\n    float startValue = nearFarScalar.y; \r\n    float endDistance = nearFarScalar.z; \r\n    float endValue = nearFarScalar.w; \r\n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0); \r\n    return mix(startValue, endValue, t); \r\n} \r\nvec4 alphaBlend(vec4 sourceColor, vec4 destinationColor) \r\n{ \r\n    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a); \r\n} \r\nuniform sampler2D colorTexture; \r\nuniform sampler2D depthTexture; \r\nuniform vec4 fogByDistance; \r\nuniform vec4 fogColor; \r\nvarying vec2 v_textureCoordinates; \r\nvoid main(void) \r\n{ \r\n    float distance = getDistance(depthTexture, v_textureCoordinates); \r\n    vec4 sceneColor = texture2D(colorTexture, v_textureCoordinates); \r\n    float blendAmount = interpolateByDistance(fogByDistance, distance); \r\n    vec4 finalFogColor = vec4(fogColor.rgb, fogColor.a * blendAmount); \r\n    gl_FragColor = alphaBlend(finalFogColor, sceneColor); \r\n} "

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvertedScene = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _InvertedScene = __webpack_require__(226);

var _InvertedScene2 = _interopRequireDefault(_InvertedScene);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//后处理实现倒影
//原理：利用空间镜面反射技术，计算倒影射线的UV进行采样
var InvertedScene = exports.InvertedScene = function () {
    //========== 构造方法 ========== 

    function InvertedScene(options) {
        _classCallCheck(this, InvertedScene);

        this.viewer = options.viewer;
        this._show = Cesium.defaultValue(options.show, true);

        this.init();
    }

    //========== 对外属性 ========== 

    //是否开启效果


    _createClass(InvertedScene, [{
        key: "init",


        //========== 方法 ========== 

        value: function init() {
            this.postStage = new Cesium.PostProcessStage({
                "name": "InvertedScene",
                fragmentShader: _InvertedScene2.default
            });
            this.postStage.enabled = this._show;
            this.viewer.scene.postProcessStages.add(this.postStage);
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            this.viewer.scene.postProcessStages.remove(this.postStage);

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(val) {
            this._show = Boolean(val);
            this.postStage.enabled = this._show;
        }
    }]);

    return InvertedScene;
}();

/***/ }),
/* 226 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nvec3 guussColor(vec2 uv){\r\n    vec2 pixelSize = 1.0 / czm_viewport.zw;\r\n    float dx0 = -pixelSize.x;\r\n    float dy0 = -pixelSize.y;\r\n    float dx1 = pixelSize.x;\r\n    float dy1 = pixelSize.y;\r\n    vec4 gc = (\r\n        texture2D(colorTexture, uv)+\r\n        texture2D(colorTexture, uv + vec2(dx0, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(0.0, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(dx0, 0.0)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, 0.0)) +\r\n        texture2D(colorTexture, uv + vec2(dx0, dy1)) +\r\n        texture2D(colorTexture, uv + vec2(0.0, dy1)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, dy1))\r\n    ) * (1.0 / 9.0);\r\n    return gc.rgb;\r\n}\r\nvoid main(){\r\n    // mat4 dither = mat4(\r\n    //     0,       0.5,    0.125,  0.625,\r\n    //     0.75,    0.25,   0.875,  0.375,\r\n    //     0.1875,  0.6875, 0.0625, 0.5625,\r\n    //     0.9375,  0.4375, 0.8125, 0.3125\r\n    // );\r\n    // int sampleCoordX = int(mod((gl_FragCoord.x * v_textureCoordinates.x),4.0));\r\n    // int sampleCoordY = int(mod((gl_FragCoord.y * v_textureCoordinates.y),4.0));\r\n    float offset = 0.0;\r\n\r\n\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    // gl_FragColor = currD;\r\n    // return;\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\r\n    // return;\r\n\r\n    \r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 normal = normalize(cross(dx,dy));\r\n\r\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\r\n    vec3 normalWC = normalize(czm_inverseViewRotation * normal);\r\n    float fotNumWC = dot(positionWC.xyz,normalWC);\r\n    if(fotNumWC<=0.5){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n    // float dotNum = dot(normal,vec3(0.0,1.0,0.0));\r\n    // gl_FragColor = mix(color,vec4(1.0),dotNum*0.8);\r\n    // return;\r\n\r\n    vec3 viewDir = normalize(positionEC.xyz);\r\n    vec3 reflectDir = reflect(viewDir, normal);\r\n    // vec3 viewReflectDir = czm_viewRotation * reflectDir;\r\n    vec3 viewReflectDir = reflectDir;\r\n\r\n    \r\n    float step = 0.05;\r\n    int stepNum = int(20.0 / step);\r\n    vec3 pos;\r\n    vec3 albedo;\r\n    bool jd = false;\r\n    for(int i = 1;i <= 400;i++)\r\n    {\r\n        float delta = step * float(i) + offset;\r\n        pos = positionEC.xyz + viewReflectDir * delta;\r\n        float d = -pos.z;\r\n\r\n        vec4 tmp = czm_projection * vec4(pos,1.0);\r\n        vec3 screenPos = tmp.xyz / tmp.w;\r\n        vec2 uv = vec2(screenPos.x, screenPos.y) * 0.5 + vec2(0.5, 0.5);\r\n        \r\n        if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0){\r\n            float dd = getDepth(texture2D(depthTexture, uv));\r\n            vec4 jzc = toEye(uv, dd);\r\n            dd = -jzc.z;\r\n            if(d>dd){\r\n                if(abs(abs(d) - abs(dd)) <=step){\r\n                    jd = true;\r\n                    // albedo = texture2D(colorTexture, uv).rgb;\r\n                    albedo = guussColor(uv);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if(jd){\r\n        gl_FragColor = vec4(mix(color.xyz,albedo,0.5),1.0);\r\n    }else{\r\n        gl_FragColor = color;\r\n    }\r\n}"

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SnowCover = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _SnowCover = __webpack_require__(228);

var _SnowCover2 = _interopRequireDefault(_SnowCover);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 雪覆盖 效果 
//原理：法线越垂直与地面越白 
var SnowCover = exports.SnowCover = function () {
    //========== 构造方法 ========== 

    function SnowCover(options) {
        _classCallCheck(this, SnowCover);

        this.viewer = options.viewer;

        this.alpha = Cesium.defaultValue(options.alpha, 1.0); //覆盖强度  0-1
        this._show = Cesium.defaultValue(options.show, true);
        this._maxHeight = Cesium.defaultValue(options.maxHeight, 9000);

        this.init();
    }

    //========== 对外属性 ==========  
    //是否开启效果


    _createClass(SnowCover, [{
        key: "init",


        //========== 方法 ========== 

        value: function init() {
            var that = this;
            this.postStage = new Cesium.PostProcessStage({
                name: "SnowCover",
                fragmentShader: _SnowCover2.default,
                uniforms: {
                    alpha: function alpha() {
                        return that.alpha;
                    }
                }
            });
            this.postStage.enabled = this._show;
            this.viewer.scene.postProcessStages.add(this.postStage);

            //加控制，只在相机高度低于一定高度时才开启本效果
            this.viewer.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
        }
    }, {
        key: "camera_changedHandler",
        value: function camera_changedHandler(event) {
            if (viewer.camera.positionCartographic.height < this._maxHeight) {
                this.postStage.enabled = this._show;
            } else {
                this.postStage.enabled = false;
            }
        }

        //销毁

    }, {
        key: "destroy",
        value: function destroy() {
            this.viewer.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
            this.viewer.scene.postProcessStages.remove(this.postStage);

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "show",
        get: function get() {
            return this._show;
        },
        set: function set(val) {
            this._show = Boolean(val);
            this.postStage.enabled = this._show;
        }
    }]);

    return SnowCover;
}();

/***/ }),
/* 228 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nuniform float alpha;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nvoid main(){\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 nor = normalize(cross(dx,dy));\r\n\r\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\r\n    vec3 normalWC = normalize(czm_inverseViewRotation * nor);\r\n    float dotNumWC = dot(positionWC.xyz,normalWC);\r\n    if(dotNumWC<=0.3){\r\n        gl_FragColor = mix(color,vec4(1.0),alpha*0.3);\r\n        return;\r\n    }\r\n    gl_FragColor = mix(color,vec4(1.0),dotNumWC*alpha);\r\n}"

/***/ }),
/* 229 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D colorTexture;//输入的场景渲染照片\r\nvarying vec2 v_textureCoordinates;\r\n\r\nfloat hash(float x){\r\n    return fract(sin(x*133.3)*13.13);\r\n}\r\n\r\nvoid main(void){\r\n\r\n    float time = czm_frameNumber / 240.0;\r\n    vec2 resolution = czm_viewport.zw;\r\n\r\n    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\r\n    vec3 c=vec3(.6,.7,.8);\r\n\r\n    float a=-.4;\r\n    float si=sin(a),co=cos(a);\r\n    uv*=mat2(co,-si,si,co);\r\n    uv*=length(uv+vec2(0,4.9))*.3+1.;\r\n\r\n    float v=1.-sin(hash(floor(uv.x*100.))*2.);\r\n    float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\r\n    c*=v*b; //屏幕上雨的颜色\r\n\r\n    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(c,1), 0.5); //将雨和三维场景融合\r\n}"

/***/ }),
/* 230 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D colorTexture; //输入的场景渲染照片\r\nvarying vec2 v_textureCoordinates;\r\n\r\nfloat snow(vec2 uv,float scale){\r\n    float time = czm_frameNumber / 60.0;\r\n    float w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\r\n    uv+=time/scale;uv.y+=time*2./scale;uv.x+=sin(uv.y+time*.5)/scale;\r\n    uv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\r\n    p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\r\n    k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\r\n    return k*w;\r\n}\r\n\r\nvoid main(void){\r\n    vec2 resolution = czm_viewport.zw;\r\n    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\r\n    vec3 finalColor=vec3(0);\r\n    float c = 0.0;\r\n    // c+=snow(uv,30.)*.0;\r\n    // c+=snow(uv,20.)*.0;\r\n    // c+=snow(uv,15.)*.0;\r\n    c+=snow(uv,10.);\r\n    c+=snow(uv,8.);\r\n    c+=snow(uv,6.);\r\n    c+=snow(uv,5.);\r\n    finalColor=(vec3(c)); //屏幕上雪的颜色\r\n    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.5);  //将雪和三维场景融合\r\n\r\n}"

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ZoomNavigation = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var unprojectedScratch = new Cesium.Cartographic();
var rayScratch = new Cesium.Ray();
var cartesian3Scratch = new Cesium.Cartesian3();

/**
 * gets the focus point of the camera
 * @param {Viewer|Widget} viewer The viewer
 * @param {boolean} inWorldCoordinates true to get the focus in world coordinates, otherwise get it in projection-specific map coordinates, in meters.
 * @param {Cesium.Cartesian3} [result] The object in which the result will be stored.
 * @return {Cesium.Cartesian3} The modified result parameter, a new instance if none was provided or undefined if there is no focus point.
 */
function getCameraFocus(viewer, inWorldCoordinates, result) {
    var scene = viewer.scene;
    var camera = scene.camera;

    if (scene.mode == Cesium.SceneMode.MORPHING) {
        return undefined;
    }

    if (!Cesium.defined(result)) {
        result = new Cesium.Cartesian3();
    }

    // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating
    // TODO bug when tracking: reset should reset to default view of tracked entity

    if (Cesium.defined(viewer.trackedEntity)) {
        result = viewer.trackedEntity.position.getValue(viewer.clock.currentTime, result);
    } else {
        rayScratch.origin = camera.positionWC;
        rayScratch.direction = camera.directionWC;
        result = scene.globe.pick(rayScratch, scene, result);
    }

    if (!Cesium.defined(result)) {
        return undefined;
    }

    if (scene.mode == Cesium.SceneMode.SCENE2D || scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
        result = camera.worldToCameraCoordinatesPoint(result, result);

        if (inWorldCoordinates) {
            result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch), result);
        }
    } else {
        if (!inWorldCoordinates) {
            result = camera.worldToCameraCoordinatesPoint(result, result);
        }
    }

    return result;
};

var ZoomNavigation = exports.ZoomNavigation = function () {
    //========== 构造方法 ========== 
    // is used for zooming in (true) or out (false)
    function ZoomNavigation(viewer, zoomIn) {
        _classCallCheck(this, ZoomNavigation);

        this.viewer = viewer;

        this.relativeAmount = 2;
        if (zoomIn) {
            // this ensures that zooming in is the inverse of zooming out and vice versa
            // e.g. the camera position remains when zooming in and out
            this.relativeAmount = 1 / this.relativeAmount;
        }
    }

    /**
     * When implemented in a derived class, performs an action when the user clicks
     * on this control
     * @abstract
     * @protected
     */


    _createClass(ZoomNavigation, [{
        key: "activate",
        value: function activate() {
            this.zoom(this.relativeAmount);
        }
    }, {
        key: "zoom",
        value: function zoom(relativeAmount) {
            this.isActive = true;

            if (Cesium.defined(this.viewer)) {
                var scene = this.viewer.scene;

                var sscc = scene.screenSpaceCameraController;
                // do not zoom if it is disabled
                if (!sscc.enableInputs || !sscc.enableZoom) {
                    return;
                }
                // TODO
                //            if(scene.mode == Cesium.SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {
                //                return;
                //            }

                var camera = scene.camera;
                var orientation;

                switch (scene.mode) {
                    case Cesium.SceneMode.MORPHING:
                        break;
                    case Cesium.SceneMode.SCENE2D:
                        camera.zoomIn(camera.positionCartographic.height * (1 - this.relativeAmount));
                        break;
                    default:
                        var focus;

                        if (Cesium.defined(this.viewer.trackedEntity)) {
                            focus = new Cesium.Cartesian3();
                        } else {
                            focus = getCameraFocus(this.viewer, false);
                        }

                        if (!Cesium.defined(focus)) {
                            // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
                            // the focal point.
                            var ray = new Cesium.Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);
                            focus = Cesium.IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);

                            orientation = {
                                heading: camera.heading,
                                pitch: camera.pitch,
                                roll: camera.roll
                            };
                        } else {
                            orientation = {
                                direction: camera.direction,
                                up: camera.up
                            };
                        }

                        var direction = Cesium.Cartesian3.subtract(camera.position, focus, cartesian3Scratch);
                        var movementVector = Cesium.Cartesian3.multiplyByScalar(direction, relativeAmount, direction);
                        var endPosition = Cesium.Cartesian3.add(focus, movementVector, focus);

                        if (Cesium.defined(this.viewer.trackedEntity) || scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
                            // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation
                            // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change
                            camera.position = endPosition;
                        } else {
                            camera.flyTo({
                                destination: endPosition,
                                orientation: orientation,
                                duration: 0.5,
                                convert: false
                            });
                        }
                }
            }

            // this.viewer.notifyRepaintRequired();
            this.isActive = false;
        }
    }]);

    return ZoomNavigation;
}();

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rotate = undefined;
exports.move = move;
exports.getHeadingPitchRoll = getHeadingPitchRoll;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _matrix = __webpack_require__(17);

var _util = __webpack_require__(1);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//自旋转效果
//gltf模型
var rotate = exports.rotate = {
    isStart: false,
    viewer: null,
    start: function start(entity, opts) {
        this.entity = entity;
        this.viewer = opts.viewer || window.viewer;

        this.time = this.viewer.clock.currentTime.clone();

        this.hpr = (0, _matrix.getHeadingPitchRollByOrientation)(this.entity.position._value, this.entity.orientation && this.entity.orientation._value);
        this.angle = opts.step || 10; //步长

        this.viewer.clock.shouldAnimate = true;
        this.viewer.clock.onTick.addEventListener(this.clock_onTickHandler, this);
        this.isStart = true;
    },
    clock_onTickHandler: function clock_onTickHandler(e) {
        var delTime = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time); // 当前已经过去的时间，单位 秒
        var heading = Cesium.Math.toRadians(delTime * this.angle) + this.hpr.heading;

        //角度控制  
        var hpr = new Cesium.HeadingPitchRoll(heading, this.hpr.pitch, this.hpr.roll);
        this.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(this.entity.position._value, hpr);
    },
    stop: function stop() {
        if (!this.isStart) return;

        if (this.viewer) this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
        this.isStart = false;
    }
};

//移动模型
function move(entity, options) {
    var viewer = options.viewer || window.viewer;

    var property = new Cesium.SampledPositionProperty();
    var startTime = viewer.clock.currentTime; //飞行开始时间
    var stopTime; //飞行结束时间 

    var pointStart = (0, _point.getPositionValue)(entity.position, startTime);
    property.addSample(startTime, pointStart);

    var pointEnd = options.position;
    var time = options.time || 3; //速度 秒
    stopTime = Cesium.JulianDate.addSeconds(startTime, time, new Cesium.JulianDate());
    property.addSample(stopTime, pointEnd);

    //为了保证到结束时间了，一直停留在那，所以加个很远的时间
    stopTime = Cesium.JulianDate.addDays(stopTime, 365, new Cesium.JulianDate());
    property.addSample(stopTime, pointEnd);

    entity.position = property;

    viewer.clock.shouldAnimate = true;
    var _bak_multiplier = viewer.clock.multiplier;
    viewer.clock.multiplier = options.speed || 1; //飞行速度  
    // viewer.clock.currentTime = startTime.clone();

    setTimeout(function () {
        entity.position = pointEnd;

        viewer.clock.multiplier = _bak_multiplier;

        if (options.onEnd) options.onEnd();
    }, time * 1000);
}

//获取动态模型的当前hpr角度
function getHeadingPitchRoll(entity, time) {
    time = time || (0, _util.currentTime)();
    var position = Cesium.Property.getValueOrUndefined(entity.position, time, new Cesium.Cartesian3());
    var orientation = Cesium.Property.getValueOrUndefined(entity.orientation, time, new Cesium.Quaternion());
    var hpr = (0, _matrix.getHeadingPitchRollByOrientation)(position, orientation);
    return hpr;
}

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Video3D = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Video3D = __webpack_require__(234);

var _Video3D2 = _interopRequireDefault(_Video3D);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ratateDirection = {
    'LEFT': 'Z',
    'RIGHT': '-Z',
    'TOP': 'Y',
    'BOTTOM': '-Y',
    'ALONG': 'X',
    'INVERSE': '-X'
};

var textStyles = {
    font: '50px 楷体',
    fill: true,
    fillColor: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
    stroke: true,
    strokeWidth: 2,
    strokeColor: new Cesium.Color(1.0, 1.0, 1.0, 0.8),
    backgroundColor: new Cesium.Color(1.0, 1.0, 1.0, 0.1),
    textBaseline: 'top',
    padding: 40
};

var Video3DType = {
    Color: 1,
    Image: 2,
    Video: 3,
    Text: 4

    //视频融合（投射3D，贴物体表面）
    //原理：在可视域的基础上，着色器里传入纹理，再计算UV进行贴图
};
var Video3D = exports.Video3D = function () {
    //========== 构造方法 ========== 
    function Video3D(viewer, options) {
        _classCallCheck(this, Video3D);

        this.viewer = viewer;

        options = options || {};

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码 
        if (Cesium.defined(options.debugFrustum)) options.showFrustum = options.debugFrustum;
        this.debugFrustum = this.showFrustum;
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

        this._cameraPosition = options.cameraPosition; //相机位置
        this._position = options.position; //视点位置
        this.type = options.type; //投影类型
        this.alpha = options.alpha || 1.0; //透明度
        this.color = options.color; //投影的颜色
        this._debugFrustum = Cesium.defaultValue(options.showFrustum, true); //显示视椎体

        this._aspectRatio = options.aspectRatio || this._getWinWidHei(); //宽高比
        var fov = options.fov && Cesium.Math.toRadians(options.fov);
        this._camerafov = fov || this.viewer.scene.camera.frustum.fov; //相机水平张角
        this.videoTexture = this.texture = options.texture || new Cesium.Texture({ //默认材质
            context: this.viewer.scene.context,
            source: {
                width: 1,
                height: 1,
                arrayBufferView: new Uint8Array([255, 255, 255, 255])
            },
            flipY: false
        });
        this._videoPlay = Cesium.defaultValue(options.videoPlay, true); //暂停播放
        this.defaultShow = Cesium.defaultValue(options.show, true); //显示和隐藏
        this.clearBlack = Cesium.defaultValue(options.clearBlack, false); //消除鱼眼视频的黑色
        this._rotateDeg = 1;
        this._dirObj = Cesium.defaultValue(options.dirObj, undefined);
        this.text = Cesium.defaultValue(options.text, undefined);
        this.textStyles = Cesium.defaultValue(options.textStyles, textStyles);
        this._disViewColor = Cesium.defaultValue(options.disViewColor, new Cesium.Color(0, 0, 0, 0.5));

        if (!this.cameraPosition || !this.position) {
            marslog.warn("初始化失败：请确认相机位置与视点位置正确！");
            return;
        }

        //传入了DOM
        if (options.dom) {
            this.dom = options.dom;
            if (this.dom instanceof HTMLElement) {
                this.dom = options.dom;
            }
            if (options.dom instanceof Object && options.dom.length) {
                this.dom = options.dom[0];
            }
        }
        //传入了URL
        this.url = options.url; //url


        switch (this.type) {
            default:
            case Video3DType.Video:
                this.activeVideo(this.url);
                break;
            case Video3DType.Image:
                this.activePicture(this.url);
                this.deActiveVideo();
                break;
            case Video3DType.Color:
                this.activeColor(this.color);
                this.deActiveVideo();
                break;
            case Video3DType.Text:
                this.activeText(this.text, this.textStyles);
                this.deActiveVideo();
                break;
        }

        this._createShadowMap();
        this._getOrientation();
        this._addCameraFrustum();
        this._addPostProcess();
        this.viewer.scene.primitives.add(this);
    }

    //========== 对外属性 ========== 
    //混合系数0-1


    _createClass(Video3D, [{
        key: "rotateCamera",


        //旋转相机
        value: function rotateCamera(axis, deg) {
            var rotateDegree = Cesium.defaultValue(deg, this._rotateDeg);
            switch (axis) {
                case ratateDirection.LEFT:
                    break;
                case ratateDirection.RIGHT:
                    rotateDegree *= -1;
                    break;
                case ratateDirection.TOP:
                    break;
                case ratateDirection.BOTTOM:
                    rotateDegree *= -1;
                    break;
                case ratateDirection.ALONG:
                    break;
                case ratateDirection.INVERSE:
                    rotateDegree *= -1;
                    break;
            }
            var newDir = this._computedNewViewDir(axis, rotateDegree);

            this.viewer.scene.postProcessStages.remove(this.postProcess);
            this.viewer.scene.primitives.remove(this.cameraFrustum);
            this.viewShadowMap.destroy();
            this.cameraFrustum.destroy();
            this._resetCameraDir(newDir);
            this._getOrientation();
            this._addCameraFrustum();
            this._addPostProcess();
        }
    }, {
        key: "_resetCameraDir",
        value: function _resetCameraDir(dirObj) {
            if (!dirObj || !dirObj.up || !dirObj.right || !dirObj.direction) return;
            this._dirObj = dirObj;
            this._createShadowMap();
        }
        //计算新视点

    }, {
        key: "_computedNewViewDir",
        value: function _computedNewViewDir(axis, deg) {
            deg = Cesium.Math.toRadians(deg);
            var camera = this.viewShadowMap._lightCamera;
            var oldDir = Cesium.clone(camera.direction);
            var oldRight = Cesium.clone(camera.right);
            var oldTop = Cesium.clone(camera.up);
            var mat3 = new Cesium.Matrix3();

            switch (axis) {
                case ratateDirection.LEFT:
                    Cesium.Matrix3.fromRotationZ(deg, mat3);
                    break;
                case ratateDirection.RIGHT:
                    Cesium.Matrix3.fromRotationZ(deg, mat3);
                    break;
                case ratateDirection.TOP:
                    Cesium.Matrix3.fromRotationY(deg, mat3);
                    break;
                case ratateDirection.BOTTOM:
                    Cesium.Matrix3.fromRotationY(deg, mat3);
                    break;
                case ratateDirection.ALONG:
                    Cesium.Matrix3.fromRotationX(deg, mat3);
                    break;
                case ratateDirection.INVERSE:
                    Cesium.Matrix3.fromRotationX(deg, mat3);
                    break;
            }
            var localToWorld_Matrix = Cesium.Transforms.eastNorthUpToFixedFrame(camera.position);
            // var hpr = new Cesium.HeadingPitchRoll(viewer.camera.heading,viewer.camera.pitch,viewer.camera.roll);
            // localToWorld_Matrix = Cesium.Transforms.headingPitchRollToFixedFrame(viewer.camera.position,hpr,Cesium.Ellipsoid.WGS84,Cesium.Transforms.eastNorthUpToFixedFrame);
            var worldToLocal_Matrix = Cesium.Matrix4.inverse(localToWorld_Matrix, new Cesium.Matrix4());

            var localDir = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldDir, new Cesium.Cartesian3());
            var localNewDir = Cesium.Matrix3.multiplyByVector(mat3, localDir, new Cesium.Cartesian3());
            var newDir = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewDir, new Cesium.Cartesian3());

            var localRight = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldRight, new Cesium.Cartesian3());
            var localNewRight = Cesium.Matrix3.multiplyByVector(mat3, localRight, new Cesium.Cartesian3());
            var newRight = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewRight, new Cesium.Cartesian3());

            var localTop = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldTop, new Cesium.Cartesian3());
            var localNewTop = Cesium.Matrix3.multiplyByVector(mat3, localTop, new Cesium.Cartesian3());
            var newTop = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewTop, new Cesium.Cartesian3());
            return {
                direction: newDir,
                right: newRight,
                up: newTop
            };
        }
    }, {
        key: "getPercentagePoint",
        value: function getPercentagePoint(cartesian) {
            if (!cartesian) return;
            var vm = this.viewShadowMap._lightCamera._viewMatrix;
            var pm = this.viewShadowMap._lightCamera.frustum.projectionMatrix;
            var c4 = new Cesium.Cartesian4(cartesian.x, cartesian.y, cartesian.z, 1.0);
            var pvm = Cesium.Matrix4.multiply(pm, vm, new Cesium.Matrix4());
            var epos1 = Cesium.Matrix4.multiplyByVector(pvm, c4, new Cesium.Cartesian4());
            var epos2 = new Cesium.Cartesian2(epos1.x / epos1.w, epos1.y / epos1.w);
            var epos3 = new Cesium.Cartesian2(epos2.x / 2 + 0.5, epos2.y / 2 + 0.5);
            return epos3;
        }

        /**
         * 改变相机的水平张角
         */

    }, {
        key: "_changeCameraFov",
        value: function _changeCameraFov() {
            this.viewer.scene.postProcessStages.remove(this.postProcess);
            this.viewer.scene.primitives.remove(this.cameraFrustum);
            this._createShadowMap();
            this._getOrientation();
            this._addCameraFrustum();
            this._addPostProcess();
        }

        /**
         * 改变相机视野的宽高比例（垂直张角）
         */

    }, {
        key: "_changeVideoWidHei",
        value: function _changeVideoWidHei() {
            this.viewer.scene.postProcessStages.remove(this.postProcess);
            this.viewer.scene.primitives.remove(this.cameraFrustum);
            this._createShadowMap();
            this._getOrientation();
            this._addCameraFrustum();
            this._addPostProcess();
        }

        /**
         * 改变相机的位置
         */

    }, {
        key: "_changeCameraPos",
        value: function _changeCameraPos() {
            this.viewer.scene.postProcessStages.remove(this.postProcess);
            this.viewer.scene.primitives.remove(this.cameraFrustum);
            this.viewShadowMap.destroy();
            this.cameraFrustum.destroy();
            this._createShadowMap(true);
            this._getOrientation();
            this._addCameraFrustum();
            this._addPostProcess();
        }

        /**
         * 改变相机视点的位置
         */

    }, {
        key: "_changeViewPos",
        value: function _changeViewPos() {
            this.viewer.scene.postProcessStages.remove(this.postProcess);
            this.viewer.scene.primitives.remove(this.cameraFrustum);
            this.viewShadowMap.destroy();
            this.cameraFrustum.destroy();
            this._createShadowMap(true);
            this._getOrientation();
            this._addCameraFrustum();
            this._addPostProcess();
        }
    }, {
        key: "_switchShow",
        value: function _switchShow() {
            if (this.show) {
                !this.postProcess && this._addPostProcess();
            } else {
                this.viewer.scene.postProcessStages.remove(this.postProcess);
                delete this.postProcess;
                this.postProcess = null;
            }
            // this.cameraFrustum.show = this.show;
        }

        /**
         * 激活或重置视频URL
         * @param videoSrc
         * @returns 
         */

    }, {
        key: "activeVideo",
        value: function activeVideo(videoSrc) {
            //在可视域添加视频
            var videoElement;
            if (this.dom) {
                videoElement = this.dom;
            } else {
                videoElement = this._createVideoEle(videoSrc);
            }

            var that = this;
            if (videoElement) {
                this.type = Video3DType.Video;
                this.videoElement = videoElement;
                videoElement.addEventListener("canplaythrough", function () {
                    if (!that.viewer) return;
                    that.viewer.clock.onTick.addEventListener(that.activeVideoListener, that);
                });
            }
        }
    }, {
        key: "activeVideoListener",
        value: function activeVideoListener() {
            try {
                if (this._videoPlay && this.videoElement.paused) this.videoElement.play();
            } catch (e) {}

            if (!this.videoElement || !this.viewer) return;

            this.videoTexture && this.videoTexture.destroy();
            this.videoTexture = new Cesium.Texture({
                context: this.viewer.scene.context,
                source: this.videoElement,
                pixelFormat: Cesium.PixelFormat.RGBA,
                pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE
            });
        }

        //删除视频播放监听

    }, {
        key: "deActiveVideo",
        value: function deActiveVideo() {
            this.viewer.clock.onTick.removeEventListener(this.activeVideoListener, this);
            delete this.activeVideoListener;
        }

        /**
         * 激活或重置图片URL
         * @param videoSrc
         * @returns 
         */

    }, {
        key: "activePicture",
        value: function activePicture(picSrc) {

            //在可视域添加图片    
            this.videoTexture = this.texture;

            var that = this;
            var image = new Image();
            image.onload = function () {
                that.type = Video3DType.Image;
                that.videoTexture = new Cesium.Texture({
                    context: that.viewer.scene.context,
                    source: image
                });
            };
            image.onerror = function () {
                marslog.warn('图片加载失败：' + picSrc);
            };
            image.src = picSrc;
        }
    }, {
        key: "activeColor",


        /**
         * 激活或重置颜色
         * @param color
         * @returns 
         */
        value: function activeColor(color) {
            //在可视域添加纯色
            var that = this;
            this.type = Video3DType.Color;
            var r, g, b, a;
            if (color) {
                r = color.red * 255;
                g = color.green * 255;
                b = color.blue * 255;
                a = color.alpha * 255;
            } else {
                r = Math.random() * 255;
                g = Math.random() * 255;
                b = Math.random() * 255;
                a = Math.random() * 255;
            }
            that.videoTexture = new Cesium.Texture({
                context: that.viewer.scene.context,
                source: {
                    width: 1,
                    height: 1,
                    arrayBufferView: new Uint8Array([r, g, b, a])
                },
                flipY: false
            });
        }

        /**
         * 激活或重置文本
         * @param text
         * @param styles
         * @returns 
         */
        // Name	               Type	          Default	                     Description
        // font	               String	      '10px sans-serif'	             optional The CSS font to use.
        // textBaseline	       String	      'bottom'	                     optional The baseline of the text.
        // fill	               Boolean	      true	                         optional Whether to fill the text.
        // stroke	           Boolean	      false	                         optional Whether to stroke the text.
        // fillColor	       Color	      Color.WHITE	                 optional The fill color.
        // strokeColor	       Color	      Color.BLACK	                 optional The stroke color.
        // strokeWidth	       Number	      1	                             optional The stroke width.
        // backgroundColor	   Color	      Color.TRANSPARENT	             optional The background color of the canvas.
        // padding	           Number	      0	                             optional The pixel size of the padding to add around the text.

    }, {
        key: "activeText",
        value: function activeText(text, styles) {
            //在可视域添加纯色
            var that = this;
            this.type = Video3DType.Text;
            if (!text) return;
            styles = styles || {};
            styles.textBaseline = 'top';
            this.textCanvas = Cesium.writeTextToCanvas(text, styles);
            that.videoTexture = new Cesium.Texture({
                context: that.viewer.scene.context,
                source: this.textCanvas,
                flipY: true
            });
        }

        /**
         * 呈现投影相机的第一视角
         */

    }, {
        key: "locate",
        value: function locate() {
            var camera_pos = Cesium.clone(this.cameraPosition);
            var lookat_pos = Cesium.clone(this.position);
            this.viewer.camera.position = camera_pos;
            if (this._dirObj) {
                this.viewer.camera.direction = Cesium.clone(this._dirObj.direction);
                this.viewer.camera.right = Cesium.clone(this._dirObj.right);
                this.viewer.camera.up = Cesium.clone(this._dirObj.up);
                return;
            }
            this.viewer.camera.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
            this.viewer.camera.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));
        }

        //获取四元数

    }, {
        key: "_getOrientation",
        value: function _getOrientation() {
            var cpos = this.cameraPosition;
            var position = this.position;
            var direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(position, cpos, new Cesium.Cartesian3()), new Cesium.Cartesian3());
            var up = Cesium.Cartesian3.normalize(cpos, new Cesium.Cartesian3());
            var camera = new Cesium.Camera(this.viewer.scene);
            camera.position = cpos;
            camera.direction = direction;
            camera.up = up;
            direction = camera.directionWC;
            up = camera.upWC;
            var right = camera.rightWC;
            var scratchRight = new Cesium.Cartesian3();
            var scratchRotation = new Cesium.Matrix3();
            var scratchOrientation = new Cesium.Quaternion();

            // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());
            right = Cesium.Cartesian3.negate(right, scratchRight);
            var rotation = scratchRotation;
            Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
            Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
            Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
            //计算视锥姿态
            var orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
            this.orientation = orientation;
            return orientation;
        }
        //创建video元素

    }, {
        key: "_createVideoEle",
        value: function _createVideoEle(src) {
            //创建可视域video DOM  元素  
            var source_map4 = document.createElement("SOURCE");
            source_map4.type = 'video/mp4';
            source_map4.src = src;

            var source_mov = document.createElement("SOURCE");
            source_mov.type = 'video/quicktime';
            source_mov.src = src;

            var videoEle = document.createElement("video");
            videoEle.setAttribute('autoplay', true);
            videoEle.setAttribute('loop', true);
            videoEle.setAttribute('crossorigin', true);
            videoEle.appendChild(source_map4);
            videoEle.appendChild(source_mov);
            videoEle.style.display = 'none';
            document.body.appendChild(videoEle);
            return videoEle;
        }

        //获取canvas宽高

    }, {
        key: "_getWinWidHei",
        value: function _getWinWidHei() {
            var scene = this.viewer.scene;
            return scene.canvas.clientWidth / scene.canvas.clientHeight;
        }

        //创建ShadowMap

    }, {
        key: "_createShadowMap",
        value: function _createShadowMap(reset) {
            var camera_pos = this.cameraPosition;
            var lookat_pos = this.position;
            var scene = this.viewer.scene;
            var camera1 = new Cesium.Camera(scene);
            camera1.position = camera_pos;
            if (this._dirObj && !reset) {
                camera1.direction = this._dirObj.direction;
                camera1.right = this._dirObj.right;
                camera1.up = this._dirObj.up;
            } else {
                camera1.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
                camera1.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));
                // this._dirObj = {
                //     direction:camera1.direction,
                //     right:camera1.right,
                //     up:camera1.up
                // }
            }

            var far = Cesium.Cartesian3.distance(lookat_pos, camera_pos);
            this.viewDis = far;
            camera1.frustum = new Cesium.PerspectiveFrustum({
                fov: this.fov,
                aspectRatio: this.aspectRatio,
                near: 0.1,
                far: far * 2
            });

            var isSpotLight = true;
            this.viewShadowMap = new Cesium.ShadowMap({
                lightCamera: camera1,
                enable: false,
                isPointLight: !isSpotLight,
                isSpotLight: isSpotLight,
                cascadesEnabled: false,
                context: scene.context,
                pointLightRadius: far
            });
        }

        //添加视椎体

    }, {
        key: "_addCameraFrustum",
        value: function _addCameraFrustum() {
            var that = this;
            this.cameraFrustum = new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                    geometry: new Cesium.FrustumOutlineGeometry({
                        origin: that.cameraPosition,
                        orientation: that.orientation,
                        frustum: this.viewShadowMap._lightCamera.frustum,
                        _drawNearPlane: true
                    }),
                    attributes: {
                        color: Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(0.0, 0.5, 0.5))
                    }
                }),
                appearance: new Cesium.PerInstanceColorAppearance({
                    translucent: false,
                    flat: true
                }),
                asynchronous: false,
                show: this.showFrustum && this.show
            });
            this.viewer.scene.primitives.add(this.cameraFrustum);
        }
        //添加后处理

    }, {
        key: "_addPostProcess",
        value: function _addPostProcess() {
            var that = this;
            var bias = that.viewShadowMap._isPointLight ? that.viewShadowMap._pointBias : that.viewShadowMap._primitiveBias;
            if (!this.show) return;
            this.postProcess = new Cesium.PostProcessStage({
                fragmentShader: _Video3D2.default,
                uniforms: {
                    mixNum: function mixNum() {
                        return that.alpha;
                    },
                    marsShadow: function marsShadow() {
                        return that.viewShadowMap._shadowMapTexture;
                    },
                    videoTexture: function videoTexture() {
                        return that.videoTexture;
                    },
                    _shadowMap_matrix: function _shadowMap_matrix() {
                        return that.viewShadowMap._shadowMapMatrix;
                    },
                    shadowMap_lightPositionEC: function shadowMap_lightPositionEC() {
                        return that.viewShadowMap._lightPositionEC;
                    },
                    shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function shadowMap_texelSizeDepthBiasAndNormalShadingSmooth() {
                        var texelStepSize = new Cesium.Cartesian2();
                        texelStepSize.x = 1.0 / that.viewShadowMap._textureSize.x;
                        texelStepSize.y = 1.0 / that.viewShadowMap._textureSize.y;
                        return Cesium.Cartesian4.fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);
                    },
                    shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness() {
                        return Cesium.Cartesian4.fromElements(bias.normalOffsetScale, that.viewShadowMap._distance, that.viewShadowMap.maximumDistance, that.viewShadowMap._darkness, this.combinedUniforms2);
                    },
                    disViewColor: function disViewColor() {
                        return that._disViewColor;
                    },
                    clearBlack: function clearBlack() {
                        return that.clearBlack;
                    }
                }
            });
            this.viewer.scene.postProcessStages.add(this.postProcess);
        }
    }, {
        key: "update",
        value: function update(frameState) {
            this.viewShadowMap && frameState.shadowMaps.push(this.viewShadowMap);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.viewer.scene.primitives.remove(this);
            if (!this.viewer) return;

            this.viewer.scene.postProcessStages.remove(this.postProcess);
            this.viewer.scene.primitives.remove(this.cameraFrustum);

            if (this.videoElement) {
                this.videoElement.parentNode.removeChild(this.videoElement);
            }
            this.deActiveVideo();

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: "alpha",
        get: function get() {
            return this._alpha;
        },
        set: function set(val) {
            this._alpha = val;
        }

        //相机宽高比例

    }, {
        key: "aspectRatio",
        get: function get() {
            return this._aspectRatio;
        },
        set: function set(val) {
            this._aspectRatio = val;
            this._changeVideoWidHei();
        }
        //视椎体显隐

    }, {
        key: "showFrustum",
        get: function get() {
            return this._debugFrustum;
        },
        set: function set(val) {
            this._debugFrustum = val;
            this.cameraFrustum.show = val;
        }
        //相机水平张角

    }, {
        key: "fov",
        get: function get() {
            return this._camerafov;
        },
        set: function set(val) {
            this._camerafov = Cesium.Math.toRadians(val);
            this._changeCameraFov();
        }
        //相机位置

    }, {
        key: "cameraPosition",
        get: function get() {
            return this._cameraPosition;
        },
        set: function set(pos) {
            if (!pos) return;
            this._cameraPosition = pos;
            this._changeCameraPos();
        }
        //视点位置

    }, {
        key: "position",
        get: function get() {
            return this._position;
        },
        set: function set(pos) {
            if (!pos) return;
            this._position = pos;
            this._changeViewPos();
        }
        //切换视频 播放/暂停

    }, {
        key: "videoPlay",
        get: function get() {
            return this._videoPlay;
        },
        set: function set(val) {
            this._videoPlay = Boolean(val);
            if (this.videoElement) {
                if (this.videoPlay) this.videoElement.play();else this.videoElement.pause();
            }
        }

        /** 所有相机的参数  */

    }, {
        key: "params",
        get: function get() {
            var viewJson = {};
            viewJson.type = this.type;
            if (this.type == Video3DType.Color) viewJson.color = this.color;else viewJson.url = this.url;

            viewJson.position = this.position;
            viewJson.cameraPosition = this.cameraPosition;
            viewJson.fov = Cesium.Math.toDegrees(this.fov);
            viewJson.aspectRatio = this.aspectRatio;
            viewJson.alpha = this.alpha;
            viewJson.showFrustum = this.showFrustum;
            viewJson.dirObj = this._dirObj;
            return viewJson;
        }

        //显示和隐藏

    }, {
        key: "show",
        get: function get() {
            return this.defaultShow;
        },
        set: function set(val) {
            this.defaultShow = Boolean(val);
            this._switchShow();
        }
    }, {
        key: "camera",
        get: function get() {
            return this.viewShadowMap._lightCamera;
        }
        //========== 方法 ========== 

    }, {
        key: "disViewColor",
        get: function get() {
            return this._disViewColor;
        },
        set: function set(color) {
            if (!color) return;
            this._disViewColor = color;
            if (!color.a && color.a != 0) {
                this._disViewColor.a = 1.0;
            }
        }
    }]);

    return Video3D;
}();

Video3D.Type = Video3DType;

/***/ }),
/* 234 */
/***/ (function(module, exports) {

module.exports = "\r\n\r\n\r\n\r\nuniform float mixNum;\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D marsShadow; \r\nuniform sampler2D videoTexture;\r\nuniform sampler2D depthTexture;\r\nuniform mat4 _shadowMap_matrix; \r\nuniform vec4 shadowMap_lightPositionEC; \r\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \r\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \r\nuniform vec4 disViewColor;\r\nuniform bool clearBlack;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\r\n    return texture2D(shadowMap, uv).r;\r\n}\r\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\r\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\r\n}\r\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\r\n    float depthBias = shadowParameters.depthBias;\r\n    float depth = shadowParameters.depth;\r\n    float nDotL = shadowParameters.nDotL;\r\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\r\n    float darkness = shadowParameters.darkness;\r\n    vec2 uv = shadowParameters.texCoords;\r\n    depth -= depthBias;\r\n    vec2 texelStepSize = shadowParameters.texelStepSize;\r\n    float radius = 1.0;\r\n    float dx0 = -texelStepSize.x * radius;\r\n    float dy0 = -texelStepSize.y * radius;\r\n    float dx1 = texelStepSize.x * radius;\r\n    float dy1 = texelStepSize.y * radius;\r\n    float visibility = \r\n    (\r\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\r\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\r\n    ) * (1.0 / 9.0)\r\n    ;\r\n    return visibility;\r\n}\r\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\r\n    vec3 v01 = point -planeOrigin;\r\n    float d = dot(planeNormal, v01) ;\r\n    return (point - planeNormal * d);\r\n}\r\nfloat ptm(vec3 pt){\r\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\r\n}\r\nvoid main() \r\n{ \r\n    const float PI = 3.141592653589793;\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 normalEC = vec3(1.0);\r\n    czm_shadowParameters shadowParameters; \r\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \r\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \r\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \r\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \r\n    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \r\n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \r\n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \r\n    vec4 shadowPosition = _shadowMap_matrix * positionEC; \r\n    shadowPosition /= shadowPosition.w; \r\n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \r\n    { \r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    shadowParameters.texCoords = shadowPosition.xy; \r\n    shadowParameters.depth = shadowPosition.z; \r\n    shadowParameters.nDotL = nDotL; \r\n    float visibility = _czm_shadowVisibility(marsShadow, shadowParameters); \r\n\r\n    vec4 videoColor = texture2D(videoTexture,shadowPosition.xy);\r\n    if(clearBlack){\r\n        if(videoColor.r + videoColor.g + videoColor.b <0.01){\r\n            gl_FragColor = color;\r\n            return;\r\n        }\r\n    }\r\n    if(visibility==1.0){\r\n        gl_FragColor = mix(color,vec4(videoColor.xyz,1.0),mixNum*videoColor.a);\r\n    }else{\r\n        if(abs(shadowPosition.z-0.0)<0.01){\r\n            return;\r\n        }\r\n        if(clearBlack){\r\n            gl_FragColor = color;\r\n            return;\r\n        }\r\n        gl_FragColor = vec4(mix(color.rgb,disViewColor.rgb,disViewColor.a),disViewColor.a);\r\n    }\r\n} "

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Video2D = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MarsClass2 = __webpack_require__(3);

var _log = __webpack_require__(5);

var marslog = _interopRequireWildcard(_log);

var _util = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ratateDirection = {
    'LEFT': 'Z',
    'RIGHT': '-Z',
    'TOP': 'Y',
    'BOTTOM': '-Y',
    'ALONG': 'X',
    'INVERSE': '-X'

    //视频融合（投射2D平面）
    //原理：根据相机位置，方向等参数，在相机前面生成一个平面，然后贴视频纹理
};
var Video2D = exports.Video2D = function (_MarsClass) {
    _inherits(Video2D, _MarsClass);

    //========== 构造方法 ========== 
    function Video2D(viewer, options, oldparam) {
        _classCallCheck(this, Video2D);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (Video2D.__proto__ || Object.getPrototypeOf(Video2D)).call(this, options));

        if (oldparam) {
            oldparam.dom = options;
            options = oldparam;
        }
        if (Cesium.defined(options.frustumShow)) options.showFrustum = options.frustumShow;
        _this.frustumShow = _this.showFrustum;
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码


        _this.viewer = viewer;
        _this.options = options;

        _this._play = true;
        if (options.aspectRatio) {
            _this._aspectRatio = options.aspectRatio;
        } else {
            _this._aspectRatio = _this.viewer.scene.context.drawingBufferWidth / _this.viewer.scene.context.drawingBufferHeight;
        }

        _this._fov = Cesium.defaultValue(options.fov, _this.viewer.scene.camera.frustum.fov);
        _this._dis = Cesium.defaultValue(options.dis, 10);
        _this._stRotation = Cesium.defaultValue(options.stRotation, 0);
        _this._rotateCam = Cesium.defaultValue(options.rotateCam, 0.05);
        _this._frustumShow = Cesium.defaultValue(options.showFrustum, true);

        _this._camera = options.camera;

        //传入了DOM
        if (options.dom) {
            if (options.dom instanceof Object && options.dom.length) {
                _this.dom = options.dom[0];
            } else {
                _this.dom = options.dom;
            }
        }

        //兼容直接传入单击回调方法，适合简单场景下使用。
        if (options.click) {
            _this.on(_MarsClass2.eventType.click, options.click);
        }

        _this.init();
        return _this;
    }

    //视频播放暂停


    _createClass(Video2D, [{
        key: 'init',
        value: function init() {
            this.recordObj = this.record();
            this.rectPos = this.computedPos(this.dis, this.fov, this.aspectRatio, this.recordObj);
            var sys = this.getOrientation(this.recordObj);
            var frustum = this.createFrustum(this.fov, this.aspectRatio, this.dis);
            var frustumGeo = this.createFrustumGeo(frustum, sys, this.recordObj.position);
            this.frustumPri = this.createFrustumPri(frustumGeo);
            this.addToScene();
        }
    }, {
        key: 'reset',
        value: function reset() {
            this.viewer.scene.primitives.remove(this.frustumPri);
            this.viewer.entities.remove(this.entity);

            this.rectPos = this.computedPos(this.dis, this.fov, this.aspectRatio, this.recordObj);
            var sys = this.getOrientation(this.recordObj);
            var frustum = this.createFrustum(this.fov, this.aspectRatio, this.dis);
            var frustumGeo = this.createFrustumGeo(frustum, sys, this.recordObj.position);
            this.frustumPri = this.createFrustumPri(frustumGeo);
            this.addToScene();
        }
    }, {
        key: 'record',
        value: function record() {
            var obj = {};
            var camera = this._camera || this.viewer.scene.camera;
            obj.direction = Cesium.clone(camera.direction);
            obj.up = Cesium.clone(camera.up);
            obj.right = Cesium.clone(camera.right);
            obj.position = Cesium.clone(camera.position);
            return obj;
        }
    }, {
        key: 'addToScene',
        value: function addToScene() {
            this.viewer.scene.primitives.add(this.frustumPri);
            this.entity = this.viewer.entities.add({
                polygon: {
                    hierarchy: this.rectPos,
                    perPositionHeight: true,
                    material: this.dom || this.options.material,
                    stRotation: this.stRotation
                },
                data: this.options,
                eventTarget: this,
                popup: this.options.popup,
                tooltip: this.options.tooltip
            });
        }
    }, {
        key: 'computedPos',
        value: function computedPos(dis, fov, kgb, camera) {
            var vpos = camera.position;
            var vdir = camera.direction;
            var vright = camera.right;
            var vup = camera.up;

            var vray = new Cesium.Ray(vpos, vdir);
            var vmbpos = Cesium.Ray.getPoint(vray, dis, new Cesium.Cartesian3());
            var halfFov = fov / 2.0;
            var tanres = Math.tan(halfFov);
            var horiDis = dis * tanres;
            var vertDis = horiDis / kgb;
            var xbDis = Math.sqrt(horiDis * horiDis + vertDis * vertDis);

            var ysj = new Cesium.Cartesian3();
            var rightRay = new Cesium.Ray(vmbpos, vright);
            var rightPos = Cesium.Ray.getPoint(rightRay, horiDis, new Cesium.Cartesian3());
            var upRay = new Cesium.Ray(rightPos, vup);
            Cesium.Ray.getPoint(upRay, vertDis, ysj);

            var yxj = new Cesium.Cartesian3();
            var fvup = Cesium.Cartesian3.negate(vup, new Cesium.Cartesian3());
            var fupRay = new Cesium.Ray(rightPos, fvup);
            Cesium.Ray.getPoint(fupRay, vertDis, yxj);

            var zxj = new Cesium.Cartesian3();
            var djdir1 = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(vmbpos, ysj, new Cesium.Cartesian3()), new Cesium.Cartesian3());
            var djRay1 = new Cesium.Ray(vmbpos, djdir1);
            Cesium.Ray.getPoint(djRay1, xbDis, zxj);

            var zsj = new Cesium.Cartesian3();
            var djdir2 = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(vmbpos, yxj, new Cesium.Cartesian3()), new Cesium.Cartesian3());
            var djRay2 = new Cesium.Ray(vmbpos, djdir2);
            Cesium.Ray.getPoint(djRay2, xbDis, zsj);

            if (this.options.reverse) {
                return [zxj, zsj, ysj, yxj].reverse();
            }
            return [zxj, zsj, ysj, yxj];
        }
    }, {
        key: 'createFrustum',
        value: function createFrustum(fov, kgb, dis) {
            return new Cesium.PerspectiveFrustum({
                fov: fov,
                aspectRatio: kgb,
                near: 0.1,
                far: dis
            });
        }
    }, {
        key: 'getOrientation',
        value: function getOrientation(camera) {
            if (!camera) return;
            var direction = camera.direction;
            var up = camera.up;
            var right = camera.right;
            var scratchRight = new Cesium.Cartesian3();
            var scratchRotation = new Cesium.Matrix3();
            var scratchOrientation = new Cesium.Quaternion();

            // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());
            right = Cesium.Cartesian3.negate(right, scratchRight);
            var rotation = scratchRotation;
            Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
            Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
            Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
            //计算视锥姿态
            var orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
            return orientation;
        }
    }, {
        key: 'createFrustumGeo',
        value: function createFrustumGeo(frustum, sys, origin) {
            return new Cesium.FrustumOutlineGeometry({
                frustum: frustum,
                orientation: sys,
                origin: origin
            });
        }
    }, {
        key: 'createFrustumPri',
        value: function createFrustumPri(geo) {
            return new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                    geometry: geo,
                    attributes: {
                        color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AZURE)
                    }
                }),
                appearance: new Cesium.PerInstanceColorAppearance({
                    flat: true
                }),
                show: this.showFrustum
            });
        }
        /**
         * 呈现投影相机的第一视角
         */

    }, {
        key: 'locate',
        value: function locate() {
            this.viewer.camera.direction = Cesium.clone(this.recordObj.direction);
            this.viewer.camera.right = Cesium.clone(this.recordObj.right);
            this.viewer.camera.up = Cesium.clone(this.recordObj.up);
            this.viewer.camera.position = Cesium.clone(this.recordObj.position);
        }

        //旋转相机

    }, {
        key: 'rotateCamera',
        value: function rotateCamera(axis, deg) {
            var rotateDegree = Cesium.defaultValue(deg, this._rotateCam);
            switch (axis) {
                case ratateDirection.LEFT:
                    break;
                case ratateDirection.RIGHT:
                    rotateDegree *= -1;
                    break;
                case ratateDirection.TOP:
                    break;
                case ratateDirection.BOTTOM:
                    rotateDegree *= -1;
                    break;
                case ratateDirection.ALONG:
                    break;
                case ratateDirection.INVERSE:
                    rotateDegree *= -1;
                    break;
            }
            var newObj = this._computedNewViewDir(axis, rotateDegree);
            this.recordObj.direction = newObj.direction;
            this.recordObj.up = newObj.up;
            this.recordObj.right = newObj.right;
            this.reset();
        }

        //计算新视点

    }, {
        key: '_computedNewViewDir',
        value: function _computedNewViewDir(axis, deg) {
            deg = Cesium.Math.toRadians(deg);
            var camera = this.recordObj;
            var oldDir = Cesium.clone(camera.direction);
            var oldRight = Cesium.clone(camera.right);
            var oldTop = Cesium.clone(camera.up);
            var mat3 = new Cesium.Matrix3();

            switch (axis) {
                case ratateDirection.LEFT:
                    Cesium.Matrix3.fromRotationZ(deg, mat3);
                    break;
                case ratateDirection.RIGHT:
                    Cesium.Matrix3.fromRotationZ(deg, mat3);
                    break;
                case ratateDirection.TOP:
                    Cesium.Matrix3.fromRotationY(deg, mat3);
                    break;
                case ratateDirection.BOTTOM:
                    Cesium.Matrix3.fromRotationY(deg, mat3);
                    break;
                case ratateDirection.ALONG:
                    Cesium.Matrix3.fromRotationX(deg, mat3);
                    break;
                case ratateDirection.INVERSE:
                    Cesium.Matrix3.fromRotationX(deg, mat3);
                    break;
            }
            var localToWorld_Matrix = Cesium.Transforms.eastNorthUpToFixedFrame(camera.position);
            // var hpr = new Cesium.HeadingPitchRoll(viewer.camera.heading,viewer.camera.pitch,viewer.camera.roll);
            // localToWorld_Matrix = Cesium.Transforms.headingPitchRollToFixedFrame(viewer.camera.position,hpr,Cesium.Ellipsoid.WGS84,Cesium.Transforms.eastNorthUpToFixedFrame);
            var worldToLocal_Matrix = Cesium.Matrix4.inverse(localToWorld_Matrix, new Cesium.Matrix4());

            var localDir = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldDir, new Cesium.Cartesian3());
            var localNewDir = Cesium.Matrix3.multiplyByVector(mat3, localDir, new Cesium.Cartesian3());
            var newDir = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewDir, new Cesium.Cartesian3());

            var localRight = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldRight, new Cesium.Cartesian3());
            var localNewRight = Cesium.Matrix3.multiplyByVector(mat3, localRight, new Cesium.Cartesian3());
            var newRight = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewRight, new Cesium.Cartesian3());

            var localTop = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldTop, new Cesium.Cartesian3());
            var localNewTop = Cesium.Matrix3.multiplyByVector(mat3, localTop, new Cesium.Cartesian3());
            var newTop = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewTop, new Cesium.Cartesian3());
            return {
                direction: newDir,
                right: newRight,
                up: newTop
            };
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.viewer.scene.primitives.remove(this.frustumPri);
            this.viewer.entities.remove(this.entity);

            //删除所有绑定的数据
            for (var i in this) {
                delete this[i];
            }
        }
    }, {
        key: 'play',
        get: function get() {
            return this._play;
        },
        set: function set(val) {
            this._play = val;
            if (!this.dom) return;

            if (this._play) {
                this.dom.play();
            } else {
                this.dom.pause();
            }
        }
        //宽高比

    }, {
        key: 'aspectRatio',
        get: function get() {
            return this._aspectRatio;
        },
        set: function set(val) {
            val = Number(val);
            if (!val || val < 0) return;
            if (val < 1.0) val = 1.0;
            this._aspectRatio = val;
            this.reset();
        }
        //张角

    }, {
        key: 'fov',
        get: function get() {
            return this._fov;
        },
        set: function set(val) {
            val = Number(val);
            if (!val || val < 0) return;
            this._fov = val;
            this.reset();
        }
        //投射距离

    }, {
        key: 'dis',
        get: function get() {
            return this._dis;
        },
        set: function set(val) {
            val = Number(val);
            if (!val || val < 0) return;
            this._dis = val;
            this.reset();
        }

        //UV旋转

    }, {
        key: 'stRotation',
        get: function get() {
            return this._stRotation;
        },
        set: function set(val) {
            val = Number(val);
            if (!val || val < 0) return;
            this._stRotation = val;
            this.entity.polygon.stRotation = val;
        }

        //视椎体显示

    }, {
        key: 'showFrustum',
        get: function get() {
            return this._frustumShow;
        },
        set: function set(val) {
            this._frustumShow = val;
            this.frustumPri.show = val;
        }

        /** 所有相机的参数  */

    }, {
        key: 'params',
        get: function get() {
            var viewJson = {
                fov: this.fov,
                dis: this.dis,
                stRotation: this.stRotation,
                showFrustum: this.showFrustum,
                aspectRatio: this.aspectRatio,
                camera: {
                    position: this.recordObj.position,
                    direction: this.recordObj.direction,
                    up: this.recordObj.up,
                    right: this.recordObj.right
                }
            };
            return viewJson;
        }
    }]);

    return Video2D;
}(_MarsClass2.MarsClass);

//[静态属性]本类中支持的事件类型常量


Video2D.event = {
    click: _MarsClass2.eventType.click,
    mouseOver: _MarsClass2.eventType.mouseOver,
    mouseOut: _MarsClass2.eventType.mouseOut
};

/***/ })
/******/ ]);
});