/*!
 * 基于Cesium和Mars3D的风向图功能插件
 * 版本信息：v1.5.0, hash值: 4da0bdce2758f9b1e244
 * 编译日期：2020-2-14 10:17:45
 * 版权所有：Copyright by 广州欧科 http://cesium.marsgis.cn
 *
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("cesium/Cesium")):"function"==typeof define&&define.amd?define(["cesium/Cesium"],t):"object"==typeof exports?exports.CesiumWind=t(require("cesium/Cesium")):e.CesiumWind=t(e.Cesium)}(window,(function(e){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=3)}([function(t,r){t.exports=e},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Util=void 0;var n=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(0));t.Util={getFullscreenQuad:function(){return new n.Geometry({attributes:new n.GeometryAttributes({position:new n.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}),st:new n.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array([0,0,1,0,1,1,0,1])})}),indices:new Uint32Array([3,2,0,0,2,1])})},createTexture:function(e,t){if(n.defined(t)){var r={};r.arrayBufferView=t,e.source=r}return new n.Texture(e)},createFramebuffer:function(e,t,r){return new n.Framebuffer({context:e,colorTextures:[t],depthTexture:r})},createRawRenderState:function(e){var t={viewport:e.viewport,depthTest:e.depthTest,depthMask:e.depthMask,blending:e.blending};return n.Appearance.getDefaultRenderState(!0,!1,t)},viewRectangleToLonLatRange:function(e){var t,r,i={},o=n.Math.mod(e.west,n.Math.TWO_PI),a=n.Math.mod(e.east,n.Math.TWO_PI),s=e.width;s>n.Math.THREE_PI_OVER_TWO?(t=0,r=n.Math.TWO_PI):a-o<s?(t=o,r=o+s):(t=o,r=a),i.lon={min:n.Math.toDegrees(t),max:n.Math.toDegrees(r)};var c=e.south,u=e.north,l=e.height,d=l>n.Math.PI/12?l/2:0,p=n.Math.clampToLatitudeRange(c-d),m=n.Math.clampToLatitudeRange(u+d);return p<-n.Math.PI_OVER_THREE&&(p=-n.Math.PI_OVER_TWO),m>n.Math.PI_OVER_THREE&&(m=n.Math.PI_OVER_TWO),i.lat={min:n.Math.toDegrees(p),max:n.Math.toDegrees(m)},i}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CustomPrimitive=void 0;var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(0));t.CustomPrimitive=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.commandType=t.commandType,this.geometry=t.geometry,this.attributeLocations=t.attributeLocations,this.primitiveType=t.primitiveType,this.uniformMap=t.uniformMap,this.vertexShaderSource=t.vertexShaderSource,this.fragmentShaderSource=t.fragmentShaderSource,this.rawRenderState=t.rawRenderState,this.framebuffer=t.framebuffer,this.outputTexture=t.outputTexture,this.autoClear=i.defaultValue(t.autoClear,!1),this.preExecute=t.preExecute,this.show=!0,this.commandToExecute=void 0,this.clearCommand=void 0,this.autoClear&&(this.clearCommand=new i.ClearCommand({color:new i.Color(0,0,0,0),depth:1,framebuffer:this.framebuffer,pass:i.Pass.OPAQUE}))}return n(e,[{key:"createCommand",value:function(e){switch(this.commandType){case"Draw":var t=i.VertexArray.fromGeometry({context:e,geometry:this.geometry,attributeLocations:this.attributeLocations,bufferUsage:i.BufferUsage.STATIC_DRAW}),r=i.ShaderProgram.fromCache({context:e,attributeLocations:this.attributeLocations,vertexShaderSource:this.vertexShaderSource,fragmentShaderSource:this.fragmentShaderSource}),n=i.RenderState.fromCache(this.rawRenderState);return new i.DrawCommand({owner:this,vertexArray:t,primitiveType:this.primitiveType,uniformMap:this.uniformMap,modelMatrix:i.Matrix4.IDENTITY,shaderProgram:r,framebuffer:this.framebuffer,renderState:n,pass:i.Pass.OPAQUE});case"Compute":return new i.ComputeCommand({owner:this,fragmentShaderSource:this.fragmentShaderSource,uniformMap:this.uniformMap,outputTexture:this.outputTexture,persists:!0})}}},{key:"setGeometry",value:function(e,t){this.geometry=t;var r=i.VertexArray.fromGeometry({context:e,geometry:this.geometry,attributeLocations:this.attributeLocations,bufferUsage:i.BufferUsage.STATIC_DRAW});this.commandToExecute.vertexArray=r}},{key:"update",value:function(e){this.show&&(i.defined(this.commandToExecute)||(this.commandToExecute=this.createCommand(e.context)),i.defined(this.preExecute)&&this.preExecute(),i.defined(this.clearCommand)&&e.commandList.push(this.clearCommand),e.commandList.push(this.commandToExecute))}},{key:"isDestroyed",value:function(){return!1}},{key:"destroy",value:function(){return i.defined(this.commandToExecute)&&(this.commandToExecute.shaderProgram=this.commandToExecute.shaderProgram&&this.commandToExecute.shaderProgram.destroy()),i.destroyObject(this)}}]),e}()},function(e,t,r){"use strict";var n=r(4);window.okay3d&&(console.log("请首先引入 okay3d 基础库，才能使用该插件！ http://cesium.marsgis.cn"),okay3d.Wind=n.Wind),e.exports=n.Wind},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Wind=void 0;var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(0)),o=r(5),a=r(1);var s=16384,c=100,u=.996,l=.003,d=.01,p=4,m=4;t.Wind=function(){function e(t,r){if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.viewer=t,this.scene=this.viewer.scene,this.camera=this.viewer.camera,this.primitives=new i.PrimitiveCollection,this.viewer.scene.primitives.add(this.primitives),this.maxParticles=s,this.particleHeight=c,this.fadeOpacity=u,this.dropRate=l,this.dropRateBump=d,this.speedFactor=p,this.lineWidth=m,r)for(var n in r)this[n]=r[n];this.viewerParameters={lonRange:new i.Cartesian2,latRange:new i.Cartesian2,pixelSize:0},this.globeBoundingSphere=new i.BoundingSphere(i.Cartesian3.ZERO,6314355.63),this.updateViewerParameters()}return n(e,[{key:"setData",value:function(e){this.particleSystem=new o.ParticleSystem(this.scene.context,e,this.getUserInput(),this.viewerParameters),this.addPrimitives(),this.setupEventListeners()}},{key:"updateParticleSystemOptions",value:function(e){if(e)for(var t in e)this[t]=e[t];this.particleSystem.applyUserInput(this.getUserInput())}},{key:"getUserInput",value:function(){var e=Math.ceil(Math.sqrt(this.maxParticles));return this.maxParticles=e*e,{particlesTextureSize:e,maxParticles:this.maxParticles,particleHeight:this.particleHeight,fadeOpacity:this.fadeOpacity,dropRate:this.dropRate,dropRateBump:this.dropRateBump,speedFactor:this.speedFactor,lineWidth:this.lineWidth,globeLayer:this.globeLayer,WMS_URL:this.WMS_URL}}},{key:"addPrimitives",value:function(){this.primitives.add(this.particleSystem.particlesComputing.primitives.getWind),this.primitives.add(this.particleSystem.particlesComputing.primitives.updateSpeed),this.primitives.add(this.particleSystem.particlesComputing.primitives.updatePosition),this.primitives.add(this.particleSystem.particlesComputing.primitives.postProcessingPosition),this.primitives.add(this.particleSystem.particlesComputing.primitives.postProcessingSpeed),this.primitives.add(this.particleSystem.particlesRendering.primitives.segments),this.primitives.add(this.particleSystem.particlesRendering.primitives.trails),this.primitives.add(this.particleSystem.particlesRendering.primitives.screen)}},{key:"updateViewerParameters",value:function(){var e=this.camera.computeViewRectangle(this.scene.globe.ellipsoid),t=a.Util.viewRectangleToLonLatRange(e);this.viewerParameters.lonRange.x=t.lon.min,this.viewerParameters.lonRange.y=t.lon.max,this.viewerParameters.latRange.x=t.lat.min,this.viewerParameters.latRange.y=t.lat.max;var r=this.camera.getPixelSize(this.globeBoundingSphere,this.scene.drawingBufferWidth,this.scene.drawingBufferHeight);r>0&&(this.viewerParameters.pixelSize=r)}},{key:"setupEventListeners",value:function(){var e=this;this.camera.moveStart.addEventListener((function(){e._isDestroy||(e.primitives.show=!1)})),this.camera.moveEnd.addEventListener((function(){e._isDestroy||(e.updateViewerParameters(),e.particleSystem.applyViewerParameters(e.viewerParameters),e.primitives.show=!0)}));var t=!1;window.addEventListener("resize",(function(){e._isDestroy||(t=!0,e.primitives.show=!1,e.primitives.removeAll())})),this.scene.preRender.addEventListener((function(){e._isDestroy||t&&(e.particleSystem.canvasResize(e.scene.context),t=!1,e.addPrimitives(),e.primitives.show=!0)}))}},{key:"destroy",value:function(){this._isDestroy=!0,this.primitives.removeAll(),this.viewer.scene.primitives.remove(this.primitives)}}]),e}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ParticleSystem=void 0;var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(0)),o=r(6),a=r(12);t.ParticleSystem=function(){function e(t,r,n,i){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.context=t,this.data=r,this.userInput=n,this.viewerParameters=i,this.particlesComputing=new a.ParticlesComputing(this.context,this.data,this.userInput,this.viewerParameters),this.particlesRendering=new o.ParticlesRendering(this.context,this.data,this.userInput,this.viewerParameters,this.particlesComputing)}return n(e,[{key:"canvasResize",value:function(e){var t=this;this.particlesComputing.destroyParticlesTextures(),Object.keys(this.particlesComputing.windTextures).forEach((function(e){t.particlesComputing.windTextures[e].destroy()})),this.particlesRendering.textures.colorTable.destroy(),Object.keys(this.particlesRendering.framebuffers).forEach((function(e){t.particlesRendering.framebuffers[e].destroy()})),this.context=e,this.particlesComputing=new a.ParticlesComputing(this.context,this.data,this.userInput,this.viewerParameters),this.particlesRendering=new o.ParticlesRendering(this.context,this.data,this.userInput,this.viewerParameters,this.particlesComputing)}},{key:"clearFramebuffers",value:function(){var e=this,t=new i.ClearCommand({color:new i.Color(0,0,0,0),depth:1,framebuffer:void 0,pass:i.Pass.OPAQUE});Object.keys(this.particlesRendering.framebuffers).forEach((function(r){t.framebuffer=e.particlesRendering.framebuffers[r],t.execute(e.context)}))}},{key:"refreshParticles",value:function(e){if(this.clearFramebuffers(),this.particlesComputing.destroyParticlesTextures(),this.particlesComputing.createParticlesTextures(this.context,this.userInput,this.viewerParameters),e){var t=this.particlesRendering.createSegmentsGeometry(this.userInput);this.particlesRendering.primitives.segments.geometry=t;var r=i.VertexArray.fromGeometry({context:this.context,geometry:t,attributeLocations:this.particlesRendering.primitives.segments.attributeLocations,bufferUsage:i.BufferUsage.STATIC_DRAW});this.particlesRendering.primitives.segments.commandToExecute.vertexArray=r}}},{key:"applyUserInput",value:function(e){var t=this,r=!1;this.userInput.maxParticles!=e.maxParticles&&(r=!0),Object.keys(e).forEach((function(r){t.userInput[r]=e[r]})),this.refreshParticles(r)}},{key:"applyViewerParameters",value:function(e){var t=this;Object.keys(e).forEach((function(r){t.viewerParameters[r]=e[r]})),this.refreshParticles(!1)}}]),e}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ParticlesRendering=void 0;var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(0)),o=r(2),a=r(1),s=p(r(7)),c=p(r(8)),u=p(r(9)),l=p(r(10)),d=p(r(11));function p(e){return e&&e.__esModule?e:{default:e}}t.ParticlesRendering=function(){function e(t,r,n,i,o){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.createRenderingTextures(t,r),this.createRenderingFramebuffers(t),this.createRenderingPrimitives(t,n,i,o)}return n(e,[{key:"createRenderingTextures",value:function(e,t){var r={context:e,width:e.drawingBufferWidth,height:e.drawingBufferHeight,pixelFormat:i.PixelFormat.RGBA,pixelDatatype:i.PixelDatatype.UNSIGNED_BYTE},n={context:e,width:e.drawingBufferWidth,height:e.drawingBufferHeight,pixelFormat:i.PixelFormat.DEPTH_COMPONENT,pixelDatatype:i.PixelDatatype.UNSIGNED_INT},o={context:e,width:t.colorTable.colorNum,height:1,pixelFormat:i.PixelFormat.RGB,pixelDatatype:i.PixelDatatype.FLOAT,sampler:new i.Sampler({minificationFilter:i.TextureMinificationFilter.LINEAR,magnificationFilter:i.TextureMagnificationFilter.LINEAR})};this.textures={segmentsColor:a.Util.createTexture(r),segmentsDepth:a.Util.createTexture(n),currentTrailsColor:a.Util.createTexture(r),currentTrailsDepth:a.Util.createTexture(n),nextTrailsColor:a.Util.createTexture(r),nextTrailsDepth:a.Util.createTexture(n),colorTable:a.Util.createTexture(o,t.colorTable.array)}}},{key:"createRenderingFramebuffers",value:function(e){this.framebuffers={segments:a.Util.createFramebuffer(e,this.textures.segmentsColor,this.textures.segmentsDepth),currentTrails:a.Util.createFramebuffer(e,this.textures.currentTrailsColor,this.textures.currentTrailsDepth),nextTrails:a.Util.createFramebuffer(e,this.textures.nextTrailsColor,this.textures.nextTrailsDepth)}}},{key:"createSegmentsGeometry",value:function(e){for(var t=[],r=0;r<e.particlesTextureSize;r++)for(var n=0;n<e.particlesTextureSize;n++)for(var o=0;o<4;o++)t.push(r/e.particlesTextureSize),t.push(n/e.particlesTextureSize);t=new Float32Array(t);var a=[],s=[-1,1],c=[-1,1];for(o=0;o<e.maxParticles;o++)for(var u=0;u<2;u++)for(var l=0;l<2;l++)a.push(s[u]),a.push(c[l]),a.push(0);a=new Float32Array(a);for(var d=6*e.maxParticles,p=new Uint32Array(d),m=(o=0,u=0,0);o<e.maxParticles;o++)p[u++]=m+0,p[u++]=m+1,p[u++]=m+2,p[u++]=m+2,p[u++]=m+1,p[u++]=m+3,m+=4;return new i.Geometry({attributes:new i.GeometryAttributes({st:new i.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:t}),normal:new i.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:a})}),indices:p})}},{key:"createRenderingPrimitives",value:function(e,t,r,n){var p=this;this.primitives={segments:new o.CustomPrimitive({commandType:"Draw",attributeLocations:{st:0,normal:1},geometry:this.createSegmentsGeometry(t),primitiveType:i.PrimitiveType.TRIANGLES,uniformMap:{currentParticlesPosition:function(){return n.particlesTextures.currentParticlesPosition},postProcessingPosition:function(){return n.particlesTextures.postProcessingPosition},postProcessingSpeed:function(){return n.particlesTextures.postProcessingSpeed},colorTable:function(){return p.textures.colorTable},aspect:function(){return e.drawingBufferWidth/e.drawingBufferHeight},pixelSize:function(){return r.pixelSize},lineWidth:function(){return t.lineWidth},particleHeight:function(){return t.particleHeight}},vertexShaderSource:new i.ShaderSource({sources:[s.default]}),fragmentShaderSource:new i.ShaderSource({sources:[c.default]}),rawRenderState:a.Util.createRawRenderState({viewport:void 0,depthTest:{enabled:!0},depthMask:!0}),framebuffer:this.framebuffers.segments,autoClear:!0}),trails:new o.CustomPrimitive({commandType:"Draw",attributeLocations:{position:0,st:1},geometry:a.Util.getFullscreenQuad(),primitiveType:i.PrimitiveType.TRIANGLES,uniformMap:{segmentsColorTexture:function(){return p.textures.segmentsColor},segmentsDepthTexture:function(){return p.textures.segmentsDepth},currentTrailsColor:function(){return p.framebuffers.currentTrails.getColorTexture(0)},trailsDepthTexture:function(){return p.framebuffers.currentTrails.depthTexture},fadeOpacity:function(){return t.fadeOpacity}},vertexShaderSource:new i.ShaderSource({defines:["DISABLE_GL_POSITION_LOG_DEPTH"],sources:[u.default]}),fragmentShaderSource:new i.ShaderSource({defines:["DISABLE_LOG_DEPTH_FRAGMENT_WRITE"],sources:[l.default]}),rawRenderState:a.Util.createRawRenderState({viewport:void 0,depthTest:{enabled:!0,func:i.DepthFunction.ALWAYS},depthMask:!0}),framebuffer:this.framebuffers.nextTrails,autoClear:!0,preExecute:function(){var e;e=p.framebuffers.currentTrails,p.framebuffers.currentTrails=p.framebuffers.nextTrails,p.framebuffers.nextTrails=e,p.primitives.trails.commandToExecute.framebuffer=p.framebuffers.nextTrails,p.primitives.trails.clearCommand.framebuffer=p.framebuffers.nextTrails}}),screen:new o.CustomPrimitive({commandType:"Draw",attributeLocations:{position:0,st:1},geometry:a.Util.getFullscreenQuad(),primitiveType:i.PrimitiveType.TRIANGLES,uniformMap:{trailsColorTexture:function(){return p.framebuffers.nextTrails.getColorTexture(0)},trailsDepthTexture:function(){return p.framebuffers.nextTrails.depthTexture}},vertexShaderSource:new i.ShaderSource({defines:["DISABLE_GL_POSITION_LOG_DEPTH"],sources:[u.default]}),fragmentShaderSource:new i.ShaderSource({defines:["DISABLE_LOG_DEPTH_FRAGMENT_WRITE"],sources:[d.default]}),rawRenderState:a.Util.createRawRenderState({viewport:void 0,depthTest:{enabled:!1},depthMask:!0,blending:{enabled:!0}}),framebuffer:void 0})}}}]),e}()},function(e,t){e.exports="attribute vec2 st;\r\n// it is not normal itself, but used to control normal\r\nattribute vec3 normal; // (point to use, offset sign, not used component)\r\n\r\nuniform sampler2D currentParticlesPosition;\r\nuniform sampler2D postProcessingPosition;\r\nuniform sampler2D postProcessingSpeed;\r\n\r\nuniform float particleHeight;\r\n\r\nuniform float aspect;\r\nuniform float pixelSize;\r\nuniform float lineWidth;\r\n\r\nvarying float speedNormalization;\r\n\r\nvec3 convertCoordinate(vec3 lonLatLev) {\r\n    // WGS84 (lon, lat, lev) -> ECEF (x, y, z)\r\n    // see https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates for detail\r\n\t\r\n    // WGS 84 geometric constants \r\n    float a = 6378137.0; // Semi-major axis \r\n    float b = 6356752.3142; // Semi-minor axis \r\n    float e2 = 6.69437999014e-3; // First eccentricity squared\r\n\r\n    float latitude = radians(lonLatLev.y);\r\n    float longitude = radians(lonLatLev.x);\r\n\r\n    float cosLat = cos(latitude);\r\n    float sinLat = sin(latitude);\r\n    float cosLon = cos(longitude);\r\n    float sinLon = sin(longitude);\r\n\r\n    float N_Phi = a / sqrt(1.0 - e2 * sinLat * sinLat);\r\n    float h = particleHeight; // it should be high enough otherwise the particle may not pass the terrain depth test\r\n\r\n    vec3 cartesian = vec3(0.0);\r\n    cartesian.x = (N_Phi + h) * cosLat * cosLon;\r\n    cartesian.y = (N_Phi + h) * cosLat * sinLon;\r\n    cartesian.z = ((b * b) / (a * a) * N_Phi + h) * sinLat;\r\n    return cartesian;\r\n}\r\n\r\nvec4 calcProjectedCoord(vec3 lonLatLev) {\r\n    // the range of longitude in Cesium is [-180, 180] but the range of longitude in the NetCDF file is [0, 360]\r\n    // [0, 180] is corresponding to [0, 180] and [180, 360] is corresponding to [-180, 0]\r\n    lonLatLev.x = mod(lonLatLev.x + 180.0, 360.0) - 180.0;\r\n    vec3 particlePosition = convertCoordinate(lonLatLev);\r\n    vec4 projectedCoord = czm_modelViewProjection * vec4(particlePosition, 1.0);\r\n    return projectedCoord;\r\n}\r\n\r\nvec4 calcOffset(vec4 currentProjectedCoord, vec4 nextProjectedCoord, float offsetSign) {\r\n    vec2 aspectVec2 = vec2(aspect, 1.0);\r\n    vec2 currentXY = (currentProjectedCoord.xy / currentProjectedCoord.w) * aspectVec2;\r\n    vec2 nextXY = (nextProjectedCoord.xy / nextProjectedCoord.w) * aspectVec2;\r\n\r\n    float offsetLength = lineWidth / 2.0;\r\n    vec2 direction = normalize(nextXY - currentXY);\r\n    vec2 normalVector = vec2(-direction.y, direction.x);\r\n\tnormalVector.x = normalVector.x / aspect;\r\n    normalVector = offsetLength * normalVector;\r\n\r\n    vec4 offset = vec4(offsetSign * normalVector, 0.0, 0.0);\r\n    return offset;\r\n}\r\n\r\nvoid main() {\r\n    vec2 particleIndex = st;\r\n\t\r\n\tvec3 currentPosition = texture2D(currentParticlesPosition, particleIndex).rgb;\r\n\tvec4 nextPosition = texture2D(postProcessingPosition, particleIndex);\r\n\t\r\n\tvec4 currentProjectedCoord = vec4(0.0);\r\n\tvec4 nextProjectedCoord = vec4(0.0);\r\n\tif (nextPosition.w > 0.0) {\r\n\t\tcurrentProjectedCoord = calcProjectedCoord(currentPosition);\r\n\t\tnextProjectedCoord = calcProjectedCoord(currentPosition);\r\n\t} else {\r\n\t    currentProjectedCoord = calcProjectedCoord(currentPosition);\r\n\t\tnextProjectedCoord = calcProjectedCoord(nextPosition.xyz);\r\n\t}\r\n\r\n\tfloat pointToUse = normal.x; // -1 is currentProjectedCoord and +1 is nextProjectedCoord\r\n\tfloat offsetSign = normal.y;\r\n\t\r\n    vec4 offset = pixelSize * calcOffset(currentProjectedCoord, nextProjectedCoord, offsetSign);\r\n    if (pointToUse < 0.0) {\r\n        gl_Position = currentProjectedCoord + offset;\r\n    } else {\r\n        gl_Position = nextProjectedCoord + offset;\r\n    }\r\n\t\r\n    speedNormalization = texture2D(postProcessingSpeed, particleIndex).a;\r\n}"},function(e,t){e.exports="uniform sampler2D colorTable;\r\n\r\nvarying float speedNormalization;\r\n\r\nvoid main() {\r\n    gl_FragColor = texture2D(colorTable, vec2(speedNormalization, 0.0));\r\n}"},function(e,t){e.exports="attribute vec3 position;\r\nattribute vec2 st;\r\n\r\nvarying vec2 textureCoordinate;\r\n\r\nvoid main() {\r\n    textureCoordinate = st;\r\n\tgl_Position = vec4(position, 1.0);\r\n}"},function(e,t){e.exports="uniform sampler2D segmentsColorTexture;\r\nuniform sampler2D segmentsDepthTexture;\r\n\r\nuniform sampler2D currentTrailsColor;\r\nuniform sampler2D trailsDepthTexture;\r\n\r\nuniform float fadeOpacity;\r\n\r\nvarying vec2 textureCoordinate;\r\n\r\nvoid main() {\r\n    vec4 pointsColor = texture2D(segmentsColorTexture, textureCoordinate);\r\n    vec4 trailsColor = texture2D(currentTrailsColor, textureCoordinate);\r\n\r\n    trailsColor = floor(fadeOpacity * 255.0 * trailsColor) / 255.0; // make sure the trailsColor will be strictly decreased\r\n\r\n    float pointsDepth = texture2D(segmentsDepthTexture, textureCoordinate).r;\r\n    float trailsDepth = texture2D(trailsDepthTexture, textureCoordinate).r;\r\n\tfloat globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, textureCoordinate));\r\n\t\r\n\tgl_FragColor = vec4(0.0);\r\n\tif (pointsDepth < globeDepth) {\r\n\t\tgl_FragColor = gl_FragColor + pointsColor;\r\n\t}\r\n\tif (trailsDepth < globeDepth) {\r\n\t\tgl_FragColor = gl_FragColor + trailsColor;\r\n\t}\r\n\tgl_FragDepthEXT = min(pointsDepth, trailsDepth);\r\n}"},function(e,t){e.exports="uniform sampler2D trailsColorTexture;\r\nuniform sampler2D trailsDepthTexture;\r\n\r\nvarying vec2 textureCoordinate;\r\n\r\nvoid main() {\r\n    vec4 trailsColor = texture2D(trailsColorTexture, textureCoordinate);\r\n    float trailsDepth = texture2D(trailsDepthTexture, textureCoordinate).r;\r\n    float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, textureCoordinate));\r\n\t\r\n    if (trailsDepth < globeDepth) {\r\n        gl_FragColor = trailsColor;\r\n    } else {\r\n        gl_FragColor = vec4(0.0);\r\n    }\r\n}"},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ParticlesComputing=void 0;var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(r(0)),o=r(2),a=r(1),s=p(r(13)),c=p(r(14)),u=p(r(15)),l=p(r(16)),d=p(r(17));function p(e){return e&&e.__esModule?e:{default:e}}t.ParticlesComputing=function(){function e(t,r,n,i){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.data=r,this.createWindTextures(t,r),this.createParticlesTextures(t,n,i),this.createComputingPrimitives(r,n,i)}return n(e,[{key:"createWindTextures",value:function(e,t){var r={context:e,width:t.dimensions.lon,height:t.dimensions.lat*t.dimensions.lev,pixelFormat:i.PixelFormat.LUMINANCE,pixelDatatype:i.PixelDatatype.FLOAT,flipY:!1,sampler:new i.Sampler({minificationFilter:i.TextureMinificationFilter.NEAREST,magnificationFilter:i.TextureMagnificationFilter.NEAREST})};this.windTextures={U:a.Util.createTexture(r,t.U.array),V:a.Util.createTexture(r,t.V.array)}}},{key:"createParticlesTextures",value:function(e,t,r){var n={context:e,width:t.particlesTextureSize,height:t.particlesTextureSize,pixelFormat:i.PixelFormat.RGBA,pixelDatatype:i.PixelDatatype.FLOAT,flipY:!1,sampler:new i.Sampler({minificationFilter:i.TextureMinificationFilter.NEAREST,magnificationFilter:i.TextureMagnificationFilter.NEAREST})},o=this.randomizeParticles(t.maxParticles,r);this.particlesTextures={particlesWind:a.Util.createTexture(n),currentParticlesPosition:a.Util.createTexture(n,o),nextParticlesPosition:a.Util.createTexture(n,o),currentParticlesSpeed:a.Util.createTexture(n),nextParticlesSpeed:a.Util.createTexture(n),postProcessingPosition:a.Util.createTexture(n,o),postProcessingSpeed:a.Util.createTexture(n)}}},{key:"randomizeParticles",value:function(e,t){for(var r=new Float32Array(4*e),n=0;n<e;n++)r[4*n]=i.Math.randomBetween(t.lonRange.x,t.lonRange.y),r[4*n+1]=i.Math.randomBetween(t.latRange.x,t.latRange.y),r[4*n+2]=i.Math.randomBetween(this.data.lev.min,this.data.lev.max),r[4*n+3]=0;return r}},{key:"destroyParticlesTextures",value:function(){var e=this;Object.keys(this.particlesTextures).forEach((function(t){e.particlesTextures[t].destroy()}))}},{key:"createComputingPrimitives",value:function(e,t,r){var n=new i.Cartesian3(e.dimensions.lon,e.dimensions.lat,e.dimensions.lev),a=new i.Cartesian3(e.lon.min,e.lat.min,e.lev.min),p=new i.Cartesian3(e.lon.max,e.lat.max,e.lev.max),m=new i.Cartesian3((p.x-a.x)/(n.x-1),(p.y-a.y)/(n.y-1),n.z>1?(p.z-a.z)/(n.z-1):1),f=new i.Cartesian2(e.U.min,e.U.max),v=new i.Cartesian2(e.V.min,e.V.max),x=this;this.primitives={getWind:new o.CustomPrimitive({commandType:"Compute",uniformMap:{U:function(){return x.windTextures.U},V:function(){return x.windTextures.V},currentParticlesPosition:function(){return x.particlesTextures.currentParticlesPosition},dimension:function(){return n},minimum:function(){return a},maximum:function(){return p},interval:function(){return m}},fragmentShaderSource:new i.ShaderSource({sources:[s.default]}),outputTexture:this.particlesTextures.particlesWind,preExecute:function(){x.primitives.getWind.commandToExecute.outputTexture=x.particlesTextures.particlesWind}}),updateSpeed:new o.CustomPrimitive({commandType:"Compute",uniformMap:{currentParticlesSpeed:function(){return x.particlesTextures.currentParticlesSpeed},particlesWind:function(){return x.particlesTextures.particlesWind},uSpeedRange:function(){return f},vSpeedRange:function(){return v},pixelSize:function(){return r.pixelSize},speedFactor:function(){return t.speedFactor}},fragmentShaderSource:new i.ShaderSource({sources:[c.default]}),outputTexture:this.particlesTextures.nextParticlesSpeed,preExecute:function(){var e;e=x.particlesTextures.currentParticlesSpeed,x.particlesTextures.currentParticlesSpeed=x.particlesTextures.postProcessingSpeed,x.particlesTextures.postProcessingSpeed=e,x.primitives.updateSpeed.commandToExecute.outputTexture=x.particlesTextures.nextParticlesSpeed}}),updatePosition:new o.CustomPrimitive({commandType:"Compute",uniformMap:{currentParticlesPosition:function(){return x.particlesTextures.currentParticlesPosition},currentParticlesSpeed:function(){return x.particlesTextures.currentParticlesSpeed}},fragmentShaderSource:new i.ShaderSource({sources:[u.default]}),outputTexture:this.particlesTextures.nextParticlesPosition,preExecute:function(){var e;e=x.particlesTextures.currentParticlesPosition,x.particlesTextures.currentParticlesPosition=x.particlesTextures.postProcessingPosition,x.particlesTextures.postProcessingPosition=e,x.primitives.updatePosition.commandToExecute.outputTexture=x.particlesTextures.nextParticlesPosition}}),postProcessingPosition:new o.CustomPrimitive({commandType:"Compute",uniformMap:{nextParticlesPosition:function(){return x.particlesTextures.nextParticlesPosition},nextParticlesSpeed:function(){return x.particlesTextures.nextParticlesSpeed},lonRange:function(){return r.lonRange},latRange:function(){return r.latRange},randomCoef:function(){var e=Math.random();return e},dropRate:function(){return t.dropRate},dropRateBump:function(){return t.dropRateBump}},fragmentShaderSource:new i.ShaderSource({sources:[l.default]}),outputTexture:this.particlesTextures.postProcessingPosition,preExecute:function(){x.primitives.postProcessingPosition.commandToExecute.outputTexture=x.particlesTextures.postProcessingPosition}}),postProcessingSpeed:new o.CustomPrimitive({commandType:"Compute",uniformMap:{postProcessingPosition:function(){return x.particlesTextures.postProcessingPosition},nextParticlesSpeed:function(){return x.particlesTextures.nextParticlesSpeed}},fragmentShaderSource:new i.ShaderSource({sources:[d.default]}),outputTexture:this.particlesTextures.postProcessingSpeed,preExecute:function(){x.primitives.postProcessingSpeed.commandToExecute.outputTexture=x.particlesTextures.postProcessingSpeed}})}}}]),e}()},function(e,t){e.exports="// the size of UV textures: width = lon, height = lat*lev\r\nuniform sampler2D U; // eastward wind \r\nuniform sampler2D V; // northward wind\r\n\r\nuniform sampler2D currentParticlesPosition; // (lon, lat, lev)\r\n\r\nuniform vec3 dimension; // (lon, lat, lev)\r\nuniform vec3 minimum; // minimum of each dimension\r\nuniform vec3 maximum; // maximum of each dimension\r\nuniform vec3 interval; // interval of each dimension\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\nvec2 mapPositionToNormalizedIndex2D(vec3 lonLatLev) {\r\n    // ensure the range of longitude and latitude\r\n    lonLatLev.x = mod(lonLatLev.x, 360.0);\r\n    lonLatLev.y = clamp(lonLatLev.y, -90.0, 90.0);\r\n\r\n    vec3 index3D = vec3(0.0);\r\n    index3D.x = (lonLatLev.x - minimum.x) / interval.x;\r\n    index3D.y = (lonLatLev.y - minimum.y) / interval.y;\r\n    index3D.z = (lonLatLev.z - minimum.z) / interval.z;\r\n\r\n    // the st texture coordinate corresponding to (col, row) index\r\n    // example\r\n    // data array is [0, 1, 2, 3, 4, 5], width = 3, height = 2\r\n    // the content of texture will be\r\n    // t 1.0\r\n    //    |  3 4 5\r\n    //    |\r\n    //    |  0 1 2\r\n    //   0.0------1.0 s\r\n\r\n    vec2 index2D = vec2(index3D.x, index3D.z * dimension.y + index3D.y);\r\n    vec2 normalizedIndex2D = vec2(index2D.x / dimension.x, index2D.y / (dimension.y * dimension.z));\r\n    return normalizedIndex2D;\r\n}\r\n\r\nfloat getWind(sampler2D windTexture, vec3 lonLatLev) {\r\n    vec2 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLatLev);\r\n    float result = texture2D(windTexture, normalizedIndex2D).r;\r\n    return result;\r\n}\r\n\r\nconst mat4 kernelMatrix = mat4(\r\n    0.0, -1.0, 2.0, -1.0, // first column\r\n    2.0, 0.0, -5.0, 3.0, // second column\r\n    0.0, 1.0, 4.0, -3.0, // third column\r\n    0.0, 0.0, -1.0, 1.0 // fourth column\r\n);\r\nfloat oneDimensionInterpolation(float t, float p0, float p1, float p2, float p3) {\r\n    vec4 tVec4 = vec4(1.0, t, t * t, t * t * t);\r\n    tVec4 = tVec4 / 2.0;\r\n    vec4 pVec4 = vec4(p0, p1, p2, p3);\r\n    return dot((tVec4 * kernelMatrix), pVec4);\r\n}\r\n\r\nfloat calculateB(sampler2D windTexture, float t, float lon, float lat, float lev) {\r\n    float lon0 = floor(lon) - 1.0 * interval.x;\r\n    float lon1 = floor(lon);\r\n    float lon2 = floor(lon) + 1.0 * interval.x;\r\n    float lon3 = floor(lon) + 2.0 * interval.x;\r\n\r\n    float p0 = getWind(windTexture, vec3(lon0, lat, lev));\r\n    float p1 = getWind(windTexture, vec3(lon1, lat, lev));\r\n    float p2 = getWind(windTexture, vec3(lon2, lat, lev));\r\n    float p3 = getWind(windTexture, vec3(lon3, lat, lev));\r\n\r\n    return oneDimensionInterpolation(t, p0, p1, p2, p3);\r\n}\r\n\r\nfloat interpolateOneTexture(sampler2D windTexture, vec3 lonLatLev) {\r\n    float lon = lonLatLev.x;\r\n    float lat = lonLatLev.y;\r\n    float lev = lonLatLev.z;\r\n\r\n    float lat0 = floor(lat) - 1.0 * interval.y;\r\n    float lat1 = floor(lat);\r\n    float lat2 = floor(lat) + 1.0 * interval.y;\r\n    float lat3 = floor(lat) + 2.0 * interval.y;\r\n\r\n    vec2 coef = lonLatLev.xy - floor(lonLatLev.xy);\r\n    float b0 = calculateB(windTexture, coef.x, lon, lat0, lev);\r\n    float b1 = calculateB(windTexture, coef.x, lon, lat1, lev);\r\n    float b2 = calculateB(windTexture, coef.x, lon, lat2, lev);\r\n    float b3 = calculateB(windTexture, coef.x, lon, lat3, lev);\r\n\r\n    return oneDimensionInterpolation(coef.y, b0, b1, b2, b3);\r\n}\r\n\r\nvec3 bicubic(vec3 lonLatLev) {\r\n    // https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm\r\n    float u = interpolateOneTexture(U, lonLatLev);\r\n    float v = interpolateOneTexture(V, lonLatLev);\r\n    float w = 0.0;\r\n    return vec3(u, v, w);\r\n}\r\n\r\nvoid main() {\r\n    // texture coordinate must be normalized\r\n    vec3 lonLatLev = texture2D(currentParticlesPosition, v_textureCoordinates).rgb;\r\n    vec3 windVector = bicubic(lonLatLev);\r\n\tgl_FragColor = vec4(windVector, 0.0);\r\n}"},function(e,t){e.exports="uniform sampler2D currentParticlesSpeed; // (u, v, w, normalization)\r\nuniform sampler2D particlesWind;\r\n\r\n// use to calculate the relative speed\r\nuniform vec2 uSpeedRange; // (min, max);\r\nuniform vec2 vSpeedRange;\r\nuniform float pixelSize;\r\nuniform float speedFactor;\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\nvec4 calcRelativeSpeed(vec3 speed) {\r\n    vec3 percent = vec3(0.0);\r\n    percent.x = (speed.x - uSpeedRange.x) / (uSpeedRange.y - uSpeedRange.x);\r\n    percent.y = (speed.y - vSpeedRange.x) / (vSpeedRange.y - vSpeedRange.x);\r\n\tfloat normalization = length(percent);\r\n\r\n    float minRelativeSpeed = -speedFactor * pixelSize;\r\n    float maxRelativeSpeed = speedFactor * pixelSize;\r\n\r\n\tvec3 relativeSpeed = vec3(0.0);\r\n    relativeSpeed.x = mix(minRelativeSpeed, maxRelativeSpeed, percent.x);\r\n    relativeSpeed.y = mix(minRelativeSpeed, maxRelativeSpeed, percent.y);\r\n\t\r\n\treturn vec4(relativeSpeed, normalization);\r\n}\r\n\r\nvoid main() {\r\n    // texture coordinate must be normalized\r\n    vec3 currentSpeed = texture2D(currentParticlesSpeed, v_textureCoordinates).rgb;\r\n\tvec3 windVector = texture2D(particlesWind, v_textureCoordinates).rgb;\r\n\t\r\n\tvec4 nextSpeed = calcRelativeSpeed(windVector);\r\n\tgl_FragColor = nextSpeed;\r\n}"},function(e,t){e.exports="uniform sampler2D currentParticlesPosition; // (lon, lat, lev)\r\nuniform sampler2D currentParticlesSpeed; // (u, v, w, normalization)\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\nvec2 lengthOfLonLat(vec3 lonLatLev) {\r\n    // unit conversion: meters -> longitude latitude degrees\r\n    // see https://en.wikipedia.org/wiki/Geographic_coordinate_system#Length_of_a_degree for detail\r\n\r\n    // Calculate the length of a degree of latitude and longitude in meters\r\n    float latitude = radians(lonLatLev.y);\r\n\r\n    float term1 = 111132.92;\r\n    float term2 = 559.82 * cos(2.0 * latitude);\r\n    float term3 = 1.175 * cos(4.0 * latitude);\r\n    float term4 = 0.0023 * cos(6.0 * latitude);\r\n    float latLength = term1 - term2 + term3 - term4;\r\n\r\n    float term5 = 111412.84 * cos(latitude);\r\n    float term6 = 93.5 * cos(3.0 * latitude);\r\n    float term7 = 0.118 * cos(5.0 * latitude);\r\n    float longLength = term5 - term6 + term7;\r\n\r\n    return vec2(longLength, latLength);\r\n}\r\n\r\nvoid updatePosition(vec3 lonLatLev, vec3 speed) {\r\n    vec2 lonlatLengthgth = lengthOfLonLat(lonLatLev);\r\n    float u = speed.x / lonlatLengthgth.x;\r\n    float v = speed.y / lonlatLengthgth.y;\r\n    float w = 0.0;\r\n    vec3 windVectorInLonLatLev = vec3(u, v, w);\r\n\r\n    vec3 nextParticle = lonLatLev + windVectorInLonLatLev;\r\n\r\n    gl_FragColor = vec4(nextParticle, 0.0);\r\n}\r\n\r\nvoid main() {\r\n    // texture coordinate must be normalized\r\n    vec3 lonLatLev = texture2D(currentParticlesPosition, v_textureCoordinates).rgb;\r\n    vec3 speed = texture2D(currentParticlesSpeed, v_textureCoordinates).rgb;\r\n\r\n    updatePosition(lonLatLev, speed);\r\n}"},function(e,t){e.exports="uniform sampler2D nextParticlesPosition;\r\nuniform sampler2D nextParticlesSpeed; // (u, v, w, normalization)\r\n\r\n// range (min, max)\r\nuniform vec2 lonRange;\r\nuniform vec2 latRange;\r\n\r\nuniform float randomCoef; // use to improve the pseudo-random generator\r\nuniform float dropRate; // drop rate is a chance a particle will restart at random position to avoid degeneration\r\nuniform float dropRateBump;\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\n// pseudo-random generator\r\nconst vec3 randomConstants = vec3(12.9898, 78.233, 4375.85453);\r\nconst vec2 normalRange = vec2(0.0, 1.0);\r\nfloat rand(vec2 seed, vec2 range) {\r\n    vec2 randomSeed = randomCoef * seed;\r\n    float temp = dot(randomConstants.xy, randomSeed);\r\n    temp = fract(sin(temp) * (randomConstants.z + temp));\r\n    return temp * (range.y - range.x) + range.x;\r\n}\r\n\r\nvec3 generateRandomParticle(vec2 seed, float lev) {\r\n    // ensure the longitude is in [0, 360]\r\n    float randomLon = mod(rand(seed, lonRange), 360.0);\r\n    float randomLat = rand(-seed, latRange);\r\n\r\n    return vec3(randomLon, randomLat, lev);\r\n}\r\n\r\nbool particleOutbound(vec3 particle) {\r\n    return particle.y < -90.0 || particle.y > 90.0;\r\n}\r\n\r\nvoid main() {\r\n\tvec3 nextParticle = texture2D(nextParticlesPosition, v_textureCoordinates).rgb;\r\n    vec4 nextSpeed = texture2D(nextParticlesSpeed, v_textureCoordinates);\r\n    float particleDropRate = dropRate + dropRateBump * nextSpeed.a;\r\n\r\n    vec2 seed1 = nextParticle.xy + v_textureCoordinates;\r\n    vec2 seed2 = nextSpeed.xy + v_textureCoordinates;\r\n    vec3 randomParticle = generateRandomParticle(seed1, nextParticle.z);\r\n    float randomNumber = rand(seed2, normalRange);\r\n\t\r\n    if (randomNumber < particleDropRate || particleOutbound(nextParticle)) {\r\n\t\tgl_FragColor = vec4(randomParticle, 1.0); // 1.0 means this is a random particle\r\n    } else {\r\n\t\tgl_FragColor = vec4(nextParticle, 0.0);\r\n    }\r\n}"},function(e,t){e.exports="uniform sampler2D postProcessingPosition;\r\nuniform sampler2D nextParticlesSpeed;\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\nvoid main() {\r\n\tvec4 randomParticle = texture2D(postProcessingPosition, v_textureCoordinates);\r\n\tvec4 particleSpeed = texture2D(nextParticlesSpeed, v_textureCoordinates);\r\n\t\r\n    if (randomParticle.a > 0.0) {\r\n\t\tgl_FragColor = vec4(0.0);\r\n    } else {\r\n\t\tgl_FragColor = particleSpeed;\r\n    }\r\n}"}])}));